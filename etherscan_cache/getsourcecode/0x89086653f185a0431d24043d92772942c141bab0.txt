{"status":"1","message":"OK","result":[{"SourceCode":"# @version 0.3.10\r\n#pragma optimize gas\r\n#pragma evm-version shanghai\r\n\"\"\"\r\n@title CryptoFromPoolsRate\r\n@notice Price oracle for pools which contain cryptos and crvUSD. This is NOT suitable for minted crvUSD - only for lent out\r\n        The oracle chains multiple pool oracles, and at the same time applies rate oracles if they are applicable\r\n@author Curve.Fi\r\n@license MIT\r\n\"\"\"\r\n\r\nMAX_COINS: constant(uint256) = 8\r\nMAX_POOLS: constant(uint256) = 8\r\n\r\n\r\ninterface Pool:\r\n    def price_oracle(i: uint256 = 0) -> uint256: view  # Universal method!\r\n    def coins(i: uint256) -> address: view\r\n    def stored_rates() -> DynArray[uint256, MAX_COINS]: view\r\n\r\n\r\nPOOLS: public(immutable(DynArray[Pool, MAX_POOLS]))\r\nBORROWED_IX: public(immutable(DynArray[uint256, MAX_POOLS]))\r\nCOLLATERAL_IX: public(immutable(DynArray[uint256, MAX_POOLS]))\r\nNO_ARGUMENT: public(immutable(DynArray[bool, MAX_POOLS]))\r\nPOOL_COUNT: public(immutable(uint256))\r\nUSE_RATES: public(immutable(DynArray[bool, MAX_POOLS]))\r\n\r\nRATE_MAX_SPEED: constant(uint256) = 10**16 / 60  # Max speed of Rate change\r\n\r\ncached_timestamp: public(uint256)\r\ncached_rate: public(uint256)\r\n\r\n\r\n@external\r\ndef __init__(\r\n        pools: DynArray[Pool, MAX_POOLS],\r\n        borrowed_ixs: DynArray[uint256, MAX_POOLS],\r\n        collateral_ixs: DynArray[uint256, MAX_POOLS]\r\n    ):\r\n    POOLS = pools\r\n    pool_count: uint256 = 0\r\n    no_arguments: DynArray[bool, MAX_POOLS] = empty(DynArray[bool, MAX_POOLS])\r\n    use_rates: DynArray[bool, MAX_POOLS] = empty(DynArray[bool, MAX_POOLS])\r\n\r\n    for i in range(MAX_POOLS):\r\n        if i == len(pools):\r\n            assert i != 0, \"Wrong pool counts\"\r\n            pool_count = i\r\n            break\r\n\r\n        # Find N\r\n        N: uint256 = 0\r\n        for j in range(MAX_COINS + 1):\r\n            success: bool = False\r\n            res: Bytes[32] = empty(Bytes[32])\r\n            success, res = raw_call(\r\n                pools[i].address,\r\n                _abi_encode(j, method_id=method_id(\"coins(uint256)\")),\r\n                max_outsize=32, is_static_call=True, revert_on_failure=False)\r\n            if not success:\r\n                assert j != 0, \"No coins(0)\"\r\n                N = j\r\n                break\r\n\r\n        assert borrowed_ixs[i] != collateral_ixs[i]\r\n        assert borrowed_ixs[i] < N\r\n        assert collateral_ixs[i] < N\r\n\r\n        # Init variables for raw call\r\n        success: bool = False\r\n\r\n        # Check and record if pool requires coin id in argument or no\r\n        if N == 2:\r\n            res: Bytes[32] = empty(Bytes[32])\r\n            success, res = raw_call(\r\n                pools[i].address,\r\n                _abi_encode(empty(uint256), method_id=method_id(\"price_oracle(uint256)\")),\r\n                max_outsize=32, is_static_call=True, revert_on_failure=False)\r\n            if not success:\r\n                no_arguments.append(True)\r\n            else:\r\n                no_arguments.append(False)\r\n        else:\r\n            no_arguments.append(False)\r\n\r\n        res: Bytes[1024] = empty(Bytes[1024])\r\n        success, res = raw_call(pools[i].address, method_id(\"stored_rates()\"), max_outsize=1024, is_static_call=True, revert_on_failure=False)\r\n        stored_rates: DynArray[uint256, MAX_COINS] = empty(DynArray[uint256, MAX_COINS])\r\n        if success and len(res) > 0:\r\n            stored_rates = _abi_decode(res, DynArray[uint256, MAX_COINS])\r\n\r\n        u: bool = False\r\n        for r in stored_rates:\r\n            if r != 10**18:\r\n                u = True\r\n        use_rates.append(u)\r\n\r\n    NO_ARGUMENT = no_arguments\r\n    BORROWED_IX = borrowed_ixs\r\n    COLLATERAL_IX = collateral_ixs\r\n    if pool_count == 0:\r\n        pool_count = MAX_POOLS\r\n    POOL_COUNT = pool_count\r\n    USE_RATES = use_rates\r\n\r\n\r\n@internal\r\n@view\r\ndef _raw_stored_rate() -> uint256:\r\n    rate: uint256 = 10**18\r\n\r\n    for i in range(MAX_POOLS):\r\n        if i == POOL_COUNT:\r\n            break\r\n        if USE_RATES[i]:\r\n            rates: DynArray[uint256, MAX_COINS] = POOLS[i].stored_rates()\r\n            rate = rate * rates[COLLATERAL_IX[i]] / rates[BORROWED_IX[i]]\r\n\r\n    return rate\r\n\r\n\r\n@internal\r\n@view\r\ndef _stored_rate() -> uint256:\r\n    rate: uint256 = self._raw_stored_rate()\r\n    cached_rate: uint256 = self.cached_rate\r\n\r\n    if cached_rate == 0:\r\n        return rate\r\n\r\n    if rate > cached_rate:\r\n        return min(rate, cached_rate * (10**18 + RATE_MAX_SPEED * (block.timestamp - self.cached_timestamp)) / 10**18)\r\n\r\n    else:\r\n        return max(rate, cached_rate * (10**18 - RATE_MAX_SPEED * (block.timestamp - self.cached_timestamp)) / 10**18)\r\n\r\n\r\n@external\r\n@view\r\ndef stored_rate() -> uint256:\r\n    return self._stored_rate()\r\n\r\n\r\n@internal\r\ndef _stored_rate_w() -> uint256:\r\n    rate: uint256 = self._stored_rate()\r\n    self.cached_rate = rate\r\n    self.cached_timestamp = block.timestamp\r\n    return rate\r\n\r\n\r\n@internal\r\n@view\r\ndef _unscaled_price() -> uint256:\r\n    _price: uint256 = 10**18\r\n    for i in range(MAX_POOLS):\r\n        if i >= POOL_COUNT:\r\n            break\r\n        p_borrowed: uint256 = 10**18\r\n        p_collateral: uint256 = 10**18\r\n\r\n        if NO_ARGUMENT[i]:\r\n            p: uint256 = POOLS[i].price_oracle()\r\n            if COLLATERAL_IX[i] > 0:\r\n                p_collateral = p\r\n            else:\r\n                p_borrowed = p\r\n\r\n        else:\r\n            if BORROWED_IX[i] > 0:\r\n                p_borrowed = POOLS[i].price_oracle(unsafe_sub(BORROWED_IX[i], 1))\r\n            if COLLATERAL_IX[i] > 0:\r\n                p_collateral = POOLS[i].price_oracle(unsafe_sub(COLLATERAL_IX[i], 1))\r\n        _price = _price * p_collateral / p_borrowed\r\n    return _price\r\n\r\n\r\n@external\r\n@view\r\ndef price() -> uint256:\r\n    return self._unscaled_price() * self._stored_rate() / 10**18\r\n\r\n\r\n@external\r\ndef price_w() -> uint256:\r\n    return self._unscaled_price() * self._stored_rate_w() / 10**18","ABI":"[{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"pools\",\"type\":\"address[]\"},{\"name\":\"borrowed_ixs\",\"type\":\"uint256[]\"},{\"name\":\"collateral_ixs\",\"type\":\"uint256[]\"}],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"stored_rate\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"price\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"price_w\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"POOLS\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"BORROWED_IX\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"COLLATERAL_IX\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"NO_ARGUMENT\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"POOL_COUNT\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"USE_RATES\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"cached_timestamp\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"cached_rate\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]}]","ContractName":"CryptoFromPoolsRate","CompilerVersion":"vyper:0.3.10","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000000000000020000000000000000000000004ebdf703948ddcea3b11f675b4d1fba9d2414a1400000000000000000000000085de3add465a219ee25e04d22c39ab027cf5c12e000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]}