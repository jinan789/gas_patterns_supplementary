{"status":"1","message":"OK","result":[{"SourceCode":"# @version 0.3.10\r\n\"\"\"\r\n@title Inclusion vote\r\n@author 0xkorin, Yearn Finance\r\n@license GNU AGPLv3\r\n@notice\r\n    Voting contract for inclusion into the pool.\r\n    Time is divided in 4 week epochs. Management configures an epoch in which an\r\n    inclusion vote is ran. Up until the last week of that epoch, any user\r\n    can submit an application on behalf of a token. A fee is potentially charged\r\n    as an anti spam measure.\r\n\r\n    The operator of this contract is tasked with deploying a rate provider for \r\n    protocols that have applied. A protocol that has a rate provider and an application\r\n    is automatically whitelisted for the vote of the current epoch.\r\n\r\n    In the final week of the epoch, all users are able to vote on the whitelisted candidates,\r\n    as well as a 'blank' option, indicating their opposition to all of the candidates.\r\n    The candidate, if any, with the most amount of votes will be whitelisted by the pool governor.\r\n\"\"\"\r\n\r\nfrom vyper.interfaces import ERC20\r\n\r\ninterface Measure:\r\n    def vote_weight(_account: address) -> uint256: view\r\n\r\ngenesis: public(immutable(uint256))\r\nmanagement: public(address)\r\npending_management: public(address)\r\noperator: public(address)\r\ntreasury: public(address)\r\nmeasure: public(address)\r\nenable_epoch: public(uint256)\r\nfinalized_epoch: uint256\r\nnum_candidates: public(HashMap[uint256, uint256]) # epoch => number of candidates\r\ncandidates: public(HashMap[uint256, address[33]]) # epoch => [candidate]\r\ncandidates_map: public(HashMap[uint256, HashMap[address, uint256]]) # epoch => candidate => candidate idx\r\napplications: public(HashMap[address, uint256]) # candidate => last epoch application\r\nrate_providers: public(HashMap[address, address]) # candidate => rate provider\r\n\r\ntotal_votes: public(HashMap[uint256, uint256]) # epoch => total votes\r\nvotes: public(HashMap[uint256, uint256[33]]) # epoch => candidate idx => votes\r\nvotes_user: public(HashMap[address, HashMap[uint256, uint256]]) # user => epoch => votes\r\nwinners: public(HashMap[uint256, address]) # epoch => winner\r\nwinner_rate_providers: public(HashMap[uint256, address]) # epoch => winner rate provider\r\n\r\nfee_token: public(address)\r\ninitial_fee: public(uint256)\r\nsubsequent_fee: public(uint256)\r\n\r\nevent Apply:\r\n    epoch: indexed(uint256)\r\n    token: indexed(address)\r\n    account: address\r\n\r\nevent Whitelist:\r\n    epoch: indexed(uint256)\r\n    token: indexed(address)\r\n    idx: uint256\r\n\r\nevent Vote:\r\n    epoch: indexed(uint256)\r\n    account: indexed(address)\r\n    weight: uint256\r\n    votes: DynArray[uint256, 33]\r\n\r\nevent Finalize:\r\n    epoch: indexed(uint256)\r\n    winner: indexed(address)\r\n\r\nevent SetRateProvider:\r\n    token: indexed(address)\r\n    provider: address\r\n\r\nevent SetEnableEpoch:\r\n    epoch: uint256\r\n\r\nevent SetOperator:\r\n    operator: indexed(address)\r\n\r\nevent SetTreasury:\r\n    treasury: indexed(address)\r\n\r\nevent SetFeeToken:\r\n    fee_token: indexed(address)\r\n\r\nevent SetFees:\r\n    initial: uint256\r\n    subsequent: uint256\r\n\r\nevent SetMeasure:\r\n    measure: indexed(address)\r\n\r\nevent PendingManagement:\r\n    management: indexed(address)\r\n\r\nevent SetManagement:\r\n    management: indexed(address)\r\n\r\nWEEK: constant(uint256) = 7 * 24 * 60 * 60\r\nEPOCH_LENGTH: constant(uint256) = 4 * WEEK\r\nVOTE_LENGTH: constant(uint256) = WEEK\r\nVOTE_START: constant(uint256) = EPOCH_LENGTH - VOTE_LENGTH\r\nVOTE_SCALE: constant(uint256) = 10_000\r\nAPPLICATION_DISABLED: constant(address) = 0x0000000000000000000000000000000000000001\r\n\r\n@external\r\ndef __init__(_genesis: uint256, _measure: address, _fee_token: address):\r\n    \"\"\"\r\n    @notice Constructor\r\n    @param _genesis Timestamp of start of epoch 0\r\n    @param _measure Vote weight measure\r\n    @param _fee_token Application fee token\r\n    \"\"\"\r\n    assert _genesis <= block.timestamp\r\n    genesis = _genesis\r\n    self.management = msg.sender\r\n    self.operator = msg.sender\r\n    self.treasury = msg.sender\r\n    self.measure = _measure\r\n    self.fee_token = _fee_token\r\n    \r\n    epoch: uint256 = self._epoch()\r\n    assert epoch > 0\r\n    self.finalized_epoch = epoch - 1\r\n\r\n@external\r\n@view\r\ndef epoch() -> uint256:\r\n    \"\"\"\r\n    @notice Get the current epoch\r\n    @return Current epoch\r\n    \"\"\"\r\n    return self._epoch()\r\n\r\n@internal\r\n@view\r\ndef _epoch() -> uint256:\r\n    \"\"\"\r\n    @notice Get the current epoch\r\n    \"\"\"\r\n    return (block.timestamp - genesis) / EPOCH_LENGTH\r\n\r\n@external\r\n@view\r\ndef apply_open() -> bool:\r\n    \"\"\"\r\n    @notice Query whether the application period is currently open\r\n    @return True: application period is open, False: application period is closed\r\n    \"\"\"\r\n    return not self._vote_open()\r\n\r\n@external\r\n@view\r\ndef vote_open() -> bool:\r\n    \"\"\"\r\n    @notice Query whether the vote period is currently open\r\n    @return True: vote period is open, False: vote period is closed\r\n    \"\"\"\r\n    return self._vote_open()\r\n\r\n@internal\r\n@view\r\ndef _vote_open() -> bool:\r\n    \"\"\"\r\n    @notice Query whether the vote period is currently open\r\n    \"\"\"\r\n    return self._enabled() and (block.timestamp - genesis) % EPOCH_LENGTH >= VOTE_START\r\n\r\n@external\r\n@view\r\ndef enabled() -> bool:\r\n    \"\"\"\r\n    @notice Query whether the inclusion voting is enabled this epoch\r\n    @return True: inclusion vote is enabled this epoch, False: inclusion vote is not enabled\r\n    \"\"\"\r\n    return self._enabled()\r\n\r\n@internal\r\n@view\r\ndef _enabled() -> bool:\r\n    \"\"\"\r\n    @notice Query whether the inclusion voting is enabled this epoch\r\n    \"\"\"\r\n    return self._epoch() == self.enable_epoch\r\n\r\n@external\r\n@view\r\ndef has_applied(_token: address) -> bool:\r\n    \"\"\"\r\n    @notice Query whether a token has applied for the next inclusion vote\r\n    @param _token Token address to query for\r\n    @return True: token has applied, False: token has not applied\r\n    \"\"\"\r\n    application_epoch: uint256 = self.applications[_token]\r\n    return application_epoch == max_value(uint256) or \\\r\n        (self._enabled() and application_epoch == self._epoch())        \r\n\r\n@external\r\n@view\r\ndef application_fee(_token: address) -> uint256:\r\n    \"\"\"\r\n    @notice Get the application fee for a specific token\r\n    @param _token Token address to get fee for\r\n    @return Application fee\r\n    \"\"\"\r\n    assert self.rate_providers[_token] != APPLICATION_DISABLED\r\n    if self.applications[_token] == 0:\r\n        return self.initial_fee\r\n    return self.subsequent_fee\r\n\r\n@external\r\ndef apply(_token: address):\r\n    \"\"\"\r\n    @notice\r\n        Apply for a token to be included into the pool. Each token can only apply once per voting round.\r\n        Included assets can no longer apply to be included.\r\n        Charges a fee, dependent on whether the application is the first one \r\n        or a follow up in a subsequent epoch.\r\n        If the token already has a rate provider configured, it will be automatically whitelisted\r\n        for the voting procedure.\r\n    @param _token Token address to apply for\r\n    \"\"\"\r\n    epoch: uint256 = self._epoch()\r\n    enable_epoch: uint256 = self.enable_epoch\r\n    if epoch > enable_epoch:\r\n        # if we're past the voting round, make sure it is finalized\r\n        assert self.finalized_epoch >= enable_epoch\r\n\r\n    enabled: bool = self._enabled()\r\n    assert not self._vote_open()\r\n    \r\n    if enabled:\r\n        assert self.num_candidates[epoch] < 32\r\n    else:\r\n        epoch = max_value(uint256)\r\n\r\n    application_epoch: uint256 = self.applications[_token]\r\n    assert epoch > application_epoch, \"already applied\"\r\n    self.applications[_token] = epoch\r\n\r\n    provider: address = self.rate_providers[_token]\r\n    assert provider != APPLICATION_DISABLED\r\n    if provider != empty(address) and enabled:\r\n        self._whitelist(epoch, _token)\r\n\r\n    fee: uint256 = 0\r\n    if application_epoch == 0:\r\n        fee = self.initial_fee\r\n    else:\r\n        fee = self.subsequent_fee\r\n    if fee > 0:\r\n        assert ERC20(self.fee_token).transferFrom(msg.sender, self, fee, default_return_value=True)\r\n    log Apply(epoch, _token, msg.sender)\r\n\r\n@external\r\ndef whitelist(_tokens: DynArray[address, 32]):\r\n    \"\"\"\r\n    @notice Whitelist tokens that applied outside of the voting epoch\r\n    @param _tokens Array of tokens to whitelist\r\n    @dev Can be called by anyone\r\n    \"\"\"\r\n    epoch: uint256 = self._epoch()\r\n    assert self._enabled()\r\n    assert not self._vote_open()\r\n    for token in _tokens:\r\n        assert self.num_candidates[epoch] < 32\r\n        assert self.applications[token] == max_value(uint256)\r\n        assert self.rate_providers[token] not in [empty(address), APPLICATION_DISABLED]\r\n        self.applications[token] = epoch\r\n        self._whitelist(epoch, token)\r\n\r\n@internal\r\ndef _whitelist(_epoch: uint256, _token: address):\r\n    \"\"\"\r\n    @notice Whitelist a token, assumes all preconditions are met\r\n    \"\"\"\r\n    n: uint256 = self.num_candidates[_epoch] + 1\r\n    self.num_candidates[_epoch] = n\r\n    self.candidates[_epoch][n] = _token\r\n    self.candidates_map[_epoch][_token] = n\r\n    log Whitelist(_epoch, _token, n)\r\n\r\n@external\r\ndef vote(_votes: DynArray[uint256, 33]):\r\n    \"\"\"\r\n    @notice\r\n        Vote for preferred candidates. The first entry corresponds to a 'blank' vote,\r\n        meaning no new asset is to be added to the pool.\r\n        Votes are in basispoints and must add to 100%\r\n    @param _votes List of votes in bps\r\n    \"\"\"\r\n    epoch: uint256 = self._epoch()\r\n    assert self._vote_open()\r\n    assert self.votes_user[msg.sender][epoch] == 0\r\n\r\n    n: uint256 = self.num_candidates[epoch] + 1\r\n    assert len(_votes) <= n\r\n\r\n    weight: uint256 = Measure(self.measure).vote_weight(msg.sender)\r\n    assert weight > 0\r\n    self.total_votes[epoch] += weight\r\n    self.votes_user[msg.sender][epoch] = weight\r\n\r\n    total: uint256 = 0\r\n    for i in range(33):\r\n        if i == len(_votes):\r\n            break\r\n        if _votes[i] == 0:\r\n            continue\r\n\r\n        votes: uint256 = _votes[i] * weight / VOTE_SCALE\r\n        self.votes[epoch][i] += votes\r\n        \r\n        total += _votes[i]\r\n\r\n    assert total == VOTE_SCALE\r\n    log Vote(epoch, msg.sender, weight, _votes)\r\n\r\n@external\r\n@view\r\ndef latest_finalized_epoch() -> uint256:\r\n    \"\"\"\r\n    @notice Get the latest finalized epoch\r\n    @return Latest finalized epoch\r\n    \"\"\"\r\n    epoch: uint256 = self._epoch() - 1\r\n    enable_epoch: uint256 = self.enable_epoch\r\n    if epoch < enable_epoch or enable_epoch == 0:\r\n        return epoch\r\n    return max(self.finalized_epoch, enable_epoch - 1)\r\n\r\n@external\r\ndef finalize_epochs():\r\n    \"\"\"\r\n    @notice Finalize epochs, if possible. Will determine the winner of the vote after epoch has ended\r\n    \"\"\"\r\n    epoch: uint256 = self._epoch() - 1\r\n    if self.finalized_epoch == epoch:\r\n        # nothing to finalize\r\n        return\r\n    self.finalized_epoch = epoch\r\n\r\n    enable: uint256 = self.enable_epoch\r\n    if epoch < enable or enable == 0:\r\n        # no epochs where voting has been enabled\r\n        return\r\n    epoch = enable\r\n\r\n    # find candidate with most votes\r\n    n: uint256 = self.num_candidates[epoch] + 1\r\n    winner: address = empty(address)\r\n    winner_votes: uint256 = 0\r\n    for i in range(33):\r\n        if i == n:\r\n            break\r\n        votes: uint256 = self.votes[epoch][i]\r\n        if votes > winner_votes:\r\n            candidate: address = self.candidates[epoch][i]\r\n            if candidate != empty(address) and self.rate_providers[candidate] in [empty(address), APPLICATION_DISABLED]:\r\n                # operator could have unset rate provider after\r\n                continue\r\n            winner = candidate\r\n            winner_votes = votes\r\n\r\n    self.winners[epoch] = winner\r\n    if winner != empty(address):\r\n        self.winner_rate_providers[epoch] = self.rate_providers[winner]\r\n        self.rate_providers[winner] = APPLICATION_DISABLED\r\n    log Finalize(epoch, winner)\r\n\r\n@external\r\ndef set_rate_provider(_token: address, _provider: address):\r\n    \"\"\"\r\n    @notice\r\n        Set a rate provider of a token. Will automatically whitelist the token\r\n        for the vote if there already is an application in this epoch.\r\n    @param _token Candidate token to set rate provider for\r\n    @param _provider Rate provider address\r\n    \"\"\"\r\n    epoch: uint256 = self._epoch()\r\n    assert msg.sender == self.operator\r\n    assert (not self._vote_open() and self.finalized_epoch + 1 == epoch) or \\\r\n        _provider == empty(address)\r\n    self.rate_providers[_token] = _provider\r\n    log SetRateProvider(_token, _provider)\r\n\r\n    if _provider not in [empty(address), APPLICATION_DISABLED] and \\\r\n        self.applications[_token] == epoch and self.num_candidates[epoch] < 32 and \\\r\n        self.candidates_map[epoch][_token] == 0:\r\n        # whitelist token for vote if it has an application for this epoch\r\n        self._whitelist(epoch, _token)\r\n\r\n@external\r\ndef sweep(_token: address, _recipient: address = msg.sender):\r\n    \"\"\"\r\n    @notice Sweep application fees and other tokens from this contract\r\n    @param _token Token to sweep\r\n    @param _recipient Recipient of the swept tokens\r\n    \"\"\"\r\n    assert msg.sender == self.treasury\r\n    amount: uint256 = ERC20(_token).balanceOf(self)\r\n    if amount > 0:\r\n        assert ERC20(_token).transfer(_recipient, amount, default_return_value=True)\r\n\r\n@external\r\ndef set_operator(_operator: address):\r\n    \"\"\"\r\n    @notice Set the operator. The operator is responsible for setting rate providers for the applicants\r\n    @param _operator New operator address\r\n    \"\"\"\r\n    assert msg.sender == self.management or msg.sender == self.operator\r\n    self.operator = _operator\r\n    log SetOperator(_operator)\r\n\r\n@external\r\ndef set_treasury(_treasury: address):\r\n    \"\"\"\r\n    @notice Set the treasury. The treasury can sweep (application fee) tokens\r\n    @param _treasury New treasury address\r\n    \"\"\"\r\n    assert msg.sender == self.treasury\r\n    self.treasury = _treasury\r\n    log SetTreasury(_treasury)\r\n\r\n@external\r\ndef set_measure(_measure: address):\r\n    \"\"\"\r\n    @notice Set vote weight measure contract\r\n    @param _measure New vote weight measure\r\n    \"\"\"\r\n    assert msg.sender == self.management\r\n    assert _measure != empty(address)\r\n    assert not self._vote_open()\r\n    self.measure = _measure\r\n    log SetMeasure(_measure)\r\n\r\n@external\r\ndef set_enable_epoch(_epoch: uint256):\r\n    \"\"\"\r\n    @notice Enable the inclusion vote procedure for a specific epoch\r\n    \"\"\"\r\n    assert msg.sender == self.management\r\n    assert not self._vote_open()\r\n    assert _epoch >= self._epoch()\r\n    assert self.finalized_epoch >= self.enable_epoch\r\n\r\n    self.enable_epoch = _epoch\r\n    log SetEnableEpoch(_epoch)\r\n\r\n@external\r\ndef set_application_fee_token(_token: address):\r\n    \"\"\"\r\n    @notice Set token in which application fees are charged\r\n    @param _token Token in which fees are charged\r\n    \"\"\"\r\n    assert msg.sender == self.management\r\n    assert _token != empty(address)\r\n    self.fee_token = _token\r\n    log SetFeeToken(_token)\r\n\r\n@external\r\ndef set_application_fees(_initial: uint256, _subsequent: uint256):\r\n    \"\"\"\r\n    @notice Set application fees\r\n    @param _initial Initial fee, to be paid on first application\r\n    @param _subsequent Subsequent fee, to be paid on any follow up application\r\n    \"\"\"\r\n    assert msg.sender == self.management\r\n    self.initial_fee = _initial\r\n    self.subsequent_fee = _subsequent\r\n    log SetFees(_initial, _subsequent)\r\n\r\n@external\r\ndef set_management(_management: address):\r\n    \"\"\"\r\n    @notice \r\n        Set the pending management address.\r\n        Needs to be accepted by that account separately to transfer management over\r\n    @param _management New pending management address\r\n    \"\"\"\r\n    assert msg.sender == self.management\r\n    self.pending_management = _management\r\n    log PendingManagement(_management)\r\n\r\n@external\r\ndef accept_management():\r\n    \"\"\"\r\n    @notice \r\n        Accept management role.\r\n        Can only be called by account previously marked as pending management by current management\r\n    \"\"\"\r\n    assert msg.sender == self.pending_management\r\n    self.pending_management = empty(address)\r\n    self.management = msg.sender\r\n    log SetManagement(msg.sender)","ABI":"[{\"name\":\"Apply\",\"inputs\":[{\"name\":\"epoch\",\"type\":\"uint256\",\"indexed\":true},{\"name\":\"token\",\"type\":\"address\",\"indexed\":true},{\"name\":\"account\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Whitelist\",\"inputs\":[{\"name\":\"epoch\",\"type\":\"uint256\",\"indexed\":true},{\"name\":\"token\",\"type\":\"address\",\"indexed\":true},{\"name\":\"idx\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Vote\",\"inputs\":[{\"name\":\"epoch\",\"type\":\"uint256\",\"indexed\":true},{\"name\":\"account\",\"type\":\"address\",\"indexed\":true},{\"name\":\"weight\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"votes\",\"type\":\"uint256[]\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Finalize\",\"inputs\":[{\"name\":\"epoch\",\"type\":\"uint256\",\"indexed\":true},{\"name\":\"winner\",\"type\":\"address\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetRateProvider\",\"inputs\":[{\"name\":\"token\",\"type\":\"address\",\"indexed\":true},{\"name\":\"provider\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetEnableEpoch\",\"inputs\":[{\"name\":\"epoch\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetOperator\",\"inputs\":[{\"name\":\"operator\",\"type\":\"address\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetTreasury\",\"inputs\":[{\"name\":\"treasury\",\"type\":\"address\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetFeeToken\",\"inputs\":[{\"name\":\"fee_token\",\"type\":\"address\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetFees\",\"inputs\":[{\"name\":\"initial\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"subsequent\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetMeasure\",\"inputs\":[{\"name\":\"measure\",\"type\":\"address\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"PendingManagement\",\"inputs\":[{\"name\":\"management\",\"type\":\"address\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetManagement\",\"inputs\":[{\"name\":\"management\",\"type\":\"address\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"_genesis\",\"type\":\"uint256\"},{\"name\":\"_measure\",\"type\":\"address\"},{\"name\":\"_fee_token\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"epoch\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"apply_open\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"vote_open\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"enabled\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"has_applied\",\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"application_fee\",\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"apply\",\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"whitelist\",\"inputs\":[{\"name\":\"_tokens\",\"type\":\"address[]\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"vote\",\"inputs\":[{\"name\":\"_votes\",\"type\":\"uint256[]\"}],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"latest_finalized_epoch\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"finalize_epochs\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_rate_provider\",\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_provider\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"sweep\",\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"sweep\",\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_recipient\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_operator\",\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_treasury\",\"inputs\":[{\"name\":\"_treasury\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_measure\",\"inputs\":[{\"name\":\"_measure\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_enable_epoch\",\"inputs\":[{\"name\":\"_epoch\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_application_fee_token\",\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_application_fees\",\"inputs\":[{\"name\":\"_initial\",\"type\":\"uint256\"},{\"name\":\"_subsequent\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_management\",\"inputs\":[{\"name\":\"_management\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"accept_management\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"genesis\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"management\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"pending_management\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"operator\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"treasury\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"measure\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"enable_epoch\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"num_candidates\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"candidates\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"},{\"name\":\"arg1\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"candidates_map\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"},{\"name\":\"arg1\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"applications\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"rate_providers\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"total_votes\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"votes\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"},{\"name\":\"arg1\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"votes_user\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"},{\"name\":\"arg1\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"winners\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"winner_rate_providers\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"fee_token\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"initial_fee\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"subsequent_fee\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]}]","ContractName":"Inclusion vote","CompilerVersion":"vyper:0.3.10","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000064d4288000000000000000000000000052574a10ce418afef388e39cea61643d33dba81d0000000000000000000000001bed97cbc3c24a4fb5c069c6e311a967386131f7","EVMVersion":"Default","Library":"","LicenseType":"GNU AGPLv3","Proxy":"0","Implementation":"","SwarmSource":""}]}