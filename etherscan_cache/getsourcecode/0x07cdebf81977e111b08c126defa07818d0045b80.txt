{"status":"1","message":"OK","result":[{"SourceCode":"# pragma version 0.3.10\r\n# pragma optimize gas\r\n# pragma evm-version paris\r\n\"\"\"\r\n@title CurveCryptoViews2Optimized\r\n@author Curve.Fi\r\n@license Copyright (c) Curve.Fi, 2020-2023 - all rights reserved\r\n@notice This contract contains view-only external methods which can be\r\n        gas-inefficient when called from smart contracts.\r\n\"\"\"\r\n\r\nfrom vyper.interfaces import ERC20\r\n\r\n\r\ninterface Curve:\r\n    def MATH() -> Math: view\r\n    def A() -> uint256: view\r\n    def gamma() -> uint256: view\r\n    def price_scale() -> uint256: view\r\n    def price_oracle() -> uint256: view\r\n    def get_virtual_price() -> uint256: view\r\n    def balances(i: uint256) -> uint256: view\r\n    def D() -> uint256: view\r\n    def fee_calc(xp: uint256[N_COINS]) -> uint256: view\r\n    def calc_token_fee(\r\n        amounts: uint256[N_COINS], xp: uint256[N_COINS]\r\n    ) -> uint256: view\r\n    def future_A_gamma_time() -> uint256: view\r\n    def totalSupply() -> uint256: view\r\n    def precisions() -> uint256[N_COINS]: view\r\n    def packed_fee_params() -> uint256: view\r\n\r\n\r\ninterface Math:\r\n    def newton_D(\r\n        ANN: uint256,\r\n        gamma: uint256,\r\n        x_unsorted: uint256[N_COINS],\r\n        K0_prev: uint256\r\n    ) -> uint256: view\r\n    def get_y(\r\n        ANN: uint256,\r\n        gamma: uint256,\r\n        x: uint256[N_COINS],\r\n        D: uint256,\r\n        i: uint256,\r\n    ) -> uint256[2]: view\r\n    def newton_y(\r\n        ANN: uint256,\r\n        gamma: uint256,\r\n        x: uint256[N_COINS],\r\n        D: uint256,\r\n        i: uint256,\r\n    ) -> uint256: view\r\n\r\n\r\nN_COINS: constant(uint256) = 2\r\nPRECISION: constant(uint256) = 10**18\r\n\r\n\r\n@external\r\n@view\r\ndef get_dy(\r\n    i: uint256, j: uint256, dx: uint256, swap: address\r\n) -> uint256:\r\n\r\n    dy: uint256 = 0\r\n    xp: uint256[N_COINS] = empty(uint256[N_COINS])\r\n\r\n    # dy = (get_y(x + dx) - y) * (1 - fee)\r\n    dy, xp = self._get_dy_nofee(i, j, dx, swap)\r\n    dy -= Curve(swap).fee_calc(xp) * dy / 10**10\r\n\r\n    return dy\r\n\r\n\r\n@view\r\n@external\r\ndef get_dx(\r\n    i: uint256, j: uint256, dy: uint256, swap: address\r\n) -> uint256:\r\n\r\n    dx: uint256 = 0\r\n    xp: uint256[N_COINS] = empty(uint256[N_COINS])\r\n    fee_dy: uint256 = 0\r\n    _dy: uint256 = dy\r\n\r\n    # for more precise dx (but never exact), increase num loops\r\n    for k in range(5):\r\n        dx, xp = self._get_dx_fee(i, j, _dy, swap)\r\n        fee_dy = Curve(swap).fee_calc(xp) * _dy / 10**10\r\n        _dy = dy + fee_dy + 1\r\n\r\n    return dx\r\n\r\n\r\n@view\r\n@external\r\ndef calc_withdraw_one_coin(\r\n    token_amount: uint256, i: uint256, swap: address\r\n) -> uint256:\r\n\r\n    return self._calc_withdraw_one_coin(token_amount, i, swap)[0]\r\n\r\n\r\n@view\r\n@external\r\ndef calc_token_amount(\r\n    amounts: uint256[N_COINS], deposit: bool, swap: address\r\n) -> uint256:\r\n\r\n    d_token: uint256 = 0\r\n    amountsp: uint256[N_COINS] = empty(uint256[N_COINS])\r\n    xp: uint256[N_COINS] = empty(uint256[N_COINS])\r\n\r\n    d_token, amountsp, xp = self._calc_dtoken_nofee(amounts, deposit, swap)\r\n    d_token -= (\r\n        Curve(swap).calc_token_fee(amountsp, xp) * d_token / 10**10 + 1\r\n    )\r\n\r\n    return d_token\r\n\r\n\r\n@external\r\n@view\r\ndef calc_fee_get_dy(i: uint256, j: uint256, dx: uint256, swap: address\r\n) -> uint256:\r\n\r\n    dy: uint256 = 0\r\n    xp: uint256[N_COINS] = empty(uint256[N_COINS])\r\n    dy, xp = self._get_dy_nofee(i, j, dx, swap)\r\n\r\n    return Curve(swap).fee_calc(xp) * dy / 10**10\r\n\r\n\r\n@external\r\n@view\r\ndef calc_fee_withdraw_one_coin(\r\n    token_amount: uint256, i: uint256, swap: address\r\n) -> uint256:\r\n\r\n    return self._calc_withdraw_one_coin(token_amount, i, swap)[1]\r\n\r\n\r\n@view\r\n@external\r\ndef calc_fee_token_amount(\r\n    amounts: uint256[N_COINS], deposit: bool, swap: address\r\n) -> uint256:\r\n\r\n    d_token: uint256 = 0\r\n    amountsp: uint256[N_COINS] = empty(uint256[N_COINS])\r\n    xp: uint256[N_COINS] = empty(uint256[N_COINS])\r\n    d_token, amountsp, xp = self._calc_dtoken_nofee(amounts, deposit, swap)\r\n\r\n    return Curve(swap).calc_token_fee(amountsp, xp) * d_token / 10**10 + 1\r\n\r\n\r\n@internal\r\n@view\r\ndef _calc_D_ramp(\r\n    A: uint256,\r\n    gamma: uint256,\r\n    xp: uint256[N_COINS],\r\n    precisions: uint256[N_COINS],\r\n    price_scale: uint256,\r\n    swap: address\r\n) -> uint256:\r\n\r\n    math: Math = Curve(swap).MATH()\r\n    D: uint256 = Curve(swap).D()\r\n    if Curve(swap).future_A_gamma_time() > block.timestamp:\r\n        _xp: uint256[N_COINS] = xp\r\n        _xp[0] *= precisions[0]\r\n        _xp[1] = _xp[1] * price_scale * precisions[1] / PRECISION\r\n        D = math.newton_D(A, gamma, _xp, 0)\r\n\r\n    return D\r\n\r\n\r\n@internal\r\n@view\r\ndef _get_dx_fee(\r\n    i: uint256, j: uint256, dy: uint256, swap: address\r\n) -> (uint256, uint256[N_COINS]):\r\n\r\n    # here, dy must include fees (and 1 wei offset)\r\n\r\n    assert i != j and i < N_COINS and j < N_COINS, \"coin index out of range\"\r\n    assert dy > 0, \"do not exchange out 0 coins\"\r\n\r\n    math: Math = Curve(swap).MATH()\r\n\r\n    xp: uint256[N_COINS] = empty(uint256[N_COINS])\r\n    precisions: uint256[N_COINS] = empty(uint256[N_COINS])\r\n    price_scale: uint256 = 0\r\n    D: uint256 = 0\r\n    token_supply: uint256 = 0\r\n    A: uint256 = 0\r\n    gamma: uint256 = 0\r\n\r\n    xp, D, token_supply, price_scale, A, gamma, precisions = self._prep_calc(swap)\r\n\r\n    # adjust xp with output dy. dy contains fee element, which we handle later\r\n    # (hence this internal method is called _get_dx_fee)\r\n    xp[j] -= dy\r\n    xp = [xp[0] * precisions[0], xp[1] * price_scale * precisions[1] / PRECISION]\r\n\r\n    x_out: uint256[2] = math.get_y(A, gamma, xp, D, i)\r\n    dx: uint256 = x_out[0] - xp[i]\r\n    xp[i] = x_out[0]\r\n\r\n    if i > 0:\r\n        dx = dx * PRECISION / price_scale\r\n    dx /= precisions[i]\r\n\r\n    return dx, xp\r\n\r\n\r\n@internal\r\n@view\r\ndef _get_dy_nofee(\r\n    i: uint256, j: uint256, dx: uint256, swap: address\r\n) -> (uint256, uint256[N_COINS]):\r\n\r\n    assert i != j and i < N_COINS and j < N_COINS, \"coin index out of range\"\r\n    assert dx > 0, \"do not exchange 0 coins\"\r\n\r\n    math: Math = Curve(swap).MATH()\r\n\r\n    xp: uint256[N_COINS] = empty(uint256[N_COINS])\r\n    precisions: uint256[N_COINS] = empty(uint256[N_COINS])\r\n    price_scale: uint256 = 0\r\n    D: uint256 = 0\r\n    token_supply: uint256 = 0\r\n    A: uint256 = 0\r\n    gamma: uint256 = 0\r\n\r\n    xp, D, token_supply, price_scale, A, gamma, precisions = self._prep_calc(swap)\r\n\r\n    # adjust xp with input dx\r\n    xp[i] += dx\r\n    xp = [\r\n        xp[0] * precisions[0],\r\n        xp[1] * price_scale * precisions[1] / PRECISION\r\n    ]\r\n\r\n    y_out: uint256[2] = math.get_y(A, gamma, xp, D, j)\r\n\r\n    dy: uint256 = xp[j] - y_out[0] - 1\r\n    xp[j] = y_out[0]\r\n    if j > 0:\r\n        dy = dy * PRECISION / price_scale\r\n    dy /= precisions[j]\r\n\r\n    return dy, xp\r\n\r\n\r\n@internal\r\n@view\r\ndef _calc_dtoken_nofee(\r\n    amounts: uint256[N_COINS], deposit: bool, swap: address\r\n) -> (uint256, uint256[N_COINS], uint256[N_COINS]):\r\n\r\n    math: Math = Curve(swap).MATH()\r\n\r\n    xp: uint256[N_COINS] = empty(uint256[N_COINS])\r\n    precisions: uint256[N_COINS] = empty(uint256[N_COINS])\r\n    price_scale: uint256 = 0\r\n    D0: uint256 = 0\r\n    token_supply: uint256 = 0\r\n    A: uint256 = 0\r\n    gamma: uint256 = 0\r\n\r\n    xp, D0, token_supply, price_scale, A, gamma, precisions = self._prep_calc(swap)\r\n\r\n    amountsp: uint256[N_COINS] = amounts\r\n    if deposit:\r\n        for k in range(N_COINS):\r\n            xp[k] += amounts[k]\r\n    else:\r\n        for k in range(N_COINS):\r\n            xp[k] -= amounts[k]\r\n\r\n    xp = [\r\n        xp[0] * precisions[0],\r\n        xp[1] * price_scale * precisions[1] / PRECISION\r\n    ]\r\n    amountsp = [\r\n        amountsp[0]* precisions[0],\r\n        amountsp[1] * price_scale * precisions[1] / PRECISION\r\n    ]\r\n\r\n    D: uint256 = math.newton_D(A, gamma, xp, 0)\r\n    d_token: uint256 = token_supply * D / D0\r\n\r\n    if deposit:\r\n        d_token -= token_supply\r\n    else:\r\n        d_token = token_supply - d_token\r\n\r\n    return d_token, amountsp, xp\r\n\r\n\r\n@internal\r\n@view\r\ndef _calc_withdraw_one_coin(\r\n    token_amount: uint256,\r\n    i: uint256,\r\n    swap: address\r\n) -> (uint256, uint256):\r\n\r\n    token_supply: uint256 = Curve(swap).totalSupply()\r\n    assert token_amount <= token_supply  # dev: token amount more than supply\r\n    assert i < N_COINS  # dev: coin out of range\r\n\r\n    math: Math = Curve(swap).MATH()\r\n\r\n    xx: uint256[N_COINS] = empty(uint256[N_COINS])\r\n    for k in range(N_COINS):\r\n        xx[k] = Curve(swap).balances(k)\r\n\r\n    precisions: uint256[N_COINS] = Curve(swap).precisions()\r\n    A: uint256 = Curve(swap).A()\r\n    gamma: uint256 = Curve(swap).gamma()\r\n    D0: uint256 = 0\r\n    p: uint256 = 0\r\n\r\n    price_scale_i: uint256 = Curve(swap).price_scale() * precisions[1]\r\n    xp: uint256[N_COINS] = [\r\n        xx[0] * precisions[0],\r\n        unsafe_div(xx[1] * price_scale_i, PRECISION)\r\n    ]\r\n    if i == 0:\r\n        price_scale_i = PRECISION * precisions[0]\r\n\r\n    if Curve(swap).future_A_gamma_time() > block.timestamp:\r\n        D0 = math.newton_D(A, gamma, xp, 0)\r\n    else:\r\n        D0 = Curve(swap).D()\r\n\r\n    D: uint256 = D0\r\n\r\n    fee: uint256 = self._fee(xp, swap)\r\n    dD: uint256 = token_amount * D / token_supply\r\n\r\n    D_fee: uint256 = fee * dD / (2 * 10**10) + 1\r\n    approx_fee: uint256 = N_COINS * D_fee * xx[i] / D\r\n\r\n    D -= (dD - D_fee)\r\n\r\n    y_out: uint256[2] = math.get_y(A, gamma, xp, D, i)\r\n    dy: uint256 = (xp[i] - y_out[0]) * PRECISION / price_scale_i\r\n    xp[i] = y_out[0]\r\n\r\n    return dy, approx_fee\r\n\r\n\r\n@internal\r\n@view\r\ndef _fee(xp: uint256[N_COINS], swap: address) -> uint256:\r\n\r\n    packed_fee_params: uint256 = Curve(swap).packed_fee_params()\r\n    fee_params: uint256[3] = self._unpack_3(packed_fee_params)\r\n    f: uint256 = xp[0] + xp[1]\r\n    f = fee_params[2] * 10**18 / (\r\n        fee_params[2] + 10**18 -\r\n        (10**18 * N_COINS**N_COINS) * xp[0] / f * xp[1] / f\r\n    )\r\n\r\n    return (fee_params[0] * f + fee_params[1] * (10**18 - f)) / 10**18\r\n\r\n\r\n@internal\r\n@view\r\ndef _prep_calc(swap: address) -> (\r\n    uint256[N_COINS],\r\n    uint256,\r\n    uint256,\r\n    uint256,\r\n    uint256,\r\n    uint256,\r\n    uint256[N_COINS]\r\n):\r\n\r\n    precisions: uint256[N_COINS] = Curve(swap).precisions()\r\n    token_supply: uint256 = Curve(swap).totalSupply()\r\n    xp: uint256[N_COINS] = empty(uint256[N_COINS])\r\n    for k in range(N_COINS):\r\n        xp[k] = Curve(swap).balances(k)\r\n\r\n    price_scale: uint256 = Curve(swap).price_scale()\r\n\r\n    A: uint256 = Curve(swap).A()\r\n    gamma: uint256 = Curve(swap).gamma()\r\n    D: uint256 = self._calc_D_ramp(\r\n        A, gamma, xp, precisions, price_scale, swap\r\n    )\r\n\r\n    return xp, D, token_supply, price_scale, A, gamma, precisions\r\n\r\n\r\n@internal\r\n@view\r\ndef _unpack_3(_packed: uint256) -> uint256[3]:\r\n    \"\"\"\r\n    @notice Unpacks a uint256 into 3 integers (values must be <= 10**18)\r\n    @param val The uint256 to unpack\r\n    @return The unpacked uint256[3]\r\n    \"\"\"\r\n    return [\r\n        (_packed >> 128) & 18446744073709551615,\r\n        (_packed >> 64) & 18446744073709551615,\r\n        _packed & 18446744073709551615,\r\n    ]","ABI":"[{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_dy\",\"inputs\":[{\"name\":\"i\",\"type\":\"uint256\"},{\"name\":\"j\",\"type\":\"uint256\"},{\"name\":\"dx\",\"type\":\"uint256\"},{\"name\":\"swap\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_dx\",\"inputs\":[{\"name\":\"i\",\"type\":\"uint256\"},{\"name\":\"j\",\"type\":\"uint256\"},{\"name\":\"dy\",\"type\":\"uint256\"},{\"name\":\"swap\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"calc_withdraw_one_coin\",\"inputs\":[{\"name\":\"token_amount\",\"type\":\"uint256\"},{\"name\":\"i\",\"type\":\"uint256\"},{\"name\":\"swap\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"calc_token_amount\",\"inputs\":[{\"name\":\"amounts\",\"type\":\"uint256[2]\"},{\"name\":\"deposit\",\"type\":\"bool\"},{\"name\":\"swap\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"calc_fee_get_dy\",\"inputs\":[{\"name\":\"i\",\"type\":\"uint256\"},{\"name\":\"j\",\"type\":\"uint256\"},{\"name\":\"dx\",\"type\":\"uint256\"},{\"name\":\"swap\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"calc_fee_withdraw_one_coin\",\"inputs\":[{\"name\":\"token_amount\",\"type\":\"uint256\"},{\"name\":\"i\",\"type\":\"uint256\"},{\"name\":\"swap\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"calc_fee_token_amount\",\"inputs\":[{\"name\":\"amounts\",\"type\":\"uint256[2]\"},{\"name\":\"deposit\",\"type\":\"bool\"},{\"name\":\"swap\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]}]","ContractName":"CurveCryptoViews2Optimized","CompilerVersion":"vyper:0.3.10","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":""}]}