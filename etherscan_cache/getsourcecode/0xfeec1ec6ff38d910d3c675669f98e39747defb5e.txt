{"status":"1","message":"OK","result":[{"SourceCode":"# @version 0.3.7\r\n\"\"\"\r\n@title Cvg-Finance - veCVG\r\n@notice Votes have a weight depending on time, so that users are committed to the future of (whatever they are voting for).\r\n@dev Vote weight decays linearly over time. Lock time cannot be more than `MAXTIME` (1.8 years).\r\n\"\"\"\r\n\r\n# Adpated fork from: Curve Finance's veCrv\r\n# Many thanks to Curve Finance\r\n\r\n# VotingPowerEscow to have time-weighted votes\r\n# Votes have a weight depending on time, so that users are committed\r\n# to the future of (whatever they are voting for).\r\n# The weight in this implementation is linear, and lock cannot be more than maxtime:\r\n# w ^\r\n# 1 +        /\r\n#   |      /\r\n#   |    /\r\n#   |  /\r\n#   |/\r\n# 0 +--------+------> time\r\n#       maxtime (1.8 years?)\r\n\r\nstruct Point:\r\n    bias: int128\r\n    slope: int128  # - dweight / dt\r\n    ts: uint256\r\n    blk: uint256  # block\r\n# We cannot really do block numbers per se b/c slope is per time, not per block\r\n# and per block could be fairly bad b/c Ethereum changes blocktimes.\r\n# What we can do is to extrapolate ***At functions\r\n\r\nstruct LockedBalance:\r\n    amount: int128\r\n    end: uint256\r\n\r\ninterface CvgControlTower:\r\n    def lockingPositionService() -> address: view\r\n    def treasuryDao() -> address:view\r\n\r\nDEPOSIT_FOR_TYPE: constant(int128) = 0\r\nCREATE_LOCK_TYPE: constant(int128) = 1\r\nINCREASE_LOCK_AMOUNT: constant(int128) = 2\r\nINCREASE_UNLOCK_TIME: constant(int128) = 3 # to be removed unless we implement the increasing of lock time\r\n\r\n\r\nevent CommitOwnership:\r\n    admin: address\r\n\r\nevent ApplyOwnership:\r\n    admin: address\r\n\r\nevent Deposit:\r\n    provider: indexed(uint256)\r\n    value: uint256\r\n    locktime: indexed(uint256)\r\n    type: int128\r\n    ts: uint256\r\n\r\nevent Withdraw:\r\n    provider: indexed(uint256)\r\n    value: uint256\r\n    ts: uint256\r\n\r\nevent Supply:\r\n    prevSupply: uint256\r\n    supply: uint256\r\n\r\n\r\nWEEK: constant(uint256) = 7 * 86400  # all future times are rounded by week\r\nMAXTIME: constant(uint256) = 97 * WEEK  \r\nMULTIPLIER: constant(uint256) = 10 ** 18\r\n\r\ncvg_control_tower: public(address)\r\nsupply: public(uint256)\r\nlocked: public(HashMap[uint256, LockedBalance]) # Locked balance of the NFT\r\n\r\nepoch: public(uint256)\r\npoint_history: public(Point[100000000000000000000000000000])  # epoch -> unsigned point\r\nnft_point_history: public(HashMap[uint256, Point[1000000000]])  # tokenId -> Point[user_epoch]\r\nnft_point_epoch: public(HashMap[uint256, uint256])\r\nslope_changes: public(HashMap[uint256, int128])  # time -> signed slope change\r\n\r\nname: public(String[64])\r\nsymbol: public(String[32])\r\nversion: public(String[32])\r\ndecimals: public(uint256)\r\n\r\nadmin: public(address)  # Can and will be a smart contract\r\nfuture_admin: public(address)\r\n\r\ninitialized: public(bool)\r\n\r\n@external\r\ndef __init__():\r\n    \"\"\"\r\n    @notice Contract constructor.\r\n    @dev The contract has an initializer to prevent the take over of the implementation.\r\n    \"\"\"\r\n    assert self.initialized == False, \"ALREADY_INIT\" #dev: contract is already initialized\r\n    self.initialized = True\r\n\r\n@external\r\ndef initialize(_cvg_control_tower: address, _name: String[64], _symbol: String[32], _version: String[32]):\r\n    \"\"\"\r\n    @notice Contract constructor.\r\n    @param _cvg_control_tower address\r\n    @param _name Token name\r\n    @param _symbol Token symbol\r\n    \"\"\"\r\n    assert self.initialized == False, \"ALREADY_INIT\" #dev: contract is already initialized\r\n    self.initialized = True\r\n    self.cvg_control_tower = _cvg_control_tower\r\n    self.point_history[0].blk = block.number\r\n    self.point_history[0].ts = block.timestamp\r\n\r\n    self.decimals = 18\r\n    self.name = _name\r\n    self.symbol = _symbol\r\n    self.version = _version\r\n\r\n@internal\r\ndef assert_locking_service_contract(addr: address):\r\n    \"\"\"\r\n    @dev Check if the call is the NFT locking service.\r\n    @param addr Address to be checked\r\n    \"\"\"\r\n    assert addr == CvgControlTower(self.cvg_control_tower).lockingPositionService(), \"NOT_LOCKING_SERVICE\" # Not the locking service\r\n\r\n\r\n@external\r\n@view\r\ndef get_last_nft_slope(tokenId: uint256) -> int128:\r\n    \"\"\"\r\n    @notice Get the most recently recorded rate of voting power decrease for `tokenId`.\r\n    @param tokenId NFT token Id\r\n    @return Value of the slope\r\n    \"\"\"\r\n    token_epoch: uint256 = self.nft_point_epoch[tokenId]\r\n    return self.nft_point_history[tokenId][token_epoch].slope\r\n\r\n\r\n@external\r\n@view\r\ndef nft_point_history_ts(_tokenId: uint256, _idx: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Get the timestamp for checkpoint `_idx` for `_tokenId`.\r\n    @param _tokenId NFT token Id\r\n    @param _idx User epoch number\r\n    @return Epoch time of the checkpoint\r\n    \"\"\"\r\n    return self.nft_point_history[_tokenId][_idx].ts\r\n\r\n\r\n@external\r\n@view\r\ndef locked__end(_tokenId: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Get timestamp when `_tokenId`'s lock finishes.\r\n    @param _tokenId NFT token Id\r\n    @return Epoch time of the lock end\r\n    \"\"\"\r\n    return self.locked[_tokenId].end\r\n\r\n\r\n@internal\r\ndef _checkpoint(tokenId: uint256, old_locked: LockedBalance, new_locked: LockedBalance):\r\n    \"\"\"\r\n    @dev Record global and per-user data to checkpoint.\r\n    @param tokenId of the NFT that embed the locking position\r\n    @param old_locked Pevious locked amount / end lock time for the user\r\n    @param new_locked New locked amount / end lock time for the user\r\n    \"\"\"\r\n    tokenId_old: Point = empty(Point)\r\n    tokenId_new: Point = empty(Point)\r\n    old_dslope: int128 = 0\r\n    new_dslope: int128 = 0\r\n    _epoch: uint256 = self.epoch\r\n\r\n    if tokenId != 0:\r\n        # Calculate slopes and biases\r\n        # Kept at zero when they have to\r\n        if old_locked.end > block.timestamp and old_locked.amount > 0:\r\n            tokenId_old.slope = old_locked.amount / convert(MAXTIME, int128)\r\n            tokenId_old.bias = tokenId_old.slope * convert(old_locked.end - block.timestamp, int128)\r\n        if new_locked.end > block.timestamp and new_locked.amount > 0:\r\n            tokenId_new.slope = new_locked.amount / convert(MAXTIME, int128)\r\n            tokenId_new.bias = tokenId_new.slope * convert(new_locked.end - block.timestamp, int128)\r\n\r\n        # Read values of scheduled changes in the slope\r\n        # old_locked.end can be in the past and in the future\r\n        # new_locked.end can ONLY by in the FUTURE unless everything expired: than zeros\r\n        old_dslope = self.slope_changes[old_locked.end]\r\n        if new_locked.end != 0:\r\n            if new_locked.end == old_locked.end:\r\n                new_dslope = old_dslope\r\n            else:\r\n                new_dslope = self.slope_changes[new_locked.end]\r\n\r\n    last_point: Point = Point({bias: 0, slope: 0, ts: block.timestamp, blk: block.number})\r\n    if _epoch > 0:\r\n        last_point = self.point_history[_epoch]\r\n    last_checkpoint: uint256 = last_point.ts\r\n    # initial_last_point is used for extrapolation to calculate block number\r\n    # (approximately, for *At methods) and save them\r\n    # as we cannot figure that out exactly from inside the contract\r\n    initial_last_point: Point = last_point\r\n    block_slope: uint256 = 0  # dblock/dt\r\n    if block.timestamp > last_point.ts:\r\n        block_slope = MULTIPLIER * (block.number - last_point.blk) / (block.timestamp - last_point.ts)\r\n    # If last point is already recorded in this block, slope=0\r\n    # But that's ok b/c we know the block in such case\r\n\r\n    # Go over weeks to fill history and calculate what the current point is\r\n    t_i: uint256 = (last_checkpoint / WEEK) * WEEK\r\n    for i in range(255):\r\n        # Hopefully it won't happen that this won't get used in 5 years!\r\n        # If it does, users will be able to withdraw but vote weight will be broken\r\n        t_i += WEEK\r\n        d_slope: int128 = 0\r\n        if t_i > block.timestamp:\r\n            t_i = block.timestamp\r\n        else:\r\n            d_slope = self.slope_changes[t_i]\r\n        last_point.bias -= last_point.slope * convert(t_i - last_checkpoint, int128)\r\n        last_point.slope += d_slope\r\n        if last_point.bias < 0:  # This can happen\r\n            last_point.bias = 0\r\n        if last_point.slope < 0:  # This cannot happen - just in case\r\n            last_point.slope = 0\r\n        last_checkpoint = t_i\r\n        last_point.ts = t_i\r\n        last_point.blk = initial_last_point.blk + block_slope * (t_i - initial_last_point.ts) / MULTIPLIER\r\n        _epoch += 1\r\n        if t_i == block.timestamp:\r\n            last_point.blk = block.number\r\n            break\r\n        else:\r\n            self.point_history[_epoch] = last_point\r\n\r\n    self.epoch = _epoch\r\n    # Now point_history is filled until t=now\r\n    if tokenId != 0:\r\n        # If last point was in this block, the slope change has been applied already\r\n        # But in such case we have 0 slope(s)\r\n        last_point.slope += (tokenId_new.slope - tokenId_old.slope)\r\n        last_point.bias += (tokenId_new.bias - tokenId_old.bias)\r\n        if last_point.slope < 0:\r\n            last_point.slope = 0\r\n        if last_point.bias < 0:\r\n            last_point.bias = 0\r\n\r\n    # Record the changed point into history\r\n    self.point_history[_epoch] = last_point\r\n\r\n    if tokenId != 0:\r\n        # Schedule the slope changes (slope is going down)\r\n        # We subtract new_tokeId_slope from [new_locked.end]\r\n        # and tokenId old_tokenId_slope to [old_locked.end]\r\n        if old_locked.end > block.timestamp:\r\n            # old_dslope was <something> - tokenId_old.slope, so we cancel that\r\n            old_dslope += tokenId_old.slope\r\n            if new_locked.end == old_locked.end:\r\n                old_dslope -= tokenId_new.slope  # It was a new deposit, not extension\r\n            self.slope_changes[old_locked.end] = old_dslope\r\n\r\n        if new_locked.end > block.timestamp:\r\n            if new_locked.end > old_locked.end:\r\n                new_dslope -= tokenId_new.slope  # old slope disappeared at this point\r\n                self.slope_changes[new_locked.end] = new_dslope\r\n            # else: we recorded it already in old_dslope\r\n\r\n        # Now handle user history\r\n        nft_epoch: uint256 = self.nft_point_epoch[tokenId] + 1\r\n\r\n        self.nft_point_epoch[tokenId] = nft_epoch\r\n        tokenId_new.ts = block.timestamp\r\n        tokenId_new.blk = block.number\r\n        self.nft_point_history[tokenId][nft_epoch] = tokenId_new\r\n\r\n\r\n@internal\r\ndef _deposit_for(_tokenId: uint256, _value: uint256, unlock_time: uint256, locked_balance: LockedBalance, type: int128):\r\n    \"\"\"\r\n    @dev Deposit and lock tokens for a user.\r\n    @param _tokenId of the NFT\r\n    @param _value Amount to deposit\r\n    @param unlock_time New time when to unlock the tokens, or 0 if unchanged\r\n    @param locked_balance Previous locked amount / timestamp\r\n    \"\"\"\r\n    _locked: LockedBalance = locked_balance\r\n    supply_before: uint256 = self.supply\r\n\r\n    self.supply = supply_before + _value\r\n    old_locked: LockedBalance = _locked\r\n    # Adding to existing lock, or if a lock is expired - creating a new one\r\n    _locked.amount += convert(_value, int128)\r\n    if unlock_time != 0:\r\n        _locked.end = unlock_time\r\n    self.locked[_tokenId] = _locked\r\n\r\n    # Possibilities:\r\n    # Both old_locked.end could be current or expired (>/< block.timestamp)\r\n    # value == 0 (extend lock) or value > 0 (add to lock or extend lock)\r\n    # _locked.end > block.timestamp (always)\r\n    self._checkpoint(_tokenId, old_locked, _locked)\r\n\r\n    log Deposit(_tokenId, _value, _locked.end, type, block.timestamp)\r\n    log Supply(supply_before, supply_before + _value)\r\n\r\n\r\n@external\r\ndef checkpoint():\r\n    \"\"\"\r\n    @notice Record global data to checkpoint.\r\n    \"\"\"\r\n    self._checkpoint(0, empty(LockedBalance), empty(LockedBalance))\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef create_lock(_tokenId: uint256, _value: uint256, _unlock_time: uint256):\r\n    \"\"\"\r\n    @notice Deposit `_value` tokens for `msg.sender` and lock until `_unlock_time`.\r\n    @param _value Amount to deposit\r\n    @param _unlock_time Epoch time when tokens unlock, rounded down to whole weeks\r\n    \"\"\"\r\n    self.assert_locking_service_contract(msg.sender)\r\n    unlock_time: uint256 = (_unlock_time / WEEK) * WEEK  # Locktime is rounded down to weeks\r\n    _locked: LockedBalance = self.locked[_tokenId]\r\n\r\n    assert _value > 0, \"Value 0\"  # dev: need non-zero value\r\n    assert _locked.amount == 0, \"Withdraw old tokens first\"\r\n    assert unlock_time > block.timestamp, \"Can only lock until time in the future\"\r\n    assert unlock_time <= block.timestamp + MAXTIME, \"Voting lock can be 1.8 years max\" # 1 week buffer to take in account the time we can take after 1 week to update the cycle\r\n\r\n    self._deposit_for(_tokenId, _value, unlock_time, _locked, CREATE_LOCK_TYPE)\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef increase_amount(_tokenId: uint256, _value: uint256):\r\n    \"\"\"\r\n    @notice Deposit `_value` additional tokens for `msg.sender`.\r\n            without modifying the unlock time\r\n    @param _value Amount of tokens to deposit and add to the lock\r\n    \"\"\"\r\n    self.assert_locking_service_contract(msg.sender)\r\n    _locked: LockedBalance = self.locked[_tokenId]\r\n\r\n    assert _value > 0, \"Value 0\"  # dev: need non-zero value\r\n    assert _locked.amount > 0, \"No existing lock found\"\r\n    assert _locked.end > block.timestamp, \"Cannot add to expired lock. Withdraw\"\r\n\r\n    self._deposit_for(_tokenId, _value, 0, _locked, INCREASE_LOCK_AMOUNT)\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef increase_unlock_time(_tokenId: uint256, _unlock_time: uint256):\r\n    \"\"\"\r\n    @notice Extend the unlock time for `msg.sender` to `_unlock_time`.\r\n    @param _unlock_time New epoch time for unlocking\r\n    \"\"\"\r\n    self.assert_locking_service_contract(msg.sender)\r\n    _locked: LockedBalance = self.locked[_tokenId]\r\n    unlock_time: uint256 = (_unlock_time / WEEK) * WEEK  # Locktime is rounded down to weeks\r\n\r\n    assert _locked.end > block.timestamp, \"Lock expired\"\r\n    assert _locked.amount > 0, \"Nothing is locked\"\r\n    assert unlock_time > _locked.end, \"Can only increase lock duration\"\r\n    assert unlock_time <= block.timestamp + MAXTIME, \"Voting lock can be 1.8 years max\" # 1 week buffer to take in account the time we can take after 1 week to update the cycle\r\n\r\n    self._deposit_for(_tokenId, 0, unlock_time, _locked, INCREASE_UNLOCK_TIME)\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef increase_unlock_time_and_amount(_tokenId: uint256, _unlock_time: uint256, _value: uint256):\r\n    \"\"\"\r\n    @notice Extend the unlock time for `msg.sender` to `_unlock_time` and then the amount of Locked CVG\r\n    @param _unlock_time New epoch time for unlocking\r\n    @param _value Amount of CVG to add in the lock\r\n    \"\"\"\r\n    self.assert_locking_service_contract(msg.sender)\r\n    _locked: LockedBalance = self.locked[_tokenId]\r\n    unlock_time: uint256 = (_unlock_time / WEEK) * WEEK  # Locktime is rounded down to weeks\r\n\r\n    assert _value > 0, \"Value 0\"  # dev: need non-zero value\r\n    assert _locked.end > block.timestamp, \"Lock expired\"\r\n    assert _locked.amount > 0, \"Nothing is locked\"\r\n    assert unlock_time > _locked.end, \"Can only increase lock duration\"\r\n    assert unlock_time <= block.timestamp + MAXTIME, \"Voting lock can be 1.8 years max\" # 1 week buffer to take in account the time we can take after 1 week to update the cycle\r\n\r\n    self._deposit_for(_tokenId, 0, unlock_time, _locked, INCREASE_UNLOCK_TIME)\r\n    self._deposit_for(_tokenId, _value, 0, self.locked[_tokenId], INCREASE_LOCK_AMOUNT)\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef withdraw(_tokenId: uint256):\r\n    \"\"\"\r\n    @notice Withdraw all tokens for `msg.sender`.\r\n    @dev Only possible if the lock has expired.\r\n    \"\"\"\r\n    self.assert_locking_service_contract(msg.sender)\r\n    _locked: LockedBalance = self.locked[_tokenId]\r\n    assert block.timestamp >= _locked.end, \"The lock didn't expire\"\r\n    value: uint256 = convert(_locked.amount, uint256)\r\n\r\n    old_locked: LockedBalance = _locked\r\n    _locked.end = 0\r\n    _locked.amount = 0\r\n    self.locked[_tokenId] = _locked\r\n    supply_before: uint256 = self.supply\r\n    self.supply = supply_before - value\r\n\r\n    # old_locked can have either expired <= timestamp or zero end\r\n    # _locked has only 0 end\r\n    # Both can have >= 0 amount\r\n    self._checkpoint(_tokenId, old_locked, _locked)\r\n\r\n    log Withdraw(_tokenId, value, block.timestamp)\r\n    log Supply(supply_before, supply_before - value)\r\n\r\n\r\n# The following ERC20/minime-compatible methods are not real balanceOf and supply!\r\n# They measure the weights for the purpose of voting, so they don't represent\r\n# real coins.\r\n\r\n@internal\r\n@view\r\ndef find_block_epoch(_block: uint256, max_epoch: uint256) -> uint256:\r\n    \"\"\"\r\n    @dev Binary search to estimate timestamp for block number.\r\n    @param _block Block to find\r\n    @param max_epoch Don't go beyond this epoch\r\n    @return Approximate timestamp for block\r\n    \"\"\"\r\n    # Binary search\r\n    _min: uint256 = 0\r\n    _max: uint256 = max_epoch\r\n    for i in range(128):  # Will be always enough for 128-bit numbers\r\n        if _min >= _max:\r\n            break\r\n        _mid: uint256 = (_min + _max + 1) / 2\r\n        if self.point_history[_mid].blk <= _block:\r\n            _min = _mid\r\n        else:\r\n            _max = _mid - 1\r\n    return _min\r\n\r\n\r\n@external\r\n@view\r\ndef balanceOf(_tokenId: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Get the current voting power for the tokenId of the NFT collection `LockingPositionManager`.\r\n    @dev Adheres to the ERC20 `balanceOf` interface for Aragon compatibility.\r\n    @param _tokenId of the NFT\r\n    @return User voting power\r\n    \"\"\"\r\n    _epoch: uint256 = self.nft_point_epoch[_tokenId]\r\n    if _epoch == 0:\r\n        return 0\r\n    else:\r\n        last_point: Point = self.nft_point_history[_tokenId][_epoch]\r\n        last_point.bias -= last_point.slope * convert(block.timestamp - last_point.ts, int128)\r\n        if last_point.bias < 0:\r\n            last_point.bias = 0\r\n        return convert(last_point.bias, uint256)\r\n\r\n\r\n@external\r\n@view\r\ndef balanceOfAt(_tokenId: uint256, _block: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Measure voting power of `_tokenId` at block height `_block`.\r\n    @dev Adheres to MiniMe `balanceOfAt` interface: https://github.com/Giveth/minime.\r\n    @param _tokenId of the NFT\r\n    @param _block Block to calculate the voting power at\r\n    @return Voting power\r\n    \"\"\"\r\n    # Copying and pasting totalSupply code because Vyper cannot pass by\r\n    # reference yet\r\n    assert _block <= block.number\r\n\r\n    # Binary search\r\n    _min: uint256 = 0\r\n    _max: uint256 = self.nft_point_epoch[_tokenId]\r\n    for i in range(128):  # Will be always enough for 128-bit numbers\r\n        if _min >= _max:\r\n            break\r\n        _mid: uint256 = (_min + _max + 1) / 2\r\n        if self.nft_point_history[_tokenId][_mid].blk <= _block:\r\n            _min = _mid\r\n        else:\r\n            _max = _mid - 1\r\n\r\n    upoint: Point = self.nft_point_history[_tokenId][_min]\r\n\r\n    max_epoch: uint256 = self.epoch\r\n    _epoch: uint256 = self.find_block_epoch(_block, max_epoch)\r\n    point_0: Point = self.point_history[_epoch]\r\n    d_block: uint256 = 0\r\n    d_t: uint256 = 0\r\n    if _epoch < max_epoch:\r\n        point_1: Point = self.point_history[_epoch + 1]\r\n        d_block = point_1.blk - point_0.blk\r\n        d_t = point_1.ts - point_0.ts\r\n    else:\r\n        d_block = block.number - point_0.blk\r\n        d_t = block.timestamp - point_0.ts\r\n    block_time: uint256 = point_0.ts\r\n    if d_block != 0:\r\n        block_time += d_t * (_block - point_0.blk) / d_block\r\n\r\n    upoint.bias -= upoint.slope * convert(block_time - upoint.ts, int128)\r\n    if upoint.bias >= 0:\r\n        return convert(upoint.bias, uint256)\r\n    else:\r\n        return 0\r\n\r\n\r\n@internal\r\n@view\r\ndef supply_at(point: Point, t: uint256) -> uint256:\r\n    \"\"\"\r\n    @dev Calculate total voting power at some point in the past.\r\n    @param point The point (bias/slope) to start search from\r\n    @param t Time to calculate the total voting power at\r\n    @return Total voting power at that time\r\n    \"\"\"\r\n    last_point: Point = point\r\n    t_i: uint256 = (last_point.ts / WEEK) * WEEK\r\n    for i in range(255):\r\n        t_i += WEEK\r\n        d_slope: int128 = 0\r\n        if t_i > t:\r\n            t_i = t\r\n        else:\r\n            d_slope = self.slope_changes[t_i]\r\n        last_point.bias -= last_point.slope * convert(t_i - last_point.ts, int128)\r\n        if t_i == t:\r\n            break\r\n        last_point.slope += d_slope\r\n        last_point.ts = t_i\r\n\r\n    if last_point.bias < 0:\r\n        last_point.bias = 0\r\n    return convert(last_point.bias, uint256)\r\n\r\n\r\n@external\r\n@view\r\ndef total_supply() -> uint256:\r\n    \"\"\"\r\n    @notice Calculate total voting power.\r\n    @dev Adheres to the ERC20 `totalSupply` interface for Aragon compatibility.\r\n    @return Total voting power\r\n    \"\"\"\r\n    _epoch: uint256 = self.epoch\r\n    last_point: Point = self.point_history[_epoch]\r\n    return self.supply_at(last_point, block.timestamp)\r\n\r\n\r\n@external\r\n@view\r\ndef totalSupplyAt(_block: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Calculate total voting power at some point in the past.\r\n    @param _block Block to calculate the total voting power at\r\n    @return Total voting power at `_block`\r\n    \"\"\"\r\n    assert _block <= block.number\r\n    _epoch: uint256 = self.epoch\r\n    target_epoch: uint256 = self.find_block_epoch(_block, _epoch)\r\n\r\n    point: Point = self.point_history[target_epoch]\r\n    dt: uint256 = 0\r\n    if target_epoch < _epoch:\r\n        point_next: Point = self.point_history[target_epoch + 1]\r\n        if point.blk != point_next.blk:\r\n            dt = (_block - point.blk) * (point_next.ts - point.ts) / (point_next.blk - point.blk)\r\n    else:\r\n        if point.blk != block.number:\r\n            dt = (_block - point.blk) * (block.timestamp - point.ts) / (block.number - point.blk)\r\n    # Now dt contains info on how far are we beyond point\r\n\r\n    return self.supply_at(point, point.ts + dt)","ABI":"[{\"name\":\"CommitOwnership\",\"inputs\":[{\"name\":\"admin\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"ApplyOwnership\",\"inputs\":[{\"name\":\"admin\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Deposit\",\"inputs\":[{\"name\":\"provider\",\"type\":\"uint256\",\"indexed\":true},{\"name\":\"value\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"locktime\",\"type\":\"uint256\",\"indexed\":true},{\"name\":\"type\",\"type\":\"int128\",\"indexed\":false},{\"name\":\"ts\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Withdraw\",\"inputs\":[{\"name\":\"provider\",\"type\":\"uint256\",\"indexed\":true},{\"name\":\"value\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"ts\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Supply\",\"inputs\":[{\"name\":\"prevSupply\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"supply\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"initialize\",\"inputs\":[{\"name\":\"_cvg_control_tower\",\"type\":\"address\"},{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"},{\"name\":\"_version\",\"type\":\"string\"}],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_last_nft_slope\",\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"int128\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"nft_point_history_ts\",\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_idx\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"locked__end\",\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"checkpoint\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"create_lock\",\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_unlock_time\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"increase_amount\",\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"increase_unlock_time\",\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_unlock_time\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"increase_unlock_time_and_amount\",\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_unlock_time\",\"type\":\"uint256\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"withdraw\",\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"balanceOf\",\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"balanceOfAt\",\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_block\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"total_supply\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"totalSupplyAt\",\"inputs\":[{\"name\":\"_block\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"cvg_control_tower\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"supply\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"locked\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"tuple\",\"components\":[{\"name\":\"amount\",\"type\":\"int128\"},{\"name\":\"end\",\"type\":\"uint256\"}]}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"epoch\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"point_history\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"tuple\",\"components\":[{\"name\":\"bias\",\"type\":\"int128\"},{\"name\":\"slope\",\"type\":\"int128\"},{\"name\":\"ts\",\"type\":\"uint256\"},{\"name\":\"blk\",\"type\":\"uint256\"}]}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"nft_point_history\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"},{\"name\":\"arg1\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"tuple\",\"components\":[{\"name\":\"bias\",\"type\":\"int128\"},{\"name\":\"slope\",\"type\":\"int128\"},{\"name\":\"ts\",\"type\":\"uint256\"},{\"name\":\"blk\",\"type\":\"uint256\"}]}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"nft_point_epoch\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"slope_changes\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"int128\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"name\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"string\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"symbol\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"string\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"version\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"string\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"decimals\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"admin\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"future_admin\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"initialized\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]}]","ContractName":"Cvg-Finance - veCVG","CompilerVersion":"vyper:0.3.7","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":""}]}