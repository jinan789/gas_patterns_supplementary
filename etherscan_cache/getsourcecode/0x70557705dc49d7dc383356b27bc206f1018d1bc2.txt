{"status":"1","message":"OK","result":[{"SourceCode":"# @version 0.3.10\r\n\"\"\"\r\n@title Incentives for inclusion vote\r\n@author 0xkorin, Yearn Finance\r\n@license GNU AGPLv3\r\n@notice\r\n    Permissionlessly submit incentives for assets inclusion in the pool.\r\n    Incentives are only paid out for the winning asset each epoch,\r\n    all other incentives are refunded.\r\n    Winner's incentives are paid out to all voters, regardless of whether they voted\r\n    on the winner or on another candidate.\r\n    Incentives that remain unclaimed for a preconfigured number of epochs\r\n    are considered expired and can be swept away.\r\n\"\"\"\r\n\r\nfrom vyper.interfaces import ERC20\r\n\r\ninterface Voting:\r\n    def genesis() -> uint256: view\r\n    def latest_finalized_epoch() -> uint256: view\r\n    def winners(_epoch: uint256) -> address: view\r\n    def total_votes(_epoch: uint256) -> uint256: view\r\n    def votes_user(_account: address, _epoch: uint256) -> uint256: view\r\n\r\ngenesis: public(immutable(uint256))\r\nvoting: public(immutable(Voting))\r\nmanagement: public(address)\r\npending_management: public(address)\r\ntreasury: public(address)\r\nfee_rate: public(uint256)\r\nincentives: public(HashMap[uint256, HashMap[address, HashMap[address, uint256]]]) # epoch => candidate => incentive token => incentive amount\r\nincentives_depositor: public(HashMap[address, HashMap[uint256, HashMap[address, HashMap[address, uint256]]]]) # depositor => epoch => candidate => incentive token => incentive amount\r\nunclaimed: public(HashMap[uint256, HashMap[address, uint256]]) # epoch => incentive token => incentive amount\r\nuser_claimed: public(HashMap[address, HashMap[uint256, HashMap[address, bool]]]) # account => epoch => incentive token => claimed?\r\ndeposit_deadline: public(uint256)\r\nclaim_deadline: public(uint256)\r\n\r\nevent Deposit:\r\n    epoch: indexed(uint256)\r\n    candidate: indexed(address)\r\n    token: indexed(address)\r\n    amount: uint256\r\n    depositor: address\r\n\r\nevent Claim:\r\n    epoch: indexed(uint256)\r\n    token: indexed(address)\r\n    amount: uint256\r\n    account: indexed(address)\r\n\r\nevent Refund:\r\n    epoch: indexed(uint256)\r\n    candidate: indexed(address)\r\n    token: indexed(address)\r\n    amount: uint256\r\n    depositor: address\r\n\r\nevent Sweep:\r\n    epoch: indexed(uint256)\r\n    token: indexed(address)\r\n    amount: uint256\r\n    recipient: address\r\n\r\nevent SetTreasury:\r\n    treasury: indexed(address)\r\n\r\nevent SetDepositDeadline:\r\n    deadline: uint256\r\n\r\nevent SetClaimDeadline:\r\n    deadline: uint256\r\n\r\nevent PendingManagement:\r\n    management: indexed(address)\r\n\r\nevent SetManagement:\r\n    management: indexed(address)\r\n\r\nWEEK: constant(uint256) = 7 * 24 * 60 * 60\r\nEPOCH_LENGTH: constant(uint256) = 4 * WEEK\r\nFEE_SCALE: constant(uint256) = 10_000\r\n\r\n@external\r\ndef __init__(_voting: address):\r\n    \"\"\"\r\n    @notice Constructor\r\n    @param _voting The inclusion voting contract\r\n    \"\"\"\r\n    voting = Voting(_voting)\r\n    genesis = voting.genesis()\r\n    self.management = msg.sender\r\n    self.treasury = msg.sender\r\n    self.deposit_deadline = EPOCH_LENGTH\r\n    self.claim_deadline = 1\r\n\r\n@external\r\n@view\r\ndef epoch() -> uint256:\r\n    \"\"\"\r\n    @notice Get the current epoch\r\n    @return Current epoch\r\n    \"\"\"\r\n    return self._epoch()\r\n\r\n@internal\r\n@view\r\ndef _epoch() -> uint256:\r\n    \"\"\"\r\n    @notice Get the current epoch\r\n    \"\"\"\r\n    return (block.timestamp - genesis) / EPOCH_LENGTH\r\n\r\n@external\r\ndef deposit(_candidate: address, _token: address, _amount: uint256):\r\n    \"\"\"\r\n    @notice \r\n        Deposit an incentive. Only allowed in the beginning of an epoch.\r\n        Management can set a deadline after which no new incentives can be deposited.\r\n    @param _candidate\r\n        The candidate token address to place the incentive on.\r\n        The zero address represents the 'blank' option, meaning no new\r\n        asset is to be added to the pool.\r\n    @param _token The incentive token to deposit\r\n    @param _amount The amount of incentive token to deposit\r\n    \"\"\"\r\n    assert (block.timestamp - genesis) % EPOCH_LENGTH <= self.deposit_deadline\r\n    epoch: uint256 = self._epoch()\r\n    fee: uint256 = _amount * self.fee_rate / FEE_SCALE\r\n    self.incentives[epoch][_candidate][_token] += _amount - fee\r\n    self.incentives_depositor[msg.sender][epoch][_candidate][_token] += _amount\r\n    self.unclaimed[epoch][_token] += _amount\r\n\r\n    assert ERC20(_token).transferFrom(msg.sender, self, _amount, default_return_value=True)\r\n    log Deposit(epoch, _candidate, _token, _amount, msg.sender)\r\n\r\n@external\r\n@view\r\ndef claimable(_epoch: uint256, _token: address, _account: address) -> uint256:\r\n    \"\"\"\r\n    @notice Query the amount of incentive that can be claimed by a specific account\r\n    @param _epoch Epoch to query for\r\n    @param _token Incentive token to query for\r\n    @param _account Claimer to query for\r\n    \"\"\"\r\n    winner: address = voting.winners(_epoch)\r\n    if voting.latest_finalized_epoch() < _epoch or self.user_claimed[_account][_epoch][_token]:\r\n        return 0\r\n    \r\n    total_votes: uint256 = voting.total_votes(_epoch)\r\n    if total_votes == 0:\r\n        return 0\r\n    votes: uint256 = voting.votes_user(_account, _epoch)\r\n    return self.incentives[_epoch][winner][_token] * votes / total_votes\r\n\r\n@external\r\ndef claim_many(_epochs: DynArray[uint256, 16], _tokens: DynArray[address, 16], _account: address = msg.sender):\r\n    \"\"\"\r\n    @notice Claim one or multiple incentives at once\r\n    @param _epochs List of epochs to claim for\r\n    @param _tokens List of tokens to claim for, corresponding to the list of epochs\r\n    @param _account Account to claim for\r\n    \"\"\"\r\n    assert len(_epochs) == len(_tokens)\r\n    for i in range(16):\r\n        if i == len(_epochs):\r\n            break\r\n        self._claim(_epochs[i], _tokens[i], _account)\r\n\r\n@external\r\ndef claim(_epoch: uint256, _token: address, _account: address = msg.sender):\r\n    \"\"\"\r\n    @notice\r\n        Claim an incentive. Incentives are claimable if the candidate received \r\n        the most amount of votes in the epoch in question, and are split amongst\r\n        all voters, regardless whether they voted for the winner or not.\r\n    @param _epoch Epoch to claim for\r\n    @param _token Tokens to claim for\r\n    @param _account Account to claim for\r\n    \"\"\"\r\n    self._claim(_epoch, _token, _account)\r\n\r\n@internal\r\ndef _claim(_epoch: uint256, _token: address, _account: address):\r\n    \"\"\"\r\n    @notice Claim an incentive\r\n    \"\"\"\r\n    assert voting.latest_finalized_epoch() >= _epoch\r\n    winner: address = voting.winners(_epoch)\r\n    total_votes: uint256 = voting.total_votes(_epoch)\r\n    if total_votes == 0:\r\n        return\r\n    votes: uint256 = voting.votes_user(_account, _epoch)\r\n    amount: uint256 = self.incentives[_epoch][winner][_token] * votes / total_votes\r\n    if self.user_claimed[_account][_epoch][_token] or amount == 0:\r\n        return\r\n    self.user_claimed[_account][_epoch][_token] = True\r\n    self.unclaimed[_epoch][_token] -= amount\r\n\r\n    assert ERC20(_token).transfer(_account, amount, default_return_value=True)\r\n    log Claim(_epoch, _token, amount, _account)\r\n\r\n@external\r\n@view\r\ndef refundable(_epoch: uint256, _candidate: address, _token: address, _depositor: address = msg.sender) -> uint256:\r\n    \"\"\"\r\n    @notice Query whether an incentive can be refunded\r\n    @param _epoch Epoch to query for\r\n    @param _candidate Candidate token to query for\r\n    @param _token Incentive token to query for\r\n    @param _depositor Incentive depositor to query for\r\n    \"\"\"\r\n    winner: address = voting.winners(_epoch)\r\n    if voting.latest_finalized_epoch() < _epoch or (winner == _candidate and voting.total_votes(_epoch) > 0):\r\n        return 0\r\n    return self.incentives_depositor[_depositor][_epoch][_candidate][_token]\r\n\r\n@external\r\ndef refund(_epoch: uint256, _candidate: address, _token: address, _depositor: address = msg.sender):\r\n    \"\"\"\r\n    @notice\r\n        Refund an incentive. Incentives can be refunded if the candidate token has not\r\n        received the most amount of votes and therefore has lost.\r\n    @param _epoch Epoch to refund for\r\n    @param _candidate Candidate token to refund for\r\n    @param _token Incentive token to refund\r\n    @param _depositor Incentive depositor to refund for\r\n    \"\"\"\r\n    assert voting.latest_finalized_epoch() >= _epoch\r\n    assert voting.winners(_epoch) != _candidate or voting.total_votes(_epoch) == 0\r\n\r\n    amount: uint256 = self.incentives_depositor[_depositor][_epoch][_candidate][_token]\r\n    assert amount > 0\r\n    self.incentives_depositor[_depositor][_epoch][_candidate][_token] = 0\r\n    self.unclaimed[_epoch][_token] -= amount\r\n\r\n    assert ERC20(_token).transfer(_depositor, amount, default_return_value=True)\r\n    log Refund(_epoch, _candidate, _token, amount, _depositor)\r\n\r\n@external\r\n@view\r\ndef sweepable(_epoch: uint256, _token: address) -> uint256:\r\n    \"\"\"\r\n    @notice Query whether an incentive can be swept\r\n    @param _epoch Epoch to query for\r\n    @param _token Incentive token to query for\r\n    \"\"\"\r\n    if self._epoch() <= _epoch + self.claim_deadline:\r\n        return 0\r\n    return self.unclaimed[_epoch][_token]\r\n\r\n@external\r\ndef sweep(_epoch: uint256, _token: address, _recipient: address = msg.sender):\r\n    \"\"\"\r\n    @notice\r\n        Sweep unclaimed incentives. Incenties that remain unclaimed for a set\r\n        number of epochs expire and can be swept by treasury.\r\n    @param _epoch Epoch to sweep for\r\n    @param _token Incentive token to sweep\r\n    @param _recipient Recipient of the swept incentives\r\n    \"\"\"\r\n    assert msg.sender == self.treasury\r\n    assert self._epoch() > _epoch + self.claim_deadline\r\n\r\n    amount: uint256 = self.unclaimed[_epoch][_token]\r\n    assert amount > 0\r\n    self.unclaimed[_epoch][_token] = 0\r\n\r\n    assert ERC20(_token).transfer(_recipient, amount, default_return_value=True)\r\n    log Sweep(_epoch, _token, amount, _recipient)\r\n\r\n@external\r\ndef set_treasury(_treasury: address):\r\n    \"\"\"\r\n    @notice Set the new treasury address. Treasury can sweep expired unclaimed incentives\r\n    @param _treasury New treasury address\r\n    \"\"\"\r\n    assert msg.sender == self.treasury\r\n    assert _treasury != empty(address)\r\n    self.treasury = _treasury\r\n    log SetTreasury(_treasury)\r\n\r\n@external\r\ndef set_deposit_deadline(_deadline: uint256):\r\n    \"\"\"\r\n    @notice \r\n        Set the deposit deadline in seconds, after which in every epoch\r\n        incentives are no longer allowed to be posted.\r\n    @param _deadline New deposit deadline in seconds from the start of the epoch\r\n    \"\"\"\r\n    assert msg.sender == self.management\r\n    assert _deadline <= EPOCH_LENGTH\r\n    self.deposit_deadline = _deadline\r\n    log SetDepositDeadline(_deadline)\r\n\r\n@external\r\ndef set_claim_deadline(_deadline: uint256):\r\n    \"\"\"\r\n    @notice \r\n        Set the claim deadline in epochs, after which unclaimed incentives \r\n        are considered expired and can be swept by treasury.\r\n    @param _deadline New claim deadline in epochs\r\n    \"\"\"\r\n    assert msg.sender == self.management\r\n    assert _deadline >= 1\r\n    self.claim_deadline = _deadline\r\n    log SetClaimDeadline(_deadline)\r\n\r\n@external\r\ndef set_fee_rate(_fee_rate: uint256):\r\n    \"\"\"\r\n    @notice Set the incentive fee rate\r\n    @param _fee_rate New fee rate (bps)\r\n    \"\"\"\r\n    assert msg.sender == self.management\r\n    assert _fee_rate <= FEE_SCALE / 10\r\n    self.fee_rate = _fee_rate\r\n\r\n@external\r\ndef set_management(_management: address):\r\n    \"\"\"\r\n    @notice \r\n        Set the pending management address.\r\n        Needs to be accepted by that account separately to transfer management over\r\n    @param _management New pending management address\r\n    \"\"\"\r\n    assert msg.sender == self.management\r\n    self.pending_management = _management\r\n    log PendingManagement(_management)\r\n\r\n@external\r\ndef accept_management():\r\n    \"\"\"\r\n    @notice \r\n        Accept management role.\r\n        Can only be called by account previously marked as pending management by current management\r\n    \"\"\"\r\n    assert msg.sender == self.pending_management\r\n    self.pending_management = empty(address)\r\n    self.management = msg.sender\r\n    log SetManagement(msg.sender)","ABI":"[{\"name\":\"Deposit\",\"inputs\":[{\"name\":\"epoch\",\"type\":\"uint256\",\"indexed\":true},{\"name\":\"candidate\",\"type\":\"address\",\"indexed\":true},{\"name\":\"token\",\"type\":\"address\",\"indexed\":true},{\"name\":\"amount\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"depositor\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Claim\",\"inputs\":[{\"name\":\"epoch\",\"type\":\"uint256\",\"indexed\":true},{\"name\":\"token\",\"type\":\"address\",\"indexed\":true},{\"name\":\"amount\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"account\",\"type\":\"address\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Refund\",\"inputs\":[{\"name\":\"epoch\",\"type\":\"uint256\",\"indexed\":true},{\"name\":\"candidate\",\"type\":\"address\",\"indexed\":true},{\"name\":\"token\",\"type\":\"address\",\"indexed\":true},{\"name\":\"amount\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"depositor\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Sweep\",\"inputs\":[{\"name\":\"epoch\",\"type\":\"uint256\",\"indexed\":true},{\"name\":\"token\",\"type\":\"address\",\"indexed\":true},{\"name\":\"amount\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"recipient\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetTreasury\",\"inputs\":[{\"name\":\"treasury\",\"type\":\"address\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetDepositDeadline\",\"inputs\":[{\"name\":\"deadline\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetClaimDeadline\",\"inputs\":[{\"name\":\"deadline\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"PendingManagement\",\"inputs\":[{\"name\":\"management\",\"type\":\"address\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetManagement\",\"inputs\":[{\"name\":\"management\",\"type\":\"address\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"_voting\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"epoch\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"deposit\",\"inputs\":[{\"name\":\"_candidate\",\"type\":\"address\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"claimable\",\"inputs\":[{\"name\":\"_epoch\",\"type\":\"uint256\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_account\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"claim_many\",\"inputs\":[{\"name\":\"_epochs\",\"type\":\"uint256[]\"},{\"name\":\"_tokens\",\"type\":\"address[]\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"claim_many\",\"inputs\":[{\"name\":\"_epochs\",\"type\":\"uint256[]\"},{\"name\":\"_tokens\",\"type\":\"address[]\"},{\"name\":\"_account\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"claim\",\"inputs\":[{\"name\":\"_epoch\",\"type\":\"uint256\"},{\"name\":\"_token\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"claim\",\"inputs\":[{\"name\":\"_epoch\",\"type\":\"uint256\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_account\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"refundable\",\"inputs\":[{\"name\":\"_epoch\",\"type\":\"uint256\"},{\"name\":\"_candidate\",\"type\":\"address\"},{\"name\":\"_token\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"refundable\",\"inputs\":[{\"name\":\"_epoch\",\"type\":\"uint256\"},{\"name\":\"_candidate\",\"type\":\"address\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_depositor\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"refund\",\"inputs\":[{\"name\":\"_epoch\",\"type\":\"uint256\"},{\"name\":\"_candidate\",\"type\":\"address\"},{\"name\":\"_token\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"refund\",\"inputs\":[{\"name\":\"_epoch\",\"type\":\"uint256\"},{\"name\":\"_candidate\",\"type\":\"address\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_depositor\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"sweepable\",\"inputs\":[{\"name\":\"_epoch\",\"type\":\"uint256\"},{\"name\":\"_token\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"sweep\",\"inputs\":[{\"name\":\"_epoch\",\"type\":\"uint256\"},{\"name\":\"_token\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"sweep\",\"inputs\":[{\"name\":\"_epoch\",\"type\":\"uint256\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_recipient\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_treasury\",\"inputs\":[{\"name\":\"_treasury\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_deposit_deadline\",\"inputs\":[{\"name\":\"_deadline\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_claim_deadline\",\"inputs\":[{\"name\":\"_deadline\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_fee_rate\",\"inputs\":[{\"name\":\"_fee_rate\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_management\",\"inputs\":[{\"name\":\"_management\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"accept_management\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"genesis\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"voting\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"management\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"pending_management\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"treasury\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"fee_rate\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"incentives\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"},{\"name\":\"arg1\",\"type\":\"address\"},{\"name\":\"arg2\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"incentives_depositor\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"},{\"name\":\"arg1\",\"type\":\"uint256\"},{\"name\":\"arg2\",\"type\":\"address\"},{\"name\":\"arg3\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"unclaimed\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"},{\"name\":\"arg1\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"user_claimed\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"},{\"name\":\"arg1\",\"type\":\"uint256\"},{\"name\":\"arg2\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"deposit_deadline\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"claim_deadline\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]}]","ContractName":"Incentives for inclusion vote","CompilerVersion":"vyper:0.3.10","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"0000000000000000000000006bc0878939669339e82dbfa13d260c89230f2c31","EVMVersion":"Default","Library":"","LicenseType":"GNU AGPLv3","Proxy":"0","Implementation":"","SwarmSource":""}]}