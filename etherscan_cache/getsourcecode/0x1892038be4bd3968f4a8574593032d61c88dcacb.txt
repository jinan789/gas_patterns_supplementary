{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/strategies/IdleStrategy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.17;\\n\\nimport \\\"@openzeppelin/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/utils/math/SafeCast.sol\\\";\\nimport \\\"../external/interfaces/strategies/idle/IIdleToken.sol\\\";\\nimport \\\"../libraries/PackedRange.sol\\\";\\nimport \\\"./Strategy.sol\\\";\\n\\nerror IdleBeforeDepositCheckFailed();\\nerror IdleBeforeRedeemalCheckFailed();\\nerror IdleDepositSlippagesFailed();\\nerror IdleRedeemSlippagesFailed();\\nerror IdleCompoundSlippagesFailed();\\n\\n// one asset\\n// multiple rewards\\n// slippages\\n// - mode selection: slippages[0]\\n// - DHW with deposit: slippages[0] == 0\\n//   - beforeDepositCheck: slippages[1]\\n//   - beforeRedeemalCheck: slippages[2]\\n//   - compound: slippages[3]\\n//   - _depositToProtocol: slippages[4]\\n// - DHW with withdrawal: slippages[0] == 1\\n//   - beforeDepositCheck: slippages[1]\\n//   - beforeRedeemalCheck: slippages[2]\\n//   - compound: slippages[3]\\n//   - _redeemFromProtocol: slippages[4]\\n// - reallocate: slippages[0] == 2\\n//   - beforeDepositCheck: depositSlippages[1]\\n//   - _depositToProtocol: depositSlippages[2]\\n//   - beforeRedeemalCheck: withdrawalSlippages[1]\\n//   - _redeemFromProtocol: withdrawalSlippages[2]\\n// - redeemFast or emergencyWithdraw: slippages[0] == 3\\n//   - _redeemFromProtocol or _emergencyWithdrawImpl: slippages[1]\\ncontract IdleStrategy is Strategy {\\n    using SafeERC20 for IERC20;\\n\\n    ISwapper public immutable swapper;\\n\\n    IIdleToken public idleToken;\\n    uint96 public oneShare;\\n\\n    uint256 private _lastIdleTokenPrice;\\n\\n    constructor(IAssetGroupRegistry assetGroupRegistry_, ISpoolAccessControl accessControl_, ISwapper swapper_)\\n        Strategy(assetGroupRegistry_, accessControl_, NULL_ASSET_GROUP_ID)\\n    {\\n        swapper = swapper_;\\n    }\\n\\n    function initialize(string memory strategyName_, uint256 assetGroupId_, IIdleToken idleToken_)\\n        external\\n        initializer\\n    {\\n        __Strategy_init(strategyName_, assetGroupId_);\\n\\n        if (address(idleToken_) == address(0)) {\\n            revert ConfigurationAddressZero();\\n        }\\n\\n        idleToken = idleToken_;\\n        oneShare = SafeCast.toUint96(10 ** idleToken_.decimals());\\n\\n        address[] memory tokens = _assetGroupRegistry.listAssetGroup(assetGroupId_);\\n\\n        if (tokens.length != 1 || tokens[0] != idleToken.token()) {\\n            revert InvalidAssetGroup(assetGroupId_);\\n        }\\n\\n        _lastIdleTokenPrice = idleToken.tokenPriceWithFee(address(this));\\n    }\\n\\n    function assetRatio() external pure override returns (uint256[] memory) {\\n        uint256[] memory _assetRatio = new uint256[](1);\\n        _assetRatio[0] = 1;\\n        return _assetRatio;\\n    }\\n\\n    function getUnderlyingAssetAmounts() external view returns (uint256[] memory amounts) {\\n        amounts = new uint256[](1);\\n        amounts[0] = idleToken.tokenPriceWithFee(address(this)) * idleToken.balanceOf(address(this)) / oneShare;\\n    }\\n\\n    function beforeDepositCheck(uint256[] memory amounts, uint256[] calldata slippages) public override {\\n        if (_isViewExecution()) {\\n            uint256[] memory beforeDepositCheckSlippageAmounts = new uint256[](1);\\n            beforeDepositCheckSlippageAmounts[0] = amounts[0];\\n\\n            emit BeforeDepositCheckSlippages(beforeDepositCheckSlippageAmounts);\\n            return;\\n        }\\n\\n        if (slippages[0] > 2) {\\n            revert IdleBeforeDepositCheckFailed();\\n        }\\n\\n        if (!PackedRange.isWithinRange(slippages[1], amounts[0])) {\\n            revert IdleBeforeDepositCheckFailed();\\n        }\\n    }\\n\\n    function beforeRedeemalCheck(uint256 ssts, uint256[] calldata slippages) public override {\\n        if (_isViewExecution()) {\\n            emit BeforeRedeemalCheckSlippages(ssts);\\n            return;\\n        }\\n\\n        uint256 slippage;\\n        if (slippages[0] < 2) {\\n            slippage = slippages[2];\\n        } else if (slippages[0] == 2) {\\n            slippage = slippages[1];\\n        } else {\\n            revert IdleBeforeRedeemalCheckFailed();\\n        }\\n\\n        if (!PackedRange.isWithinRange(slippage, ssts)) {\\n            revert IdleBeforeRedeemalCheckFailed();\\n        }\\n    }\\n\\n    function _depositToProtocol(address[] calldata tokens, uint256[] memory amounts, uint256[] calldata slippages)\\n        internal\\n        override\\n    {\\n        uint256 slippage;\\n        if (slippages[0] == 0) {\\n            slippage = slippages[4];\\n        } else if (slippages[0] == 2) {\\n            slippage = slippages[2];\\n        } else {\\n            revert IdleDepositSlippagesFailed();\\n        }\\n\\n        _depositToIdle(tokens[0], amounts[0], slippage);\\n    }\\n\\n    function _redeemFromProtocol(address[] calldata, uint256 ssts, uint256[] calldata slippages) internal override {\\n        uint256 slippage;\\n        if (slippages[0] == 1) {\\n            slippage = slippages[4];\\n        } else if (slippages[0] == 2) {\\n            slippage = slippages[2];\\n        } else if (slippages[0] == 3) {\\n            slippage = slippages[1];\\n        } else if (_isViewExecution()) {} else {\\n            revert IdleRedeemSlippagesFailed();\\n        }\\n\\n        uint256 idleTokensToRedeem = idleToken.balanceOf(address(this)) * ssts / totalSupply();\\n        _redeemFromIdle(idleTokensToRedeem, slippage);\\n    }\\n\\n    function _emergencyWithdrawImpl(uint256[] calldata slippages, address recipient) internal override {\\n        if (slippages[0] != 3) {\\n            revert IdleRedeemSlippagesFailed();\\n        }\\n\\n        uint256 assetsWithdrawn = _redeemFromIdle(idleToken.balanceOf((address(this))), slippages[1]);\\n\\n        address[] memory tokens = _assetGroupRegistry.listAssetGroup(assetGroupId());\\n        IERC20(tokens[0]).safeTransfer(recipient, assetsWithdrawn);\\n    }\\n\\n    function _compound(address[] calldata tokens, SwapInfo[] calldata compoundSwapInfo, uint256[] calldata slippages)\\n        internal\\n        override\\n        returns (int256 compoundYield)\\n    {\\n        if (compoundSwapInfo.length == 0) {\\n            return compoundYield;\\n        }\\n\\n        if (slippages[0] > 1) {\\n            revert IdleCompoundSlippagesFailed();\\n        }\\n\\n        (address[] memory govTokens,) = _getProtocolRewardsInternal();\\n\\n        uint256 swappedAmount = swapper.swap(govTokens, compoundSwapInfo, tokens, address(this))[0];\\n\\n        uint256 idleTokensBefore = idleToken.balanceOf(address(this));\\n\\n        uint256 idleTokensMinted = _depositToIdle(tokens[0], swappedAmount, slippages[3]);\\n\\n        compoundYield = int256(YIELD_FULL_PERCENT * idleTokensMinted / idleTokensBefore);\\n    }\\n\\n    function _getYieldPercentage(int256) internal override returns (int256 baseYieldPercentage) {\\n        uint256 currentIdleTokenPrice = idleToken.tokenPriceWithFee(address(this));\\n\\n        baseYieldPercentage = _calculateYieldPercentage(_lastIdleTokenPrice, currentIdleTokenPrice);\\n\\n        _lastIdleTokenPrice = currentIdleTokenPrice;\\n    }\\n\\n    function _swapAssets(address[] memory, uint256[] memory, SwapInfo[] calldata) internal override {}\\n\\n    function _getUsdWorth(uint256[] memory exchangeRates, IUsdPriceFeedManager priceFeedManager)\\n        internal\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        uint256 assetWorth = idleToken.tokenPriceWithFee(address(this)) * idleToken.balanceOf(address(this)) / oneShare;\\n        address[] memory tokens = _assetGroupRegistry.listAssetGroup(assetGroupId());\\n\\n        return priceFeedManager.assetToUsdCustomPrice(tokens[0], assetWorth, exchangeRates[0]);\\n    }\\n\\n    function _depositToIdle(address token, uint256 amount, uint256 slippage) private returns (uint256) {\\n        _resetAndApprove(IERC20(token), address(idleToken), amount);\\n\\n        uint256 mintedIdleTokens = idleToken.mintIdleToken(\\n            amount,\\n            true, // not used by the protocol, can be anything\\n            address(this)\\n        );\\n\\n        if (mintedIdleTokens < slippage) {\\n            revert IdleDepositSlippagesFailed();\\n        }\\n\\n        if (_isViewExecution()) {\\n            emit Slippages(true, mintedIdleTokens, \\\"\\\");\\n        }\\n\\n        return mintedIdleTokens;\\n    }\\n\\n    function _redeemFromIdle(uint256 idleTokens, uint256 slippage) private returns (uint256) {\\n        uint256 redeemedAssets = idleToken.redeemIdleToken(idleTokens);\\n\\n        if (redeemedAssets < slippage) {\\n            revert IdleRedeemSlippagesFailed();\\n        }\\n\\n        if (_isViewExecution()) {\\n            emit Slippages(false, redeemedAssets, \\\"\\\");\\n        }\\n\\n        return redeemedAssets;\\n    }\\n\\n    function _getProtocolRewardsInternal() internal virtual override returns (address[] memory, uint256[] memory) {\\n        address[] memory govTokens = idleToken.getGovTokens();\\n        uint256[] memory balances = new uint256[](govTokens.length);\\n\\n        idleToken.redeemIdleToken(0);\\n\\n        for (uint256 i; i < govTokens.length; ++i) {\\n            uint256 balance = IERC20(govTokens[i]).balanceOf(address(this));\\n\\n            if (balance > 0) {\\n                IERC20(govTokens[i]).safeTransfer(address(swapper), balance);\\n            }\\n\\n            balances[i] = balance;\\n        }\\n\\n        return (govTokens, balances);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\r\\n */\\r\\ninterface IERC20 {\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address to, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender's allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller's\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"../IERC20.sol\\\";\\r\\nimport \\\"../extensions/IERC20Permit.sol\\\";\\r\\nimport \\\"../../../utils/Address.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title SafeERC20\\r\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\r\\n * contract returns false). Tokens that return no value (and instead revert or\\r\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\r\\n * successful.\\r\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\r\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\r\\n */\\r\\nlibrary SafeERC20 {\\r\\n    using Address for address;\\r\\n\\r\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\r\\n    }\\r\\n\\r\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Deprecated. This function has issues similar to the ones found in\\r\\n     * {IERC20-approve}, and its usage is discouraged.\\r\\n     *\\r\\n     * Whenever possible, use {safeIncreaseAllowance} and\\r\\n     * {safeDecreaseAllowance} instead.\\r\\n     */\\r\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\r\\n        // safeApprove should only be called when setting an initial allowance,\\r\\n        // or when resetting it to zero. To increase and decrease it, use\\r\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\r\\n        require(\\r\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\r\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\r\\n        );\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\r\\n    }\\r\\n\\r\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\r\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\r\\n    }\\r\\n\\r\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\r\\n        unchecked {\\r\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\r\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\r\\n            uint256 newAllowance = oldAllowance - value;\\r\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function safePermit(\\r\\n        IERC20Permit token,\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 value,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) internal {\\r\\n        uint256 nonceBefore = token.nonces(owner);\\r\\n        token.permit(owner, spender, value, deadline, v, r, s);\\r\\n        uint256 nonceAfter = token.nonces(owner);\\r\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\r\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\r\\n     * @param token The token targeted by the call.\\r\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\r\\n     */\\r\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\r\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\r\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\r\\n        // the target address contains contract code and also asserts for success in the low-level call.\\r\\n\\r\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\r\\n        if (returndata.length > 0) {\\r\\n            // Return data is optional\\r\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/math/SafeCast.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\\r\\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\r\\n * checks.\\r\\n *\\r\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\r\\n * easily result in undesired exploitation or bugs, since developers usually\\r\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\r\\n * reverting the transaction when such an operation overflows.\\r\\n *\\r\\n * Using this library instead of the unchecked operations eliminates an entire\\r\\n * class of bugs, so it's recommended to use it always.\\r\\n *\\r\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\r\\n * all math on `uint256` and `int256` and then downcasting.\\r\\n */\\r\\nlibrary SafeCast {\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint248 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint248).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint248` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 248 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint248(uint256 value) internal pure returns (uint248) {\\r\\n        require(value <= type(uint248).max, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\r\\n        return uint248(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint240 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint240).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint240` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 240 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint240(uint256 value) internal pure returns (uint240) {\\r\\n        require(value <= type(uint240).max, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\r\\n        return uint240(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint232 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint232).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint232` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 232 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint232(uint256 value) internal pure returns (uint232) {\\r\\n        require(value <= type(uint232).max, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\r\\n        return uint232(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint224).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint224` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 224 bits\\r\\n     *\\r\\n     * _Available since v4.2._\\r\\n     */\\r\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\r\\n        require(value <= type(uint224).max, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\r\\n        return uint224(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint216 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint216).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint216` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 216 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint216(uint256 value) internal pure returns (uint216) {\\r\\n        require(value <= type(uint216).max, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\r\\n        return uint216(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint208 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint208).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint208` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 208 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint208(uint256 value) internal pure returns (uint208) {\\r\\n        require(value <= type(uint208).max, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\r\\n        return uint208(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint200 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint200).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint200` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 200 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint200(uint256 value) internal pure returns (uint200) {\\r\\n        require(value <= type(uint200).max, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\r\\n        return uint200(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint192 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint192).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint192` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 192 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint192(uint256 value) internal pure returns (uint192) {\\r\\n        require(value <= type(uint192).max, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\r\\n        return uint192(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint184 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint184).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint184` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 184 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint184(uint256 value) internal pure returns (uint184) {\\r\\n        require(value <= type(uint184).max, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\r\\n        return uint184(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint176 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint176).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint176` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 176 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint176(uint256 value) internal pure returns (uint176) {\\r\\n        require(value <= type(uint176).max, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\r\\n        return uint176(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint168 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint168).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint168` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 168 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint168(uint256 value) internal pure returns (uint168) {\\r\\n        require(value <= type(uint168).max, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\r\\n        return uint168(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint160 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint160).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint160` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 160 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint160(uint256 value) internal pure returns (uint160) {\\r\\n        require(value <= type(uint160).max, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\r\\n        return uint160(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint152 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint152).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint152` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 152 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint152(uint256 value) internal pure returns (uint152) {\\r\\n        require(value <= type(uint152).max, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\r\\n        return uint152(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint144 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint144).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint144` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 144 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint144(uint256 value) internal pure returns (uint144) {\\r\\n        require(value <= type(uint144).max, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\r\\n        return uint144(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint136 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint136).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint136` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 136 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint136(uint256 value) internal pure returns (uint136) {\\r\\n        require(value <= type(uint136).max, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\r\\n        return uint136(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint128).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint128` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 128 bits\\r\\n     *\\r\\n     * _Available since v2.5._\\r\\n     */\\r\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\r\\n        require(value <= type(uint128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\r\\n        return uint128(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint120 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint120).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint120` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 120 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint120(uint256 value) internal pure returns (uint120) {\\r\\n        require(value <= type(uint120).max, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\r\\n        return uint120(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint112 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint112).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint112` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 112 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint112(uint256 value) internal pure returns (uint112) {\\r\\n        require(value <= type(uint112).max, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\r\\n        return uint112(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint104 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint104).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint104` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 104 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint104(uint256 value) internal pure returns (uint104) {\\r\\n        require(value <= type(uint104).max, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\r\\n        return uint104(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint96).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint96` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 96 bits\\r\\n     *\\r\\n     * _Available since v4.2._\\r\\n     */\\r\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\r\\n        require(value <= type(uint96).max, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\r\\n        return uint96(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint88 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint88).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint88` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 88 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint88(uint256 value) internal pure returns (uint88) {\\r\\n        require(value <= type(uint88).max, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\r\\n        return uint88(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint80 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint80).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint80` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 80 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint80(uint256 value) internal pure returns (uint80) {\\r\\n        require(value <= type(uint80).max, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\r\\n        return uint80(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint72 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint72).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint72` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 72 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint72(uint256 value) internal pure returns (uint72) {\\r\\n        require(value <= type(uint72).max, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\r\\n        return uint72(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint64).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint64` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 64 bits\\r\\n     *\\r\\n     * _Available since v2.5._\\r\\n     */\\r\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\r\\n        require(value <= type(uint64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\r\\n        return uint64(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint56 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint56).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint56` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 56 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint56(uint256 value) internal pure returns (uint56) {\\r\\n        require(value <= type(uint56).max, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\r\\n        return uint56(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint48 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint48).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint48` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 48 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint48(uint256 value) internal pure returns (uint48) {\\r\\n        require(value <= type(uint48).max, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\r\\n        return uint48(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint40 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint40).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint40` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 40 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint40(uint256 value) internal pure returns (uint40) {\\r\\n        require(value <= type(uint40).max, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\r\\n        return uint40(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint32).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint32` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 32 bits\\r\\n     *\\r\\n     * _Available since v2.5._\\r\\n     */\\r\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\r\\n        require(value <= type(uint32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\r\\n        return uint32(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint24 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint24).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint24` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 24 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toUint24(uint256 value) internal pure returns (uint24) {\\r\\n        require(value <= type(uint24).max, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\r\\n        return uint24(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint16).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint16` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 16 bits\\r\\n     *\\r\\n     * _Available since v2.5._\\r\\n     */\\r\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\r\\n        require(value <= type(uint16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\r\\n        return uint16(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint8).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint8` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 8 bits\\r\\n     *\\r\\n     * _Available since v2.5._\\r\\n     */\\r\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\r\\n        require(value <= type(uint8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\r\\n        return uint8(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Converts a signed int256 into an unsigned uint256.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must be greater than or equal to 0.\\r\\n     *\\r\\n     * _Available since v3.0._\\r\\n     */\\r\\n    function toUint256(int256 value) internal pure returns (uint256) {\\r\\n        require(value >= 0, \\\"SafeCast: value must be positive\\\");\\r\\n        return uint256(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int248 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int248 or\\r\\n     * greater than largest int248).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int248` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 248 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\\r\\n        downcasted = int248(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int240 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int240 or\\r\\n     * greater than largest int240).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int240` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 240 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\\r\\n        downcasted = int240(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int232 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int232 or\\r\\n     * greater than largest int232).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int232` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 232 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\\r\\n        downcasted = int232(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int224 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int224 or\\r\\n     * greater than largest int224).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int224` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 224 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\\r\\n        downcasted = int224(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int216 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int216 or\\r\\n     * greater than largest int216).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int216` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 216 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\\r\\n        downcasted = int216(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int208 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int208 or\\r\\n     * greater than largest int208).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int208` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 208 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\\r\\n        downcasted = int208(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int200 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int200 or\\r\\n     * greater than largest int200).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int200` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 200 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\\r\\n        downcasted = int200(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int192 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int192 or\\r\\n     * greater than largest int192).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int192` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 192 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\\r\\n        downcasted = int192(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int184 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int184 or\\r\\n     * greater than largest int184).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int184` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 184 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\\r\\n        downcasted = int184(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int176 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int176 or\\r\\n     * greater than largest int176).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int176` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 176 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\\r\\n        downcasted = int176(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int168 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int168 or\\r\\n     * greater than largest int168).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int168` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 168 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\\r\\n        downcasted = int168(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int160 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int160 or\\r\\n     * greater than largest int160).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int160` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 160 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\\r\\n        downcasted = int160(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int152 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int152 or\\r\\n     * greater than largest int152).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int152` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 152 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\\r\\n        downcasted = int152(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int144 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int144 or\\r\\n     * greater than largest int144).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int144` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 144 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\\r\\n        downcasted = int144(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int136 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int136 or\\r\\n     * greater than largest int136).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int136` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 136 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\\r\\n        downcasted = int136(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int128 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int128 or\\r\\n     * greater than largest int128).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int128` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 128 bits\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\\r\\n        downcasted = int128(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int120 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int120 or\\r\\n     * greater than largest int120).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int120` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 120 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\\r\\n        downcasted = int120(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int112 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int112 or\\r\\n     * greater than largest int112).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int112` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 112 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\\r\\n        downcasted = int112(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int104 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int104 or\\r\\n     * greater than largest int104).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int104` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 104 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\\r\\n        downcasted = int104(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int96 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int96 or\\r\\n     * greater than largest int96).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int96` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 96 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\\r\\n        downcasted = int96(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int88 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int88 or\\r\\n     * greater than largest int88).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int88` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 88 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\\r\\n        downcasted = int88(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int80 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int80 or\\r\\n     * greater than largest int80).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int80` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 80 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\\r\\n        downcasted = int80(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int72 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int72 or\\r\\n     * greater than largest int72).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int72` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 72 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\\r\\n        downcasted = int72(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int64 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int64 or\\r\\n     * greater than largest int64).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int64` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 64 bits\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\\r\\n        downcasted = int64(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int56 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int56 or\\r\\n     * greater than largest int56).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int56` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 56 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\\r\\n        downcasted = int56(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int48 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int48 or\\r\\n     * greater than largest int48).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int48` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 48 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\\r\\n        downcasted = int48(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int40 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int40 or\\r\\n     * greater than largest int40).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int40` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 40 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\\r\\n        downcasted = int40(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int32 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int32 or\\r\\n     * greater than largest int32).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int32` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 32 bits\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\\r\\n        downcasted = int32(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int24 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int24 or\\r\\n     * greater than largest int24).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int24` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 24 bits\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\\r\\n        downcasted = int24(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int16 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int16 or\\r\\n     * greater than largest int16).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int16` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 16 bits\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\\r\\n        downcasted = int16(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int8 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int8 or\\r\\n     * greater than largest int8).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int8` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 8 bits\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\\r\\n        downcasted = int8(value);\\r\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Converts an unsigned uint256 into a signed int256.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must be less than or equal to maxInt256.\\r\\n     *\\r\\n     * _Available since v3.0._\\r\\n     */\\r\\n    function toInt256(uint256 value) internal pure returns (int256) {\\r\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\r\\n        require(value <= uint256(type(int256).max), \\\"SafeCast: value doesn't fit in an int256\\\");\\r\\n        return int256(value);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"src/external/interfaces/strategies/idle/IIdleToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\ninterface IIdleToken {\\n    function balanceOf(address _user) external view returns (uint256);\\n\\n    function decimals() external view returns (uint8);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function token() external view returns (address);\\n\\n    // NOTE: some idle tokens don't have this: https://docs.idle.finance/developers/best-yield/methods/tokenprice\\n    function tokenPriceWithFee(address _user) external view returns (uint256);\\n\\n    function tokenPrice() external view returns (uint256);\\n\\n    function getGovTokens() external view returns (address[] memory);\\n\\n    function getGovTokensAmounts(address _user) external view returns (uint256[] memory);\\n\\n    function mintIdleToken(uint256 _amount, bool _skipWholeRebalance, address _referral)\\n        external\\n        returns (uint256 mintedTokens);\\n\\n    function redeemIdleToken(uint256 _amount) external returns (uint256 redeemedTokens);\\n}\\n\"\r\n    },\r\n    \"src/libraries/PackedRange.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nlibrary PackedRange {\\n    uint256 constant BITS = 128;\\n    uint256 constant MAX = (1 << BITS) - 1;\\n\\n    function isWithinRange(uint256 range, uint256 value) internal pure returns (bool) {\\n        return !((value < (range & MAX)) || (value > (range >> BITS)));\\n    }\\n}\\n\"\r\n    },\r\n    \"src/strategies/Strategy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.17;\\n\\nimport \\\"@openzeppelin/token/ERC20/extensions/IERC20Metadata.sol\\\";\\nimport \\\"@openzeppelin/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/utils/math/Math.sol\\\";\\nimport \\\"@openzeppelin-upgradeable/token/ERC20/ERC20Upgradeable.sol\\\";\\nimport \\\"../interfaces/Constants.sol\\\";\\nimport \\\"../interfaces/IAssetGroupRegistry.sol\\\";\\nimport \\\"../interfaces/IMasterWallet.sol\\\";\\nimport \\\"../interfaces/IStrategy.sol\\\";\\nimport \\\"../interfaces/IStrategyRegistry.sol\\\";\\nimport \\\"../interfaces/CommonErrors.sol\\\";\\nimport \\\"../interfaces/Constants.sol\\\";\\nimport \\\"../access/SpoolAccessControllable.sol\\\";\\n\\n/**\\n * @notice Used when initial locked strategy shares are already minted and strategy usd value is zero.\\n */\\nerror StrategyWorthIsZero();\\n\\nabstract contract Strategy is ERC20Upgradeable, SpoolAccessControllable, IStrategy {\\n    using SafeERC20 for IERC20;\\n\\n    /* ========== STATE VARIABLES ========== */\\n\\n    IAssetGroupRegistry internal immutable _assetGroupRegistry;\\n\\n    /// @notice Name of the strategy\\n    string private _strategyName;\\n\\n    /// @dev ID of the asset group used by the strategy.\\n    uint256 private immutable _assetGroupId;\\n    /// @dev ID of the asset group used by the strategy.\\n    uint256 private _assetGroupIdStorage;\\n    // Only one of the above can be set. Use the `assetGroupId` function to read\\n    // the correct one.\\n\\n    constructor(IAssetGroupRegistry assetGroupRegistry_, ISpoolAccessControl accessControl_, uint256 assetGroupId_)\\n        SpoolAccessControllable(accessControl_)\\n    {\\n        if (address(assetGroupRegistry_) == address(0)) {\\n            revert ConfigurationAddressZero();\\n        }\\n\\n        _assetGroupRegistry = assetGroupRegistry_;\\n        _assetGroupId = assetGroupId_;\\n    }\\n\\n    function __Strategy_init(string memory strategyName_, uint256 assetGroupId_) internal onlyInitializing {\\n        if (bytes(strategyName_).length == 0) revert InvalidConfiguration();\\n\\n        // asset group ID needs to be set exactly once,\\n        // either in constructor or initializer\\n        if (_assetGroupId == NULL_ASSET_GROUP_ID) {\\n            if (assetGroupId_ == NULL_ASSET_GROUP_ID) {\\n                revert InvalidAssetGroupIdInitialization();\\n            }\\n            _assetGroupIdStorage = assetGroupId_;\\n        } else {\\n            if (assetGroupId_ != NULL_ASSET_GROUP_ID) {\\n                revert InvalidAssetGroupIdInitialization();\\n            }\\n        }\\n        _assetGroupRegistry.validateAssetGroup(assetGroupId());\\n\\n        _strategyName = strategyName_;\\n\\n        __ERC20_init(\\\"Strategy Share Token\\\", \\\"SST\\\");\\n    }\\n\\n    /* ========== EXTERNAL VIEW FUNCTIONS ========== */\\n\\n    function assetGroupId() public view returns (uint256) {\\n        return _assetGroupId > 0 ? _assetGroupId : _assetGroupIdStorage;\\n    }\\n\\n    function assets() public view returns (address[] memory) {\\n        return _assetGroupRegistry.listAssetGroup(assetGroupId());\\n    }\\n\\n    function assetRatio() external view virtual returns (uint256[] memory);\\n\\n    function strategyName() external view returns (string memory) {\\n        return _strategyName;\\n    }\\n\\n    function beforeDepositCheck(uint256[] memory amounts, uint256[] calldata slippages) public virtual;\\n\\n    function beforeRedeemalCheck(uint256 ssts, uint256[] calldata slippages) public virtual;\\n\\n    /* ========== EXTERNAL MUTATIVE FUNCTIONS ========== */\\n\\n    function doHardWork(StrategyDhwParameterBag calldata dhwParams) external returns (DhwInfo memory dhwInfo) {\\n        _checkRole(ROLE_STRATEGY_REGISTRY, msg.sender);\\n\\n        bool depositNeeded;\\n        uint256[] memory assetsToDeposit = new uint256[](dhwParams.assetGroup.length);\\n        unchecked {\\n            for (uint256 i; i < dhwParams.assetGroup.length; ++i) {\\n                assetsToDeposit[i] = IERC20(dhwParams.assetGroup[i]).balanceOf(address(this));\\n\\n                if (assetsToDeposit[i] > 0) {\\n                    depositNeeded = true;\\n                }\\n            }\\n        }\\n\\n        beforeDepositCheck(assetsToDeposit, dhwParams.slippages);\\n        beforeRedeemalCheck(dhwParams.withdrawnShares, dhwParams.slippages);\\n\\n        // usdWorth[0]: usd worth before deposit / withdrawal\\n        // usdWorth[1]: usd worth after deposit / withdrawal\\n        uint256[2] memory usdWorth;\\n\\n        // Compound and get USD value.\\n        {\\n            dhwInfo.yieldPercentage = _getYieldPercentage(dhwParams.baseYield);\\n            int256 compoundYield = _compound(dhwParams.assetGroup, dhwParams.compoundSwapInfo, dhwParams.slippages);\\n            dhwInfo.yieldPercentage += compoundYield + compoundYield * dhwInfo.yieldPercentage / YIELD_FULL_PERCENT_INT;\\n        }\\n\\n        // collect fees, mint SVTs relative to the yield generated\\n        _collectPlatformFees(dhwInfo.yieldPercentage, dhwParams.platformFees);\\n\\n        usdWorth[0] = _getUsdWorth(dhwParams.exchangeRates, dhwParams.priceFeedManager);\\n\\n        uint256 matchedShares;\\n        uint256 depositShareEquivalent;\\n        uint256 mintedShares;\\n        uint256 withdrawnShares = dhwParams.withdrawnShares;\\n\\n        // Calculate deposit share equivalent.\\n        if (depositNeeded) {\\n            uint256 valueToDeposit = dhwParams.priceFeedManager.assetToUsdCustomPriceBulk(\\n                dhwParams.assetGroup, assetsToDeposit, dhwParams.exchangeRates\\n            );\\n\\n            if (totalSupply() < INITIAL_LOCKED_SHARES) {\\n                depositShareEquivalent = INITIAL_SHARE_MULTIPLIER * valueToDeposit;\\n            } else if (usdWorth[0] > 0) {\\n                depositShareEquivalent = totalSupply() * valueToDeposit / usdWorth[0];\\n            } else {\\n                revert StrategyWorthIsZero();\\n            }\\n\\n            // Match withdrawals and deposits by taking smaller value as matched shares.\\n            if (depositShareEquivalent < withdrawnShares) {\\n                matchedShares = depositShareEquivalent;\\n            } else {\\n                matchedShares = withdrawnShares;\\n            }\\n        }\\n\\n        uint256[] memory withdrawnAssets = new uint256[](dhwParams.assetGroup.length);\\n        bool withdrawn;\\n        if (depositShareEquivalent > withdrawnShares) {\\n            // Deposit is needed.\\n\\n            // - match if needed\\n            if (matchedShares > 0) {\\n                unchecked {\\n                    for (uint256 i; i < dhwParams.assetGroup.length; ++i) {\\n                        withdrawnAssets[i] = assetsToDeposit[i] * matchedShares / depositShareEquivalent;\\n                        assetsToDeposit[i] -= withdrawnAssets[i];\\n                    }\\n                }\\n                withdrawn = true;\\n            }\\n\\n            // - swap assets\\n            uint256[] memory assetsIn = new uint256[](assetsToDeposit.length);\\n            if (dhwParams.swapInfo.length > 0) {\\n                _swapAssets(dhwParams.assetGroup, assetsToDeposit, dhwParams.swapInfo);\\n                for (uint256 i; i < dhwParams.assetGroup.length; ++i) {\\n                    assetsIn[i] = assetsToDeposit[i];\\n                    assetsToDeposit[i] = IERC20(dhwParams.assetGroup[i]).balanceOf(address(this)) - withdrawnAssets[i];\\n                }\\n            } else {\\n                for (uint256 i; i < dhwParams.assetGroup.length; ++i) {\\n                    assetsIn[i] = assetsToDeposit[i];\\n                }\\n            }\\n\\n            // - deposit assets into the protocol\\n            _depositToProtocol(dhwParams.assetGroup, assetsToDeposit, dhwParams.slippages);\\n            usdWorth[1] = _getUsdWorth(dhwParams.exchangeRates, dhwParams.priceFeedManager);\\n\\n            // - mint SSTs\\n            mintedShares = _mintStrategyShares(usdWorth[0], usdWorth[1]);\\n\\n            emit Deposited(mintedShares, usdWorth[1] - usdWorth[0], assetsIn, assetsToDeposit);\\n\\n            mintedShares += matchedShares;\\n        } else if (withdrawnShares > depositShareEquivalent) {\\n            // Withdrawal is needed.\\n\\n            // - match if needed\\n            if (matchedShares > 0) {\\n                unchecked {\\n                    withdrawnShares -= matchedShares;\\n                    mintedShares = matchedShares;\\n                }\\n            }\\n\\n            // - redeem shares from protocol\\n            _redeemFromProtocol(dhwParams.assetGroup, withdrawnShares, dhwParams.slippages);\\n            _burn(address(this), withdrawnShares);\\n            withdrawn = true;\\n\\n            // - figure out how much was withdrawn\\n            usdWorth[1] = _getUsdWorth(dhwParams.exchangeRates, dhwParams.priceFeedManager);\\n            unchecked {\\n                for (uint256 i; i < dhwParams.assetGroup.length; ++i) {\\n                    withdrawnAssets[i] = IERC20(dhwParams.assetGroup[i]).balanceOf(address(this));\\n                }\\n            }\\n\\n            emit Withdrawn(withdrawnShares, usdWorth[1], withdrawnAssets);\\n        } else {\\n            // Neither withdrawal nor deposit is needed.\\n\\n            // - match if needed\\n            if (matchedShares > 0) {\\n                mintedShares = withdrawnShares;\\n                unchecked {\\n                    for (uint256 i; i < dhwParams.assetGroup.length; ++i) {\\n                        withdrawnAssets[i] = assetsToDeposit[i];\\n                    }\\n                }\\n                withdrawn = true;\\n            }\\n\\n            usdWorth[1] = usdWorth[0];\\n        }\\n\\n        // Transfer withdrawn assets to master wallet if needed.\\n        if (withdrawn) {\\n            unchecked {\\n                for (uint256 i; i < dhwParams.assetGroup.length; ++i) {\\n                    IERC20(dhwParams.assetGroup[i]).safeTransfer(dhwParams.masterWallet, withdrawnAssets[i]);\\n                }\\n            }\\n        }\\n\\n        dhwInfo.sharesMinted = mintedShares;\\n        dhwInfo.assetsWithdrawn = withdrawnAssets;\\n        dhwInfo.valueAtDhw = usdWorth[1];\\n        dhwInfo.totalSstsAtDhw = totalSupply();\\n    }\\n\\n    function redeemFast(\\n        uint256 shares,\\n        address masterWallet,\\n        address[] calldata assetGroup,\\n        uint256[] calldata slippages\\n    ) external returns (uint256[] memory) {\\n        if (\\n            !_accessControl.hasRole(ROLE_SMART_VAULT_MANAGER, msg.sender)\\n                && !_accessControl.hasRole(ROLE_STRATEGY_REGISTRY, msg.sender)\\n        ) {\\n            revert NotFastRedeemer(msg.sender);\\n        }\\n\\n        return _redeemShares(shares, address(this), masterWallet, assetGroup, slippages);\\n    }\\n\\n    function redeemShares(uint256 shares, address redeemer, address[] calldata assetGroup, uint256[] calldata slippages)\\n        external\\n        returns (uint256[] memory)\\n    {\\n        _checkRole(ROLE_STRATEGY_REGISTRY, msg.sender);\\n\\n        return _redeemShares(shares, redeemer, redeemer, assetGroup, slippages);\\n    }\\n\\n    /// @dev is only called when reallocating\\n    function depositFast(\\n        address[] calldata assetGroup,\\n        uint256[] calldata exchangeRates,\\n        IUsdPriceFeedManager priceFeedManager,\\n        uint256[] calldata slippages,\\n        SwapInfo[] calldata swapInfo\\n    ) external onlyRole(ROLE_SMART_VAULT_MANAGER, msg.sender) returns (uint256) {\\n        // get amount of assets available to deposit\\n        uint256[] memory assetsToDeposit = new uint256[](assetGroup.length);\\n        for (uint256 i; i < assetGroup.length; ++i) {\\n            assetsToDeposit[i] = IERC20(assetGroup[i]).balanceOf(address(this));\\n        }\\n\\n        // swap assets\\n        _swapAssets(assetGroup, assetsToDeposit, swapInfo);\\n        for (uint256 i; i < assetGroup.length; ++i) {\\n            assetsToDeposit[i] = IERC20(assetGroup[i]).balanceOf(address(this));\\n        }\\n\\n        // deposit assets\\n        uint256 usdWorth0 = _getUsdWorth(exchangeRates, priceFeedManager);\\n        _depositToProtocol(assetGroup, assetsToDeposit, slippages);\\n        uint256 usdWorth1 = _getUsdWorth(exchangeRates, priceFeedManager);\\n\\n        // mint SSTs\\n        uint256 sstsToMint = _mintStrategyShares(usdWorth0, usdWorth1);\\n\\n        return sstsToMint;\\n    }\\n\\n    function claimShares(address smartVault, uint256 amount) external onlyRole(ROLE_SMART_VAULT_MANAGER, msg.sender) {\\n        _transfer(address(this), smartVault, amount);\\n    }\\n\\n    function releaseShares(address smartVault, uint256 amount)\\n        external\\n        onlyRole(ROLE_SMART_VAULT_MANAGER, msg.sender)\\n    {\\n        _transfer(smartVault, address(this), amount);\\n    }\\n\\n    function emergencyWithdraw(uint256[] calldata slippages, address recipient)\\n        external\\n        onlyRole(ROLE_STRATEGY_REGISTRY, msg.sender)\\n    {\\n        _emergencyWithdrawImpl(slippages, recipient);\\n    }\\n\\n    function getProtocolRewards() external onlyViewExecution returns (address[] memory, uint256[] memory) {\\n        return _getProtocolRewardsInternal();\\n    }\\n\\n    function getUsdWorth(uint256[] memory exchangeRates, IUsdPriceFeedManager priceFeedManager)\\n        external\\n        onlyRole(ROLE_SMART_VAULT_MANAGER, msg.sender)\\n        returns (uint256)\\n    {\\n        return _getUsdWorth(exchangeRates, priceFeedManager);\\n    }\\n\\n    /* ========== PRIVATE/INTERNAL FUNCTIONS ========== */\\n\\n    function _mintStrategyShares(uint256 usdWorthBefore, uint256 usdWorthAfter)\\n        private\\n        returns (uint256 mintedShares)\\n    {\\n        uint256 totalSupply_ = totalSupply();\\n\\n        if (totalSupply_ < INITIAL_LOCKED_SHARES) {\\n            // multiply with usd worth after deposit as there are no other owned shares\\n            mintedShares = usdWorthAfter * INITIAL_SHARE_MULTIPLIER;\\n\\n            unchecked {\\n                uint256 lockedSharesLeftToMint = INITIAL_LOCKED_SHARES - totalSupply_;\\n\\n                if (mintedShares < lockedSharesLeftToMint) {\\n                    lockedSharesLeftToMint = mintedShares;\\n                }\\n\\n                mintedShares -= lockedSharesLeftToMint;\\n\\n                _mint(INITIAL_LOCKED_SHARES_ADDRESS, lockedSharesLeftToMint);\\n            }\\n        } else if (usdWorthBefore > 0) {\\n            mintedShares = (usdWorthAfter - usdWorthBefore) * totalSupply_ / usdWorthBefore;\\n        } else {\\n            revert StrategyWorthIsZero();\\n        }\\n\\n        _mint(address(this), mintedShares);\\n    }\\n\\n    function _redeemShares(\\n        uint256 shares,\\n        address shareOwner,\\n        address recipient,\\n        address[] calldata assetGroup,\\n        uint256[] calldata slippages\\n    ) internal virtual returns (uint256[] memory) {\\n        // redeem shares from protocol\\n        uint256[] memory assetsWithdrawn = _redeemFromProtocolAndReturnAssets(assetGroup, shares, slippages);\\n        _burn(shareOwner, shares);\\n\\n        // transfer assets to recipient (master wallet in case of redeemFast)\\n        unchecked {\\n            for (uint256 i; i < assetGroup.length; ++i) {\\n                IERC20(assetGroup[i]).safeTransfer(recipient, assetsWithdrawn[i]);\\n            }\\n        }\\n\\n        return assetsWithdrawn;\\n    }\\n\\n    /**\\n     * @notice Calculate and mint platform performance fees based on the yield generated.\\n     * @param yieldPct Yield generated since previous DHW. Full percent is `YIELD_FULL_PERCENT`.\\n     * @param platformFees Platform fees info, containing information of the sice and recipient of the fees (SSTs).\\n     * @return sharesMinted Returns newly minted shares representing the platform performance fees.\\n     */\\n    function _collectPlatformFees(int256 yieldPct, PlatformFees calldata platformFees)\\n        internal\\n        virtual\\n        returns (uint256 sharesMinted)\\n    {\\n        if (yieldPct > 0) {\\n            uint256 uint256YieldPct = uint256(yieldPct);\\n\\n            uint256 yieldPctUsersPlusOne = uint256YieldPct\\n                * (FULL_PERCENT - platformFees.ecosystemFeePct - platformFees.treasuryFeePct)\\n                + FULL_PERCENT * YIELD_FULL_PERCENT;\\n            uint256 totalSupplyTimesYieldPct = totalSupply() * uint256YieldPct;\\n\\n            // mint new ecosystem fee SSTs\\n            uint256 newEcosystemFeeSsts = totalSupplyTimesYieldPct * platformFees.ecosystemFeePct / yieldPctUsersPlusOne;\\n            _mint(platformFees.ecosystemFeeReceiver, newEcosystemFeeSsts);\\n\\n            // mint new treasury fee SSTs\\n            uint256 newTreasuryFeeSsts = totalSupplyTimesYieldPct * platformFees.treasuryFeePct / yieldPctUsersPlusOne;\\n            _mint(platformFees.treasuryFeeReceiver, newTreasuryFeeSsts);\\n\\n            unchecked {\\n                sharesMinted = newEcosystemFeeSsts + newTreasuryFeeSsts;\\n            }\\n\\n            emit PlatformFeesCollected(address(this), sharesMinted);\\n        }\\n    }\\n\\n    function _redeemFromProtocolAndReturnAssets(address[] calldata tokens, uint256 ssts, uint256[] calldata slippages)\\n        internal\\n        virtual\\n        returns (uint256[] memory withdrawnAssets)\\n    {\\n        withdrawnAssets = new uint256[](tokens.length);\\n        for (uint256 i; i < tokens.length; ++i) {\\n            withdrawnAssets[i] = IERC20(tokens[i]).balanceOf(address(this));\\n        }\\n\\n        _redeemFromProtocol(tokens, ssts, slippages);\\n\\n        for (uint256 i; i < tokens.length; ++i) {\\n            withdrawnAssets[i] = IERC20(tokens[i]).balanceOf(address(this)) - withdrawnAssets[i];\\n        }\\n    }\\n\\n    function _calculateYieldPercentage(uint256 previousValue, uint256 currentValue)\\n        internal\\n        pure\\n        returns (int256 yieldPercentage)\\n    {\\n        if (currentValue > previousValue) {\\n            yieldPercentage = int256((currentValue - previousValue) * YIELD_FULL_PERCENT / previousValue);\\n        } else if (previousValue > currentValue) {\\n            yieldPercentage = -int256((previousValue - currentValue) * YIELD_FULL_PERCENT / previousValue);\\n        }\\n    }\\n\\n    function _resetAndApprove(IERC20 token, address spender, uint256 amount) internal {\\n        _resetAllowance(token, spender);\\n        token.safeApprove(spender, amount);\\n    }\\n\\n    function _resetAllowance(IERC20 token, address spender) internal {\\n        if (token.allowance(address(this), spender) > 0) {\\n            token.safeApprove(spender, 0);\\n        }\\n    }\\n\\n    function _isViewExecution() internal view returns (bool) {\\n        return tx.origin == address(0);\\n    }\\n\\n    function _compound(address[] calldata tokens, SwapInfo[] calldata compoundSwapInfo, uint256[] calldata slippages)\\n        internal\\n        virtual\\n        returns (int256 compoundYield);\\n\\n    function _getYieldPercentage(int256 manualYield) internal virtual returns (int256);\\n\\n    /**\\n     * @dev Swaps assets.\\n     * @param tokens Addresses of tokens to swap.\\n     * @param toSwap Available amounts to swap.\\n     * @param swapInfo Information on how to swap.\\n     */\\n    function _swapAssets(address[] memory tokens, uint256[] memory toSwap, SwapInfo[] calldata swapInfo)\\n        internal\\n        virtual;\\n\\n    /**\\n     * @dev Deposits assets into the underlying protocol.\\n     * @param tokens Addresses of asset tokens.\\n     * @param amounts Amounts to deposit.\\n     * @param slippages Slippages to guard depositing.\\n     */\\n    function _depositToProtocol(address[] calldata tokens, uint256[] memory amounts, uint256[] calldata slippages)\\n        internal\\n        virtual;\\n\\n    /**\\n     * @dev Redeems shares from the undelying protocol.\\n     * @param tokens Addresses of asset tokens.\\n     * @param ssts Amount of strategy tokens to redeem.\\n     * @param slippages Slippages to guard redeemal.\\n     */\\n    function _redeemFromProtocol(address[] calldata tokens, uint256 ssts, uint256[] calldata slippages)\\n        internal\\n        virtual;\\n\\n    function _emergencyWithdrawImpl(uint256[] calldata slippages, address recipient) internal virtual;\\n\\n    function _getUsdWorth(uint256[] memory exchangeRates, IUsdPriceFeedManager priceFeedManager)\\n        internal\\n        virtual\\n        returns (uint256);\\n\\n    /**\\n     * @dev Gets protocol rewards.\\n     * @return tokens Addresses of reward tokens.\\n     * @return amounts Amount of each reward token.\\n     */\\n    function _getProtocolRewardsInternal()\\n        internal\\n        virtual\\n        returns (address[] memory tokens, uint256[] memory amounts);\\n\\n    /* ========== MODIFIERS ========== */\\n\\n    modifier onlyViewExecution() {\\n        require(_isViewExecution());\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Permit.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\r\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\r\\n *\\r\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\r\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\r\\n * need to send a transaction, and thus is not required to hold Ether at all.\\r\\n */\\r\\ninterface IERC20Permit {\\r\\n    /**\\r\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\r\\n     * given ``owner``'s signed approval.\\r\\n     *\\r\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\r\\n     * ordering also apply here.\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `spender` cannot be the zero address.\\r\\n     * - `deadline` must be a timestamp in the future.\\r\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\r\\n     * over the EIP712-formatted function arguments.\\r\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\r\\n     *\\r\\n     * For more information on the signature format, see the\\r\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\r\\n     * section].\\r\\n     */\\r\\n    function permit(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 value,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the current nonce for `owner`. This value must be\\r\\n     * included whenever a signature is generated for {permit}.\\r\\n     *\\r\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\r\\n     * prevents a signature from being used multiple times.\\r\\n     */\\r\\n    function nonces(address owner) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\r\\n     */\\r\\n    // solhint-disable-next-line func-name-mixedcase\\r\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\r\\n\\r\\npragma solidity ^0.8.1;\\r\\n\\r\\n/**\\r\\n * @dev Collection of functions related to the address type\\r\\n */\\r\\nlibrary Address {\\r\\n    /**\\r\\n     * @dev Returns true if `account` is a contract.\\r\\n     *\\r\\n     * [IMPORTANT]\\r\\n     * ====\\r\\n     * It is unsafe to assume that an address for which this function returns\\r\\n     * false is an externally-owned account (EOA) and not a contract.\\r\\n     *\\r\\n     * Among others, `isContract` will return false for the following\\r\\n     * types of addresses:\\r\\n     *\\r\\n     *  - an externally-owned account\\r\\n     *  - a contract in construction\\r\\n     *  - an address where a contract will be created\\r\\n     *  - an address where a contract lived, but was destroyed\\r\\n     *\\r\\n     * Furthermore, `isContract` will also return true if the target contract within\\r\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\r\\n     * which only has an effect at the end of a transaction.\\r\\n     * ====\\r\\n     *\\r\\n     * [IMPORTANT]\\r\\n     * ====\\r\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\r\\n     *\\r\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\r\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\r\\n     * constructor.\\r\\n     * ====\\r\\n     */\\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n        // This method relies on extcodesize/address.code.length, which returns 0\\r\\n        // for contracts in construction, since the code is only stored at the end\\r\\n        // of the constructor execution.\\r\\n\\r\\n        return account.code.length > 0;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\r\\n     * `recipient`, forwarding all available gas and reverting on errors.\\r\\n     *\\r\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\r\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\r\\n     * imposed by `transfer`, making them unable to receive funds via\\r\\n     * `transfer`. {sendValue} removes this limitation.\\r\\n     *\\r\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\r\\n     *\\r\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\r\\n     * taken to not create reentrancy vulnerabilities. Consider using\\r\\n     * {ReentrancyGuard} or the\\r\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\r\\n     */\\r\\n    function sendValue(address payable recipient, uint256 amount) internal {\\r\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\r\\n\\r\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\r\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Performs a Solidity function call using a low level `call`. A\\r\\n     * plain `call` is an unsafe replacement for a function call: use this\\r\\n     * function instead.\\r\\n     *\\r\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\r\\n     * function (like regular Solidity function calls).\\r\\n     *\\r\\n     * Returns the raw returned data. To convert to the expected return value,\\r\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `target` must be a contract.\\r\\n     * - calling `target` with `data` must not revert.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\r\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCall(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        string memory errorMessage\\r\\n    ) internal returns (bytes memory) {\\r\\n        return functionCallWithValue(target, data, 0, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but also transferring `value` wei to `target`.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the calling contract must have an ETH balance of at least `value`.\\r\\n     * - the called Solidity function must be `payable`.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\r\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\r\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCallWithValue(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        uint256 value,\\r\\n        string memory errorMessage\\r\\n    ) internal returns (bytes memory) {\\r\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\r\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\r\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but performing a static call.\\r\\n     *\\r\\n     * _Available since v3.3._\\r\\n     */\\r\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\r\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\r\\n     * but performing a static call.\\r\\n     *\\r\\n     * _Available since v3.3._\\r\\n     */\\r\\n    function functionStaticCall(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        string memory errorMessage\\r\\n    ) internal view returns (bytes memory) {\\r\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\r\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but performing a delegate call.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\r\\n     * but performing a delegate call.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function functionDelegateCall(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        string memory errorMessage\\r\\n    ) internal returns (bytes memory) {\\r\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\r\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\r\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\r\\n     *\\r\\n     * _Available since v4.8._\\r\\n     */\\r\\n    function verifyCallResultFromTarget(\\r\\n        address target,\\r\\n        bool success,\\r\\n        bytes memory returndata,\\r\\n        string memory errorMessage\\r\\n    ) internal view returns (bytes memory) {\\r\\n        if (success) {\\r\\n            if (returndata.length == 0) {\\r\\n                // only check isContract if the call was successful and the return data is empty\\r\\n                // otherwise we already know that it was a contract\\r\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\r\\n            }\\r\\n            return returndata;\\r\\n        } else {\\r\\n            _revert(returndata, errorMessage);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\r\\n     * revert reason or using the provided one.\\r\\n     *\\r\\n     * _Available since v4.3._\\r\\n     */\\r\\n    function verifyCallResult(\\r\\n        bool success,\\r\\n        bytes memory returndata,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (bytes memory) {\\r\\n        if (success) {\\r\\n            return returndata;\\r\\n        } else {\\r\\n            _revert(returndata, errorMessage);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\r\\n        // Look for revert reason and bubble it up if present\\r\\n        if (returndata.length > 0) {\\r\\n            // The easiest way to bubble the revert reason is using memory via assembly\\r\\n            /// @solidity memory-safe-assembly\\r\\n            assembly {\\r\\n                let returndata_size := mload(returndata)\\r\\n                revert(add(32, returndata), returndata_size)\\r\\n            }\\r\\n        } else {\\r\\n            revert(errorMessage);\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"../IERC20.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\r\\n *\\r\\n * _Available since v4.1._\\r\\n */\\r\\ninterface IERC20Metadata is IERC20 {\\r\\n    /**\\r\\n     * @dev Returns the name of the token.\\r\\n     */\\r\\n    function name() external view returns (string memory);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the symbol of the token.\\r\\n     */\\r\\n    function symbol() external view returns (string memory);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the decimals places of the token.\\r\\n     */\\r\\n    function decimals() external view returns (uint8);\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Standard math utilities missing in the Solidity language.\\r\\n */\\r\\nlibrary Math {\\r\\n    enum Rounding {\\r\\n        Down, // Toward negative infinity\\r\\n        Up, // Toward infinity\\r\\n        Zero // Toward zero\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the largest of two numbers.\\r\\n     */\\r\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a > b ? a : b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the smallest of two numbers.\\r\\n     */\\r\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a < b ? a : b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the average of two numbers. The result is rounded towards\\r\\n     * zero.\\r\\n     */\\r\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // (a + b) / 2 can overflow.\\r\\n        return (a & b) + (a ^ b) / 2;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the ceiling of the division of two numbers.\\r\\n     *\\r\\n     * This differs from standard division with `/` in that it rounds up instead\\r\\n     * of rounding down.\\r\\n     */\\r\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\r\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\r\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\r\\n     * with further edits by Uniswap Labs also under MIT license.\\r\\n     */\\r\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\r\\n        unchecked {\\r\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\r\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\r\\n            // variables such that product = prod1 * 2^256 + prod0.\\r\\n            uint256 prod0; // Least significant 256 bits of the product\\r\\n            uint256 prod1; // Most significant 256 bits of the product\\r\\n            assembly {\\r\\n                let mm := mulmod(x, y, not(0))\\r\\n                prod0 := mul(x, y)\\r\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\r\\n            }\\r\\n\\r\\n            // Handle non-overflow cases, 256 by 256 division.\\r\\n            if (prod1 == 0) {\\r\\n                return prod0 / denominator;\\r\\n            }\\r\\n\\r\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\r\\n            require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\r\\n\\r\\n            ///////////////////////////////////////////////\\r\\n            // 512 by 256 division.\\r\\n            ///////////////////////////////////////////////\\r\\n\\r\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\r\\n            uint256 remainder;\\r\\n            assembly {\\r\\n                // Compute remainder using mulmod.\\r\\n                remainder := mulmod(x, y, denominator)\\r\\n\\r\\n                // Subtract 256 bit number from 512 bit number.\\r\\n                prod1 := sub(prod1, gt(remainder, prod0))\\r\\n                prod0 := sub(prod0, remainder)\\r\\n            }\\r\\n\\r\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\r\\n            // See https://cs.stackexchange.com/q/138556/92363.\\r\\n\\r\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\r\\n            uint256 twos = denominator & (~denominator + 1);\\r\\n            assembly {\\r\\n                // Divide denominator by twos.\\r\\n                denominator := div(denominator, twos)\\r\\n\\r\\n                // Divide [prod1 prod0] by twos.\\r\\n                prod0 := div(prod0, twos)\\r\\n\\r\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\r\\n                twos := add(div(sub(0, twos), twos), 1)\\r\\n            }\\r\\n\\r\\n            // Shift in bits from prod1 into prod0.\\r\\n            prod0 |= prod1 * twos;\\r\\n\\r\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\r\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\r\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\r\\n            uint256 inverse = (3 * denominator) ^ 2;\\r\\n\\r\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\r\\n            // in modular arithmetic, doubling the correct bits in each step.\\r\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\r\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\r\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\r\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\r\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\r\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\r\\n\\r\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\r\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\r\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\r\\n            // is no longer required.\\r\\n            result = prod0 * inverse;\\r\\n            return result;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\r\\n     */\\r\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\r\\n        uint256 result = mulDiv(x, y, denominator);\\r\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\r\\n            result += 1;\\r\\n        }\\r\\n        return result;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\r\\n     *\\r\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\r\\n     */\\r\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\r\\n        //\\r\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\r\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\r\\n        //\\r\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\r\\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\r\\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\r\\n        //\\r\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\r\\n        uint256 result = 1 << (log2(a) >> 1);\\r\\n\\r\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\r\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\r\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\r\\n        // into the expected uint128 result.\\r\\n        unchecked {\\r\\n            result = (result + a / result) >> 1;\\r\\n            result = (result + a / result) >> 1;\\r\\n            result = (result + a / result) >> 1;\\r\\n            result = (result + a / result) >> 1;\\r\\n            result = (result + a / result) >> 1;\\r\\n            result = (result + a / result) >> 1;\\r\\n            result = (result + a / result) >> 1;\\r\\n            return min(result, a / result);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\r\\n     */\\r\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            uint256 result = sqrt(a);\\r\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\r\\n     * Returns 0 if given 0.\\r\\n     */\\r\\n    function log2(uint256 value) internal pure returns (uint256) {\\r\\n        uint256 result = 0;\\r\\n        unchecked {\\r\\n            if (value >> 128 > 0) {\\r\\n                value >>= 128;\\r\\n                result += 128;\\r\\n            }\\r\\n            if (value >> 64 > 0) {\\r\\n                value >>= 64;\\r\\n                result += 64;\\r\\n            }\\r\\n            if (value >> 32 > 0) {\\r\\n                value >>= 32;\\r\\n                result += 32;\\r\\n            }\\r\\n            if (value >> 16 > 0) {\\r\\n                value >>= 16;\\r\\n                result += 16;\\r\\n            }\\r\\n            if (value >> 8 > 0) {\\r\\n                value >>= 8;\\r\\n                result += 8;\\r\\n            }\\r\\n            if (value >> 4 > 0) {\\r\\n                value >>= 4;\\r\\n                result += 4;\\r\\n            }\\r\\n            if (value >> 2 > 0) {\\r\\n                value >>= 2;\\r\\n                result += 2;\\r\\n            }\\r\\n            if (value >> 1 > 0) {\\r\\n                result += 1;\\r\\n            }\\r\\n        }\\r\\n        return result;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\r\\n     * Returns 0 if given 0.\\r\\n     */\\r\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            uint256 result = log2(value);\\r\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\r\\n     * Returns 0 if given 0.\\r\\n     */\\r\\n    function log10(uint256 value) internal pure returns (uint256) {\\r\\n        uint256 result = 0;\\r\\n        unchecked {\\r\\n            if (value >= 10 ** 64) {\\r\\n                value /= 10 ** 64;\\r\\n                result += 64;\\r\\n            }\\r\\n            if (value >= 10 ** 32) {\\r\\n                value /= 10 ** 32;\\r\\n                result += 32;\\r\\n            }\\r\\n            if (value >= 10 ** 16) {\\r\\n                value /= 10 ** 16;\\r\\n                result += 16;\\r\\n            }\\r\\n            if (value >= 10 ** 8) {\\r\\n                value /= 10 ** 8;\\r\\n                result += 8;\\r\\n            }\\r\\n            if (value >= 10 ** 4) {\\r\\n                value /= 10 ** 4;\\r\\n                result += 4;\\r\\n            }\\r\\n            if (value >= 10 ** 2) {\\r\\n                value /= 10 ** 2;\\r\\n                result += 2;\\r\\n            }\\r\\n            if (value >= 10 ** 1) {\\r\\n                result += 1;\\r\\n            }\\r\\n        }\\r\\n        return result;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\r\\n     * Returns 0 if given 0.\\r\\n     */\\r\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            uint256 result = log10(value);\\r\\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\r\\n     * Returns 0 if given 0.\\r\\n     *\\r\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\r\\n     */\\r\\n    function log256(uint256 value) internal pure returns (uint256) {\\r\\n        uint256 result = 0;\\r\\n        unchecked {\\r\\n            if (value >> 128 > 0) {\\r\\n                value >>= 128;\\r\\n                result += 16;\\r\\n            }\\r\\n            if (value >> 64 > 0) {\\r\\n                value >>= 64;\\r\\n                result += 8;\\r\\n            }\\r\\n            if (value >> 32 > 0) {\\r\\n                value >>= 32;\\r\\n                result += 4;\\r\\n            }\\r\\n            if (value >> 16 > 0) {\\r\\n                value >>= 16;\\r\\n                result += 2;\\r\\n            }\\r\\n            if (value >> 8 > 0) {\\r\\n                result += 1;\\r\\n            }\\r\\n        }\\r\\n        return result;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\r\\n     * Returns 0 if given 0.\\r\\n     */\\r\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            uint256 result = log256(value);\\r\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./IERC20Upgradeable.sol\\\";\\r\\nimport \\\"./extensions/IERC20MetadataUpgradeable.sol\\\";\\r\\nimport \\\"../../utils/ContextUpgradeable.sol\\\";\\r\\nimport \\\"../../proxy/utils/Initializable.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Implementation of the {IERC20} interface.\\r\\n *\\r\\n * This implementation is agnostic to the way tokens are created. This means\\r\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\r\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\r\\n *\\r\\n * TIP: For a detailed writeup see our guide\\r\\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\\r\\n * to implement supply mechanisms].\\r\\n *\\r\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\r\\n * instead returning `false` on failure. This behavior is nonetheless\\r\\n * conventional and does not conflict with the expectations of ERC20\\r\\n * applications.\\r\\n *\\r\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\r\\n * This allows applications to reconstruct the allowance for all accounts just\\r\\n * by listening to said events. Other implementations of the EIP may not emit\\r\\n * these events, as it isn't required by the specification.\\r\\n *\\r\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\r\\n * functions have been added to mitigate the well-known issues around setting\\r\\n * allowances. See {IERC20-approve}.\\r\\n */\\r\\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\\r\\n    mapping(address => uint256) private _balances;\\r\\n\\r\\n    mapping(address => mapping(address => uint256)) private _allowances;\\r\\n\\r\\n    uint256 private _totalSupply;\\r\\n\\r\\n    string private _name;\\r\\n    string private _symbol;\\r\\n\\r\\n    /**\\r\\n     * @dev Sets the values for {name} and {symbol}.\\r\\n     *\\r\\n     * The default value of {decimals} is 18. To select a different value for\\r\\n     * {decimals} you should overload it.\\r\\n     *\\r\\n     * All two of these values are immutable: they can only be set once during\\r\\n     * construction.\\r\\n     */\\r\\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\\r\\n        __ERC20_init_unchained(name_, symbol_);\\r\\n    }\\r\\n\\r\\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\\r\\n        _name = name_;\\r\\n        _symbol = symbol_;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the name of the token.\\r\\n     */\\r\\n    function name() public view virtual override returns (string memory) {\\r\\n        return _name;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\r\\n     * name.\\r\\n     */\\r\\n    function symbol() public view virtual override returns (string memory) {\\r\\n        return _symbol;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the number of decimals used to get its user representation.\\r\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\r\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\r\\n     *\\r\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\r\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\r\\n     * overridden;\\r\\n     *\\r\\n     * NOTE: This information is only used for _display_ purposes: it in\\r\\n     * no way affects any of the arithmetic of the contract, including\\r\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\r\\n     */\\r\\n    function decimals() public view virtual override returns (uint8) {\\r\\n        return 18;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-totalSupply}.\\r\\n     */\\r\\n    function totalSupply() public view virtual override returns (uint256) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-balanceOf}.\\r\\n     */\\r\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\r\\n        return _balances[account];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-transfer}.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `to` cannot be the zero address.\\r\\n     * - the caller must have a balance of at least `amount`.\\r\\n     */\\r\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\r\\n        address owner = _msgSender();\\r\\n        _transfer(owner, to, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-allowance}.\\r\\n     */\\r\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\r\\n        return _allowances[owner][spender];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-approve}.\\r\\n     *\\r\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\r\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `spender` cannot be the zero address.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\r\\n        address owner = _msgSender();\\r\\n        _approve(owner, spender, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-transferFrom}.\\r\\n     *\\r\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\r\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\r\\n     *\\r\\n     * NOTE: Does not update the allowance if the current allowance\\r\\n     * is the maximum `uint256`.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `from` and `to` cannot be the zero address.\\r\\n     * - `from` must have a balance of at least `amount`.\\r\\n     * - the caller must have allowance for ``from``'s tokens of at least\\r\\n     * `amount`.\\r\\n     */\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) public virtual override returns (bool) {\\r\\n        address spender = _msgSender();\\r\\n        _spendAllowance(from, spender, amount);\\r\\n        _transfer(from, to, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\r\\n     *\\r\\n     * This is an alternative to {approve} that can be used as a mitigation for\\r\\n     * problems described in {IERC20-approve}.\\r\\n     *\\r\\n     * Emits an {Approval} event indicating the updated allowance.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `spender` cannot be the zero address.\\r\\n     */\\r\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\r\\n        address owner = _msgSender();\\r\\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\r\\n     *\\r\\n     * This is an alternative to {approve} that can be used as a mitigation for\\r\\n     * problems described in {IERC20-approve}.\\r\\n     *\\r\\n     * Emits an {Approval} event indicating the updated allowance.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `spender` cannot be the zero address.\\r\\n     * - `spender` must have allowance for the caller of at least\\r\\n     * `subtractedValue`.\\r\\n     */\\r\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\r\\n        address owner = _msgSender();\\r\\n        uint256 currentAllowance = allowance(owner, spender);\\r\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\r\\n        unchecked {\\r\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\r\\n        }\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` of tokens from `from` to `to`.\\r\\n     *\\r\\n     * This internal function is equivalent to {transfer}, and can be used to\\r\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `from` cannot be the zero address.\\r\\n     * - `to` cannot be the zero address.\\r\\n     * - `from` must have a balance of at least `amount`.\\r\\n     */\\r\\n    function _transfer(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) internal virtual {\\r\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\r\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\r\\n\\r\\n        _beforeTokenTransfer(from, to, amount);\\r\\n\\r\\n        uint256 fromBalance = _balances[from];\\r\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\r\\n        unchecked {\\r\\n            _balances[from] = fromBalance - amount;\\r\\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\\r\\n            // decrementing then incrementing.\\r\\n            _balances[to] += amount;\\r\\n        }\\r\\n\\r\\n        emit Transfer(from, to, amount);\\r\\n\\r\\n        _afterTokenTransfer(from, to, amount);\\r\\n    }\\r\\n\\r\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\r\\n     * the total supply.\\r\\n     *\\r\\n     * Emits a {Transfer} event with `from` set to the zero address.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `account` cannot be the zero address.\\r\\n     */\\r\\n    function _mint(address account, uint256 amount) internal virtual {\\r\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\r\\n\\r\\n        _beforeTokenTransfer(address(0), account, amount);\\r\\n\\r\\n        _totalSupply += amount;\\r\\n        unchecked {\\r\\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\\r\\n            _balances[account] += amount;\\r\\n        }\\r\\n        emit Transfer(address(0), account, amount);\\r\\n\\r\\n        _afterTokenTransfer(address(0), account, amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\r\\n     * total supply.\\r\\n     *\\r\\n     * Emits a {Transfer} event with `to` set to the zero address.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `account` cannot be the zero address.\\r\\n     * - `account` must have at least `amount` tokens.\\r\\n     */\\r\\n    function _burn(address account, uint256 amount) internal virtual {\\r\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\r\\n\\r\\n        _beforeTokenTransfer(account, address(0), amount);\\r\\n\\r\\n        uint256 accountBalance = _balances[account];\\r\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\r\\n        unchecked {\\r\\n            _balances[account] = accountBalance - amount;\\r\\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\\r\\n            _totalSupply -= amount;\\r\\n        }\\r\\n\\r\\n        emit Transfer(account, address(0), amount);\\r\\n\\r\\n        _afterTokenTransfer(account, address(0), amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\r\\n     *\\r\\n     * This internal function is equivalent to `approve`, and can be used to\\r\\n     * e.g. set automatic allowances for certain subsystems, etc.\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `owner` cannot be the zero address.\\r\\n     * - `spender` cannot be the zero address.\\r\\n     */\\r\\n    function _approve(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 amount\\r\\n    ) internal virtual {\\r\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\r\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\r\\n\\r\\n        _allowances[owner][spender] = amount;\\r\\n        emit Approval(owner, spender, amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\\r\\n     *\\r\\n     * Does not update the allowance amount in case of infinite allowance.\\r\\n     * Revert if not enough allowance is available.\\r\\n     *\\r\\n     * Might emit an {Approval} event.\\r\\n     */\\r\\n    function _spendAllowance(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 amount\\r\\n    ) internal virtual {\\r\\n        uint256 currentAllowance = allowance(owner, spender);\\r\\n        if (currentAllowance != type(uint256).max) {\\r\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\r\\n            unchecked {\\r\\n                _approve(owner, spender, currentAllowance - amount);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Hook that is called before any transfer of tokens. This includes\\r\\n     * minting and burning.\\r\\n     *\\r\\n     * Calling conditions:\\r\\n     *\\r\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\r\\n     * will be transferred to `to`.\\r\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\r\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\r\\n     * - `from` and `to` are never both zero.\\r\\n     *\\r\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\r\\n     */\\r\\n    function _beforeTokenTransfer(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) internal virtual {}\\r\\n\\r\\n    /**\\r\\n     * @dev Hook that is called after any transfer of tokens. This includes\\r\\n     * minting and burning.\\r\\n     *\\r\\n     * Calling conditions:\\r\\n     *\\r\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\r\\n     * has been transferred to `to`.\\r\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\r\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\r\\n     * - `from` and `to` are never both zero.\\r\\n     *\\r\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\r\\n     */\\r\\n    function _afterTokenTransfer(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) internal virtual {}\\r\\n\\r\\n    /**\\r\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\r\\n     * variables without shifting down storage in the inheritance chain.\\r\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\r\\n     */\\r\\n    uint256[45] private __gap;\\r\\n}\\r\\n\"\r\n    },\r\n    \"src/interfaces/Constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.17;\\n\\n/// @dev Number of seconds in an average year.\\nuint256 constant SECONDS_IN_YEAR = 31_556_926;\\n\\n/// @dev Number of seconds in an average year.\\nint256 constant SECONDS_IN_YEAR_INT = 31_556_926;\\n\\n/// @dev Represents 100%.\\nuint256 constant FULL_PERCENT = 100_00;\\n\\n/// @dev Represents 100%.\\nint256 constant FULL_PERCENT_INT = 100_00;\\n\\n/// @dev Represents 100% for yield.\\nint256 constant YIELD_FULL_PERCENT_INT = 10 ** 12;\\n\\n/// @dev Represents 100% for yield.\\nuint256 constant YIELD_FULL_PERCENT = uint256(YIELD_FULL_PERCENT_INT);\\n\\n/// @dev Maximal management fee that can be set on a smart vault. Expressed in terms of FULL_PERCENT.\\nuint256 constant MANAGEMENT_FEE_MAX = 5_00;\\n\\n/// @dev Maximal deposit fee that can be set on a smart vault. Expressed in terms of FULL_PERCENT.\\nuint256 constant DEPOSIT_FEE_MAX = 5_00;\\n\\n/// @dev Maximal smart vault performance fee that can be set on a smart vault. Expressed in terms of FULL_PERCENT.\\nuint256 constant SV_PERFORMANCE_FEE_MAX = 20_00;\\n\\n/// @dev Maximal ecosystem fee that can be set on the system. Expressed in terms of FULL_PERCENT.\\nuint256 constant ECOSYSTEM_FEE_MAX = 20_00;\\n\\n/// @dev Maximal treasury fee that can be set on the system. Expressed in terms of FULL_PERCENT.\\nuint256 constant TREASURY_FEE_MAX = 10_00;\\n\\n/// @dev Maximal risk score a strategy can be assigned.\\nuint8 constant MAX_RISK_SCORE = 10_0;\\n\\n/// @dev Minimal risk score a strategy can be assigned.\\nuint8 constant MIN_RISK_SCORE = 1;\\n\\n/// @dev Maximal value for risk tolerance a smart vautl can have.\\nint8 constant MAX_RISK_TOLERANCE = 10;\\n\\n/// @dev Minimal value for risk tolerance a smart vault can have.\\nint8 constant MIN_RISK_TOLERANCE = -10;\\n\\n/// @dev If set as risk provider, system will return fixed risk score values\\naddress constant STATIC_RISK_PROVIDER = address(0xaaa);\\n\\n/// @dev Fixed values to use if risk provider is set to STATIC_RISK_PROVIDER\\nuint8 constant STATIC_RISK_SCORE = 1;\\n\\n/// @dev Maximal value of deposit NFT ID.\\nuint256 constant MAXIMAL_DEPOSIT_ID = 2 ** 255;\\n\\n/// @dev Maximal value of withdrawal NFT ID.\\nuint256 constant MAXIMAL_WITHDRAWAL_ID = 2 ** 256 - 1;\\n\\n/// @dev How many shares will be minted with a NFT\\nuint256 constant NFT_MINTED_SHARES = 10 ** 6;\\n\\n/// @dev Each smart vault can have up to STRATEGY_COUNT_CAP strategies.\\nuint256 constant STRATEGY_COUNT_CAP = 16;\\n\\n/// @dev Maximal DHW base yield. Expressed in terms of FULL_PERCENT.\\nuint256 constant MAX_DHW_BASE_YIELD_LIMIT = 10_00;\\n\\n/// @dev Smart vault and strategy share multiplier at first deposit.\\nuint256 constant INITIAL_SHARE_MULTIPLIER = 1000;\\n\\n/// @dev Strategy initial locked shares. These shares will never be unlocked.\\nuint256 constant INITIAL_LOCKED_SHARES = 10 ** 12;\\n\\n/// @dev Strategy initial locked shares address.\\naddress constant INITIAL_LOCKED_SHARES_ADDRESS = address(0xdead);\\n\\n/// @dev Maximum number of guards a smart vault can be configured with\\nuint256 constant MAX_GUARD_COUNT = 10;\\n\\n/// @dev Maximum number of actions a smart vault can be configured with\\nuint256 constant MAX_ACTION_COUNT = 10;\\n\\n/// @dev ID of null asset group. Should not be used by any strategy or smart vault.\\nuint256 constant NULL_ASSET_GROUP_ID = 0;\\n\"\r\n    },\r\n    \"src/interfaces/IAssetGroupRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.17;\\n\\nimport \\\"@openzeppelin/token/ERC20/IERC20.sol\\\";\\n\\n/* ========== ERRORS ========== */\\n\\n/**\\n * @notice Used when invalid ID for asset group is provided.\\n * @param assetGroupId Invalid ID for asset group.\\n */\\nerror InvalidAssetGroup(uint256 assetGroupId);\\n\\n/**\\n * @notice Used when no assets are provided for an asset group.\\n */\\nerror NoAssetsProvided();\\n\\n/**\\n * @notice Used when token is not allowed to be used as an asset.\\n * @param token Address of the token that is not allowed.\\n */\\nerror TokenNotAllowed(address token);\\n\\n/**\\n * @notice Used when asset group already exists.\\n * @param assetGroupId ID of the already existing asset group.\\n */\\nerror AssetGroupAlreadyExists(uint256 assetGroupId);\\n\\n/**\\n * @notice Used when given array is unsorted.\\n */\\nerror UnsortedArray();\\n\\n/* ========== INTERFACES ========== */\\n\\ninterface IAssetGroupRegistry {\\n    /* ========== EVENTS ========== */\\n\\n    /**\\n     * @notice Emitted when token is allowed to be used as an asset.\\n     * @param token Address of newly allowed token.\\n     */\\n    event TokenAllowed(address indexed token);\\n\\n    /**\\n     * @notice Emitted when asset group is registered.\\n     * @param assetGroupId ID of the newly registered asset group.\\n     */\\n    event AssetGroupRegistered(uint256 indexed assetGroupId);\\n\\n    /* ========== VIEW FUNCTIONS ========== */\\n\\n    /**\\n     * @notice Checks if token is allowed to be used as an asset.\\n     * @param token Address of token to check.\\n     * @return isAllowed True if token is allowed, false otherwise.\\n     */\\n    function isTokenAllowed(address token) external view returns (bool isAllowed);\\n\\n    /**\\n     * @notice Gets number of registered asset groups.\\n     * @return count Number of registered asset groups.\\n     */\\n    function numberOfAssetGroups() external view returns (uint256 count);\\n\\n    /**\\n     * @notice Gets asset group by its ID.\\n     * @dev Requirements:\\n     * - must provide a valid ID for the asset group\\n     * @return assets Array of assets in the asset group.\\n     */\\n    function listAssetGroup(uint256 assetGroupId) external view returns (address[] memory assets);\\n\\n    /**\\n     * @notice Gets asset group length.\\n     * @dev Requirements:\\n     * - must provide a valid ID for the asset group\\n     * @return length\\n     */\\n    function assetGroupLength(uint256 assetGroupId) external view returns (uint256 length);\\n\\n    /**\\n     * @notice Validates that provided ID represents an asset group.\\n     * @dev Function reverts when ID does not represent an asset group.\\n     * @param assetGroupId ID to validate.\\n     */\\n    function validateAssetGroup(uint256 assetGroupId) external view;\\n\\n    /**\\n     * @notice Checks if asset group composed of assets already exists.\\n     * Will revert if provided assets cannot form an asset group.\\n     * @param assets Assets composing the asset group.\\n     * @return Asset group ID if such asset group exists, 0 otherwise.\\n     */\\n    function checkAssetGroupExists(address[] calldata assets) external view returns (uint256);\\n\\n    /* ========== MUTATIVE FUNCTIONS ========== */\\n\\n    /**\\n     * @notice Allows a token to be used as an asset.\\n     * @dev Requirements:\\n     * - can only be called by the ROLE_SPOOL_ADMIN\\n     * @param token Address of token to be allowed.\\n     */\\n    function allowToken(address token) external;\\n\\n    /**\\n     * @notice Allows tokens to be used as assets.\\n     * @dev Requirements:\\n     * - can only be called by the ROLE_SPOOL_ADMIN\\n     * @param tokens Addresses of tokens to be allowed.\\n     */\\n    function allowTokenBatch(address[] calldata tokens) external;\\n\\n    /**\\n     * @notice Registers a new asset group.\\n     * @dev Requirements:\\n     * - must provide at least one asset\\n     * - all assets must be allowed\\n     * - assets must be sorted\\n     * - such asset group should not exist yet\\n     * - can only be called by the ROLE_SPOOL_ADMIN\\n     * @param assets Array of assets in the asset group.\\n     * @return id Sequential ID assigned to the asset group.\\n     */\\n    function registerAssetGroup(address[] calldata assets) external returns (uint256 id);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IMasterWallet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.17;\\n\\nimport \\\"@openzeppelin/token/ERC20/IERC20.sol\\\";\\n\\ninterface IMasterWallet {\\n    /**\\n     * @notice Transfers amount of token to the recipient.\\n     * @dev Requirements:\\n     * - caller must have role ROLE_MASTER_WALLET_MANAGER\\n     * @param token Token to transfer.\\n     * @param recipient Target of the transfer.\\n     * @param amount Amount to transfer.\\n     */\\n    function transfer(IERC20 token, address recipient, uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IStrategy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.17;\\n\\nimport \\\"@openzeppelin/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport {PlatformFees} from \\\"./IStrategyRegistry.sol\\\";\\nimport \\\"./ISwapper.sol\\\";\\nimport \\\"./IUsdPriceFeedManager.sol\\\";\\n\\n/**\\n * @notice Struct holding information how to swap the assets.\\n * @custom:member slippage minumum output amount\\n * @custom:member path swap path, first byte represents an action (e.g. Uniswap V2 custom swap), rest is swap specific path\\n */\\nstruct SwapData {\\n    uint256 slippage; // min amount out\\n    bytes path; // 1st byte is action, then path\\n}\\n\\n/**\\n * @notice Parameters for calling do hard work on strategy.\\n * @custom:member swapInfo Information for swapping assets before depositing into the protocol.\\n * @custom:member swapInfo Information for swapping rewards before depositing them back into the protocol.\\n * @custom:member slippages Slippages used to constrain depositing and withdrawing from the protocol.\\n * @custom:member assetGroup Asset group of the strategy.\\n * @custom:member exchangeRates Exchange rates for assets.\\n * @custom:member withdrawnShares Strategy shares withdrawn by smart vault.\\n * @custom:member masterWallet Master wallet.\\n * @custom:member priceFeedManager Price feed manager.\\n * @custom:member baseYield Base yield value, manual input for specific strategies.\\n * @custom:member platformFees Platform fees info.\\n */\\nstruct StrategyDhwParameterBag {\\n    SwapInfo[] swapInfo;\\n    SwapInfo[] compoundSwapInfo;\\n    uint256[] slippages;\\n    address[] assetGroup;\\n    uint256[] exchangeRates;\\n    uint256 withdrawnShares;\\n    address masterWallet;\\n    IUsdPriceFeedManager priceFeedManager;\\n    int256 baseYield;\\n    PlatformFees platformFees;\\n}\\n\\n/**\\n * @notice Information about results of the do hard work.\\n * @custom:member sharesMinted Amount of strategy shares minted.\\n * @custom:member assetsWithdrawn Amount of assets withdrawn.\\n * @custom:member yieldPercentage Yield percentage from the previous DHW.\\n * @custom:member valueAtDhw Value of the strategy at the end of DHW.\\n * @custom:member totalSstsAtDhw Total SSTs at the end of DHW.\\n */\\nstruct DhwInfo {\\n    uint256 sharesMinted;\\n    uint256[] assetsWithdrawn;\\n    int256 yieldPercentage;\\n    uint256 valueAtDhw;\\n    uint256 totalSstsAtDhw;\\n}\\n\\n/**\\n * @notice Used when ghost strategy is called.\\n */\\nerror IsGhostStrategy();\\n\\n/**\\n * @notice Used when user is not allowed to redeem fast.\\n * @param user User that tried to redeem fast.\\n */\\nerror NotFastRedeemer(address user);\\n\\n/**\\n * @notice Used when asset group ID is not correctly initialized.\\n */\\nerror InvalidAssetGroupIdInitialization();\\n\\ninterface IStrategy is IERC20Upgradeable {\\n    /* ========== EVENTS ========== */\\n\\n    event Deposited(\\n        uint256 mintedShares, uint256 usdWorthDeposited, uint256[] assetsBeforeSwap, uint256[] assetsDeposited\\n    );\\n\\n    event Withdrawn(uint256 withdrawnShares, uint256 usdWorthWithdrawn, uint256[] withdrawnAssets);\\n\\n    event PlatformFeesCollected(address indexed strategy, uint256 sharesMinted);\\n\\n    event Slippages(bool isDeposit, uint256 slippage, bytes data);\\n\\n    event BeforeDepositCheckSlippages(uint256[] amounts);\\n\\n    event BeforeRedeemalCheckSlippages(uint256 ssts);\\n\\n    /* ========== VIEW FUNCTIONS ========== */\\n\\n    /**\\n     * @notice Gets strategy name.\\n     * @return name Name of the strategy.\\n     */\\n    function strategyName() external view returns (string memory name);\\n\\n    /**\\n     * @notice Gets required ratio between underlying assets.\\n     * @return ratio Required asset ratio for the strategy.\\n     */\\n    function assetRatio() external view returns (uint256[] memory ratio);\\n\\n    /**\\n     * @notice Gets asset group used by the strategy.\\n     * @return id ID of the asset group.\\n     */\\n    function assetGroupId() external view returns (uint256 id);\\n\\n    /**\\n     * @notice Gets underlying assets for the strategy.\\n     * @return assets Addresses of the underlying assets.\\n     */\\n    function assets() external view returns (address[] memory assets);\\n\\n    /**\\n     * @notice Gets underlying asset amounts for the strategy.\\n     * @return amounts Amounts of the underlying assets.\\n     */\\n    function getUnderlyingAssetAmounts() external view returns (uint256[] memory amounts);\\n\\n    /* ========== MUTATIVE FUNCTIONS ========== */\\n\\n    /**\\n     * @dev Performs slippages check before depositing.\\n     * @param amounts Amounts to be deposited.\\n     * @param slippages Slippages to check against.\\n     */\\n    function beforeDepositCheck(uint256[] memory amounts, uint256[] calldata slippages) external;\\n\\n    /**\\n     * @dev Performs slippages check before redeemal.\\n     * @param ssts Amount of strategy tokens to be redeemed.\\n     * @param slippages Slippages to check against.\\n     */\\n    function beforeRedeemalCheck(uint256 ssts, uint256[] calldata slippages) external;\\n\\n    /**\\n     * @notice Does hard work:\\n     * - compounds rewards\\n     * - deposits into the protocol\\n     * - withdraws from the protocol\\n     * @dev Requirements:\\n     * - caller must have role ROLE_STRATEGY_REGISTRY\\n     * @param dhwParams Parameters for the do hard work.\\n     * @return info Information about do the performed hard work.\\n     */\\n    function doHardWork(StrategyDhwParameterBag calldata dhwParams) external returns (DhwInfo memory info);\\n\\n    /**\\n     * @notice Claims strategy shares after do-hard-work.\\n     * @dev Requirements:\\n     * - caller must have role ROLE_SMART_VAULT_MANAGER\\n     * @param smartVault Smart vault claiming shares.\\n     * @param amount Amount of strategy shares to claim.\\n     */\\n    function claimShares(address smartVault, uint256 amount) external;\\n\\n    /**\\n     * @notice Releases shares back to strategy.\\n     * @dev Requirements:\\n     * - caller must have role ROLE_SMART_VAULT_MANAGER\\n     * @param smartVault Smart vault releasing shares.\\n     * @param amount Amount of strategy shares to release.\\n     */\\n    function releaseShares(address smartVault, uint256 amount) external;\\n\\n    /**\\n     * @notice Instantly redeems strategy shares for assets.\\n     * @dev Requirements:\\n     * - caller must have either role ROLE_SMART_VAULT_MANAGER or role ROLE_STRATEGY_REGISTRY\\n     * @param shares Amount of shares to redeem.\\n     * @param masterWallet Address of the master wallet.\\n     * @param assetGroup Asset group of the strategy.\\n     * @param slippages Slippages to guard redeeming.\\n     * @return assetsWithdrawn Amount of assets withdrawn.\\n     */\\n    function redeemFast(\\n        uint256 shares,\\n        address masterWallet,\\n        address[] calldata assetGroup,\\n        uint256[] calldata slippages\\n    ) external returns (uint256[] memory assetsWithdrawn);\\n\\n    /**\\n     * @notice Instantly redeems strategy shares for assets.\\n     * @param shares Amount of shares to redeem.\\n     * @param redeemer Address of he redeemer, owner of SSTs.\\n     * @param assetGroup Asset group of the strategy.\\n     * @param slippages Slippages to guard redeeming.\\n     * @return assetsWithdrawn Amount of assets withdrawn.\\n     */\\n    function redeemShares(uint256 shares, address redeemer, address[] calldata assetGroup, uint256[] calldata slippages)\\n        external\\n        returns (uint256[] memory assetsWithdrawn);\\n\\n    /**\\n     * @notice Instantly deposits into the protocol.\\n     * @dev Requirements:\\n     * - caller must have role ROLE_SMART_VAULT_MANAGER\\n     * @param assetGroup Asset group of the strategy.\\n     * @param exchangeRates Asset to USD exchange rates.\\n     * @param priceFeedManager Price feed manager contract.\\n     * @param slippages Slippages to guard depositing.\\n     * @param swapInfo Information for swapping assets before depositing into the protocol.\\n     * @return sstsMinted Amount of SSTs minted.\\n     */\\n    function depositFast(\\n        address[] calldata assetGroup,\\n        uint256[] calldata exchangeRates,\\n        IUsdPriceFeedManager priceFeedManager,\\n        uint256[] calldata slippages,\\n        SwapInfo[] calldata swapInfo\\n    ) external returns (uint256 sstsMinted);\\n\\n    /**\\n     * @notice Instantly withdraws assets, bypassing shares mechanism.\\n     * Transfers withdrawn assets to the emergency withdrawal wallet.\\n     * @dev Requirements:\\n     * - caller must have role ROLE_STRATEGY_REGISTRY\\n     * @param slippages Slippages to guard redeeming.\\n     * @param recipient Recipient address\\n     */\\n    function emergencyWithdraw(uint256[] calldata slippages, address recipient) external;\\n\\n    /**\\n     * @notice Gets USD worth of the strategy.\\n     * @dev Requirements:\\n     * - caller must have role ROLE_SMART_VAULT_MANAGER\\n     * @param exchangeRates Asset to USD exchange rates.\\n     * @param priceFeedManager Price feed manager contract.\\n     */\\n    function getUsdWorth(uint256[] memory exchangeRates, IUsdPriceFeedManager priceFeedManager)\\n        external\\n        returns (uint256 usdWorth);\\n\\n    /**\\n     * @notice Gets protocol rewards.\\n     * @dev Requirements:\\n     * - can only be called in view-execution mode.\\n     * @return tokens Addresses of reward tokens.\\n     * @return amounts Amount of reward tokens available.\\n     */\\n    function getProtocolRewards() external returns (address[] memory tokens, uint256[] memory amounts);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IStrategyRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.17;\\n\\nimport \\\"./ISwapper.sol\\\";\\nimport {DhwInfo} from \\\"./IStrategy.sol\\\";\\nimport \\\"../libraries/uint16a16Lib.sol\\\";\\n\\n/* ========== ERRORS ========== */\\n\\n/**\\n * @notice Used when trying to register an already registered strategy.\\n * @param address_ Address of already registered strategy.\\n */\\nerror StrategyAlreadyRegistered(address address_);\\n\\n/**\\n * @notice Used when DHW was not run yet for a strategy index.\\n * @param strategy Address of the strategy.\\n * @param strategyIndex Index of the strategy.\\n */\\nerror DhwNotRunYetForIndex(address strategy, uint256 strategyIndex);\\n\\n/**\\n * @notice Used when provided token list is invalid.\\n */\\nerror InvalidTokenList();\\n\\n/**\\n * @notice Used when ghost strategy is used.\\n */\\nerror GhostStrategyUsed();\\n\\n/**\\n * @notice Used when syncing vault that is already fully synced.\\n */\\nerror NothingToSync();\\n\\n/**\\n * @notice Used when system tries to configure a too large ecosystem fee.\\n * @param ecosystemFeePct Requested ecosystem fee.\\n */\\nerror EcosystemFeeTooLarge(uint256 ecosystemFeePct);\\n\\n/**\\n * @notice Used when system tries to configure a too large treasury fee.\\n * @param treasuryFeePct Requested treasury fee.\\n */\\nerror TreasuryFeeTooLarge(uint256 treasuryFeePct);\\n\\n/**\\n * @notice Used when user tries to re-add a strategy that was previously removed from the system.\\n * @param strategy Strategy address\\n */\\nerror StrategyPreviouslyRemoved(address strategy);\\n\\n/**\\n * @notice Represents change of state for a strategy during a DHW.\\n * @custom:member exchangeRates Exchange rates between assets and USD.\\n * @custom:member assetsDeposited Amount of assets deposited into the strategy.\\n * @custom:member sharesMinted Amount of strategy shares minted.\\n * @custom:member totalSSTs Amount of strategy shares at the end of the DHW.\\n * @custom:member totalStrategyValue Total strategy value at the end of the DHW.\\n * @custom:member dhwYields DHW yield percentage from the previous DHW.\\n */\\nstruct StrategyAtIndex {\\n    uint256[] exchangeRates;\\n    uint256[] assetsDeposited;\\n    uint256 sharesMinted;\\n    uint256 totalSSTs;\\n    uint256 totalStrategyValue;\\n    int256 dhwYields;\\n}\\n\\n/**\\n * @notice Parameters for calling do hard work.\\n * @custom:member strategies Strategies to do-hard-worked upon, grouped by their asset group.\\n * @custom:member swapInfo Information for swapping assets before depositing into protocol. SwapInfo[] per each strategy.\\n * @custom:member compoundSwapInfo Information for swapping rewards before depositing them back into the protocol. SwapInfo[] per each strategy.\\n * @custom:member strategySlippages Slippages used to constrain depositing into and withdrawing from the protocol. uint256[] per strategy.\\n * @custom:member baseYields Base yield percentage the strategy created in the DHW period (applicable only for some strategies).\\n * @custom:member tokens List of all asset tokens involved in the do hard work.\\n * @custom:member exchangeRateSlippages Slippages used to constrain exchange rates for asset tokens. uint256[2] for each token.\\n * @custom:member validUntil Sets the maximum timestamp the user is willing to wait to start executing 'do hard work'.\\n */\\nstruct DoHardWorkParameterBag {\\n    address[][] strategies;\\n    SwapInfo[][][] swapInfo;\\n    SwapInfo[][][] compoundSwapInfo;\\n    uint256[][][] strategySlippages;\\n    int256[][] baseYields;\\n    address[] tokens;\\n    uint256[2][] exchangeRateSlippages;\\n    uint256 validUntil;\\n}\\n\\n/**\\n * @notice Parameters for calling redeem fast.\\n * @custom:member strategies Addresses of strategies.\\n * @custom:member strategyShares Amount of shares to redeem.\\n * @custom:member assetGroup Asset group of the smart vault.\\n * @custom:member slippages Slippages to guard withdrawal.\\n */\\nstruct RedeemFastParameterBag {\\n    address[] strategies;\\n    uint256[] strategyShares;\\n    address[] assetGroup;\\n    uint256[][] withdrawalSlippages;\\n}\\n\\n/**\\n * @notice Group of platform fees.\\n * @custom:member ecosystemFeeReciever Receiver of the ecosystem fees.\\n * @custom:member ecosystemFeePct Ecosystem fees. Expressed in FULL_PERCENT.\\n * @custom:member treasuryFeeReciever Receiver of the treasury fees.\\n * @custom:member treasuryFeePct Treasury fees. Expressed in FULL_PERCENT.\\n */\\nstruct PlatformFees {\\n    address ecosystemFeeReceiver;\\n    uint96 ecosystemFeePct;\\n    address treasuryFeeReceiver;\\n    uint96 treasuryFeePct;\\n}\\n\\n/* ========== INTERFACES ========== */\\n\\ninterface IStrategyRegistry {\\n    /* ========== EXTERNAL VIEW FUNCTIONS ========== */\\n\\n    /**\\n     * @notice Returns address of emergency withdrawal wallet.\\n     * @return emergencyWithdrawalWallet Address of the emergency withdrawal wallet.\\n     */\\n    function emergencyWithdrawalWallet() external view returns (address emergencyWithdrawalWallet);\\n\\n    /**\\n     * @notice Returns current do-hard-work indexes for strategies.\\n     * @param strategies Strategies.\\n     * @return dhwIndexes Current do-hard-work indexes for strategies.\\n     */\\n    function currentIndex(address[] calldata strategies) external view returns (uint256[] memory dhwIndexes);\\n\\n    /**\\n     * @notice Returns current strategy APYs.\\n     * @param strategies Strategies.\\n     */\\n    function strategyAPYs(address[] calldata strategies) external view returns (int256[] memory apys);\\n\\n    /**\\n     * @notice Returns assets deposited into a do-hard-work index for a strategy.\\n     * @param strategy Strategy.\\n     * @param dhwIndex Do-hard-work index.\\n     * @return assets Assets deposited into the do-hard-work index for the strategy.\\n     */\\n    function depositedAssets(address strategy, uint256 dhwIndex) external view returns (uint256[] memory assets);\\n\\n    /**\\n     * @notice Returns shares redeemed in a do-hard-work index for a strategy.\\n     * @param strategy Strategy.\\n     * @param dhwIndex Do-hard-work index.\\n     * @return shares Shares redeemed in a do-hard-work index for the strategy.\\n     */\\n    function sharesRedeemed(address strategy, uint256 dhwIndex) external view returns (uint256 shares);\\n\\n    /**\\n     * @notice Gets timestamps when do-hard-works were performed.\\n     * @param strategies Strategies.\\n     * @param dhwIndexes Do-hard-work indexes.\\n     * @return timestamps Timestamp for each pair of strategies and do-hard-work indexes.\\n     */\\n    function dhwTimestamps(address[] calldata strategies, uint16a16 dhwIndexes)\\n        external\\n        view\\n        returns (uint256[] memory timestamps);\\n\\n    function getDhwYield(address[] calldata strategies, uint16a16 dhwIndexes)\\n        external\\n        view\\n        returns (int256[] memory yields);\\n\\n    /**\\n     * @notice Returns state of strategies at do-hard-work indexes.\\n     * @param strategies Strategies.\\n     * @param dhwIndexes Do-hard-work indexes.\\n     * @return states State of each strategy at corresponding do-hard-work index.\\n     */\\n    function strategyAtIndexBatch(address[] calldata strategies, uint16a16 dhwIndexes, uint256 assetGroupLength)\\n        external\\n        view\\n        returns (StrategyAtIndex[] memory states);\\n\\n    /**\\n     * @notice Gets required asset ratio for strategy at last DHW.\\n     * @param strategy Address of the strategy.\\n     * @return assetRatio Asset ratio.\\n     */\\n    function assetRatioAtLastDhw(address strategy) external view returns (uint256[] memory assetRatio);\\n\\n    /**\\n     * @notice Gets set platform fees.\\n     * @return fees Set platform fees.\\n     */\\n    function platformFees() external view returns (PlatformFees memory fees);\\n\\n    /* ========== EXTERNAL MUTATIVE FUNCTIONS ========== */\\n\\n    /**\\n     * @notice Registers a strategy into the system.\\n     * @dev Requirements:\\n     * - caller must have role ROLE_SPOOL_ADMIN\\n     * @param strategy Address of strategy to register.\\n     * @param apy Apy of the strategy at the time of the registration.\\n     */\\n    function registerStrategy(address strategy, int256 apy) external;\\n\\n    /**\\n     * @notice Removes strategy from the system.\\n     * @dev Requirements:\\n     * - caller must have role ROLE_SMART_VAULT_MANAGER\\n     * @param strategy Strategy to remove.\\n     */\\n    function removeStrategy(address strategy) external;\\n\\n    /**\\n     * @notice Sets ecosystem fee.\\n     * @dev Requirements:\\n     * - caller must have role ROLE_SPOOL_ADMIN\\n     * @param ecosystemFeePct Ecosystem fee to set. Expressed in terms of FULL_PERCENT.\\n     */\\n    function setEcosystemFee(uint96 ecosystemFeePct) external;\\n\\n    /**\\n     * @notice Sets receiver of the ecosystem fees.\\n     * @dev Requirements:\\n     * - caller must have role ROLE_SPOOL_ADMIN\\n     * @param ecosystemFeeReceiver Receiver to set.\\n     */\\n    function setEcosystemFeeReceiver(address ecosystemFeeReceiver) external;\\n\\n    /**\\n     * @notice Sets treasury fee.\\n     * @dev Requirements:\\n     * - caller must have role ROLE_SPOOL_ADMIN\\n     * @param treasuryFeePct Treasury fee to set. Expressed in terms of FULL_PERCENT.\\n     */\\n    function setTreasuryFee(uint96 treasuryFeePct) external;\\n\\n    /**\\n     * @notice Sets treasury fee receiver.\\n     * @dev Requirements:\\n     * - caller must have role ROLE_SPOOL_ADMIN\\n     * @param treasuryFeeReceiver Receiver to set.\\n     */\\n    function setTreasuryFeeReceiver(address treasuryFeeReceiver) external;\\n\\n    /**\\n     * @notice Does hard work on multiple strategies.\\n     * @dev Requirements:\\n     * - caller must have role ROLE_DO_HARD_WORKER\\n     * @param dhwParams Parameters for do hard work.\\n     */\\n    function doHardWork(DoHardWorkParameterBag calldata dhwParams) external;\\n\\n    /**\\n     * @notice Adds deposits to strategies to be processed at next do-hard-work.\\n     * @dev Requirements:\\n     * - caller must have role ROLE_SMART_VAULT_MANAGER\\n     * @param strategies Strategies to which to add deposit.\\n     * @param amounts Amounts of assets to add to each strategy.\\n     * @return strategyIndexes Current do-hard-work indexes for the strategies.\\n     */\\n    function addDeposits(address[] calldata strategies, uint256[][] calldata amounts)\\n        external\\n        returns (uint16a16 strategyIndexes);\\n\\n    /**\\n     * @notice Adds withdrawals to strategies to be processed at next do-hard-work.\\n     * @dev Requirements:\\n     * - caller must have role ROLE_SMART_VAULT_MANAGER\\n     * @param strategies Strategies to which to add withdrawal.\\n     * @param strategyShares Amounts of strategy shares to add to each strategy.\\n     * @return strategyIndexes Current do-hard-work indexes for the strategies.\\n     */\\n    function addWithdrawals(address[] calldata strategies, uint256[] calldata strategyShares)\\n        external\\n        returns (uint16a16 strategyIndexes);\\n\\n    /**\\n     * @notice Instantly redeems strategy shares for assets.\\n     * @dev Requirements:\\n     * - caller must have role ROLE_SMART_VAULT_MANAGER\\n     * @param redeemFastParams Parameters for fast redeem.\\n     * @return withdrawnAssets Amount of assets withdrawn.\\n     */\\n    function redeemFast(RedeemFastParameterBag calldata redeemFastParams)\\n        external\\n        returns (uint256[] memory withdrawnAssets);\\n\\n    /**\\n     * @notice Claims withdrawals from the strategies.\\n     * @dev Requirements:\\n     * - caller must have role ROLE_SMART_VAULT_MANAGER\\n     * - DHWs must be run for withdrawal indexes.\\n     * @param strategies Addresses if strategies from which to claim withdrawal.\\n     * @param dhwIndexes Indexes of strategies when withdrawal was made.\\n     * @param strategyShares Amount of strategy shares that was withdrawn.\\n     * @return assetsWithdrawn Amount of assets withdrawn from strategies.\\n     */\\n    function claimWithdrawals(address[] calldata strategies, uint16a16 dhwIndexes, uint256[] calldata strategyShares)\\n        external\\n        returns (uint256[] memory assetsWithdrawn);\\n\\n    /**\\n     * @notice Redeems strategy shares.\\n     * Used by recipients of platform fees.\\n     * @param strategies Strategies from which to redeem.\\n     * @param shares Amount of shares to redeem from each strategy.\\n     * @param withdrawalSlippages Slippages to guard redeemal process.\\n     */\\n    function redeemStrategyShares(\\n        address[] calldata strategies,\\n        uint256[] calldata shares,\\n        uint256[][] calldata withdrawalSlippages\\n    ) external;\\n\\n    /**\\n     * @notice Strategy was registered\\n     * @param strategy Strategy address\\n     */\\n    event StrategyRegistered(address indexed strategy);\\n\\n    /**\\n     * @notice Strategy was removed\\n     * @param strategy Strategy address\\n     */\\n    event StrategyRemoved(address indexed strategy);\\n\\n    /**\\n     * @notice Strategy DHW was executed\\n     * @param strategy Strategy address\\n     * @param dhwIndex DHW index\\n     * @param dhwInfo DHW info\\n     */\\n    event StrategyDhw(address indexed strategy, uint256 dhwIndex, DhwInfo dhwInfo);\\n\\n    /**\\n     * @notice Ecosystem fee configuration was changed\\n     * @param feePct Fee percentage value\\n     */\\n    event EcosystemFeeSet(uint256 feePct);\\n\\n    /**\\n     * @notice Ecosystem fee receiver was changed\\n     * @param ecosystemFeeReceiver Receiver address\\n     */\\n    event EcosystemFeeReceiverSet(address indexed ecosystemFeeReceiver);\\n\\n    /**\\n     * @notice Treasury fee configuration was changed\\n     * @param feePct Fee percentage value\\n     */\\n    event TreasuryFeeSet(uint256 feePct);\\n\\n    /**\\n     * @notice Treasury fee receiver was changed\\n     * @param treasuryFeeReceiver Receiver address\\n     */\\n    event TreasuryFeeReceiverSet(address indexed treasuryFeeReceiver);\\n\\n    /**\\n     * @notice Emergency withdrawal wallet changed\\n     * @param wallet Emergency withdrawal wallet address\\n     */\\n    event EmergencyWithdrawalWalletSet(address indexed wallet);\\n\\n    /**\\n     * @notice Strategy shares have been redeemed\\n     * @param strategy Strategy address\\n     * @param owner Address that owns the shares\\n     * @param recipient Address that received the withdrawn funds\\n     * @param shares Amount of shares that were redeemed\\n     * @param assetsWithdrawn Amounts of withdrawn assets\\n     */\\n    event StrategySharesRedeemed(\\n        address indexed strategy,\\n        address indexed owner,\\n        address indexed recipient,\\n        uint256 shares,\\n        uint256[] assetsWithdrawn\\n    );\\n\\n    /**\\n     * @notice Strategy shares were fast redeemed\\n     * @param strategy Strategy address\\n     * @param shares Amount of shares redeemed\\n     * @param assetsWithdrawn Amounts of withdrawn assets\\n     */\\n    event StrategySharesFastRedeemed(address indexed strategy, uint256 shares, uint256[] assetsWithdrawn);\\n\\n    /**\\n     * @notice Strategy APY value was updated\\n     * @param strategy Strategy address\\n     * @param apy New APY value\\n     */\\n    event StrategyApyUpdated(address indexed strategy, int256 apy);\\n}\\n\\ninterface IEmergencyWithdrawal {\\n    /**\\n     * @notice Emitted when a strategy is emergency withdrawn from.\\n     * @param strategy Strategy that was emergency withdrawn from.\\n     */\\n    event StrategyEmergencyWithdrawn(address indexed strategy);\\n\\n    /**\\n     * @notice Set a new address that will receive assets withdrawn if emergency withdrawal is executed.\\n     * @dev Requirements:\\n     * - caller must have role ROLE_SPOOL_ADMIN\\n     * @param wallet Address to set as the emergency withdrawal wallet.\\n     */\\n    function setEmergencyWithdrawalWallet(address wallet) external;\\n\\n    /**\\n     * @notice Instantly withdraws assets from a strategy, bypassing shares mechanism.\\n     * @dev Requirements:\\n     * - caller must have role ROLE_EMERGENCY_WITHDRAWAL_EXECUTOR\\n     * @param strategies Addresses of strategies.\\n     * @param withdrawalSlippages Slippages to guard withdrawal.\\n     * @param removeStrategies Whether to remove strategies from the system after withdrawal.\\n     */\\n    function emergencyWithdraw(\\n        address[] calldata strategies,\\n        uint256[][] calldata withdrawalSlippages,\\n        bool removeStrategies\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/CommonErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.17;\\n\\n/**\\n * @notice Used when an array has invalid length.\\n */\\nerror InvalidArrayLength();\\n\\n/**\\n * @notice Used when group of smart vaults or strategies do not have same asset group.\\n */\\nerror NotSameAssetGroup();\\n\\n/**\\n * @notice Used when configuring an address with a zero address.\\n */\\nerror ConfigurationAddressZero();\\n\\n/**\\n * @notice Used when constructor or intializer parameters are invalid.\\n */\\nerror InvalidConfiguration();\\n\\n/**\\n * @notice Used when fetched exchange rate is out of slippage range.\\n */\\nerror ExchangeRateOutOfSlippages();\\n\\n/**\\n * @notice Used when an invalid strategy is provided.\\n * @param address_ Address of the invalid strategy.\\n */\\nerror InvalidStrategy(address address_);\\n\\n/**\\n * @notice Used when doing low-level call on an address that is not a contract.\\n * @param address_ Address of the contract\\n */\\nerror AddressNotContract(address address_);\\n\\n/**\\n * @notice Used when invoking an only view execution and tx.origin is not address zero.\\n * @param address_ Address of the tx.origin\\n */\\nerror OnlyViewExecution(address address_);\\n\"\r\n    },\r\n    \"src/access/SpoolAccessControllable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.17;\\n\\nimport \\\"../interfaces/ISpoolAccessControl.sol\\\";\\nimport \\\"../interfaces/CommonErrors.sol\\\";\\nimport \\\"./Roles.sol\\\";\\n\\n/**\\n * @notice Account access role verification middleware\\n */\\nabstract contract SpoolAccessControllable {\\n    /* ========== CONSTANTS ========== */\\n\\n    /**\\n     * @dev Spool access control manager.\\n     */\\n    ISpoolAccessControl internal immutable _accessControl;\\n\\n    /* ========== CONSTRUCTOR ========== */\\n\\n    /**\\n     * @param accessControl_ Spool access control manager.\\n     */\\n    constructor(ISpoolAccessControl accessControl_) {\\n        if (address(accessControl_) == address(0)) revert ConfigurationAddressZero();\\n\\n        _accessControl = accessControl_;\\n    }\\n\\n    /* ========== INTERNAL FUNCTIONS ========== */\\n\\n    /**\\n     * @dev Reverts if an account is missing a role.\\\\\\n     * @param role Role to check for.\\n     * @param account Account to check.\\n     */\\n    function _checkRole(bytes32 role, address account) internal view virtual {\\n        if (!_accessControl.hasRole(role, account)) {\\n            revert MissingRole(role, account);\\n        }\\n    }\\n\\n    /**\\n     * @dev Revert if an account is missing a role for a smartVault.\\n     * @param smartVault Address of the smart vault.\\n     * @param role Role to check for.\\n     * @param account Account to check.\\n     */\\n    function _checkSmartVaultRole(address smartVault, bytes32 role, address account) internal view {\\n        if (!_accessControl.hasSmartVaultRole(smartVault, role, account)) {\\n            revert MissingRole(role, account);\\n        }\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is paused.\\n     */\\n    function _requireNotPaused() internal view virtual {\\n        if (_accessControl.paused()) {\\n            revert SystemPaused();\\n        }\\n    }\\n\\n    function _checkNonReentrant() internal view {\\n        _accessControl.checkNonReentrant();\\n    }\\n\\n    function _nonReentrantBefore() internal {\\n        _accessControl.nonReentrantBefore();\\n    }\\n\\n    function _nonReentrantAfter() internal {\\n        _accessControl.nonReentrantAfter();\\n    }\\n\\n    /* ========== MODIFIERS ========== */\\n\\n    /**\\n     * @notice Only allows accounts with granted role.\\n     * @dev Reverts when the account fails check.\\n     * @param role Role to check for.\\n     * @param account Account to check.\\n     */\\n    modifier onlyRole(bytes32 role, address account) {\\n        _checkRole(role, account);\\n        _;\\n    }\\n\\n    /**\\n     * @notice Only allows accounts with granted role for a smart vault.\\n     * @dev Reverts when the account fails check.\\n     * @param smartVault Address of the smart vault.\\n     * @param role Role to check for.\\n     * @param account Account to check.\\n     */\\n    modifier onlySmartVaultRole(address smartVault, bytes32 role, address account) {\\n        _checkSmartVaultRole(smartVault, role, account);\\n        _;\\n    }\\n\\n    /**\\n     * @notice Only allows accounts that are Spool admins or admins of a smart vault.\\n     * @dev Reverts when the account fails check.\\n     * @param smartVault Address of the smart vault.\\n     * @param account Account to check.\\n     */\\n    modifier onlyAdminOrVaultAdmin(address smartVault, address account) {\\n        _accessControl.checkIsAdminOrVaultAdmin(smartVault, account);\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        _requireNotPaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, or other contracts using this modifier.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    /**\\n     * @dev Check if a system has already entered in the non-reentrant state.\\n     */\\n    modifier checkNonReentrant() {\\n        _checkNonReentrant();\\n        _;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\r\\n */\\r\\ninterface IERC20Upgradeable {\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address to, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender's allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller's\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"../IERC20Upgradeable.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\r\\n *\\r\\n * _Available since v4.1._\\r\\n */\\r\\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\\r\\n    /**\\r\\n     * @dev Returns the name of the token.\\r\\n     */\\r\\n    function name() external view returns (string memory);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the symbol of the token.\\r\\n     */\\r\\n    function symbol() external view returns (string memory);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the decimals places of the token.\\r\\n     */\\r\\n    function decimals() external view returns (uint8);\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/utils/ContextUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Provides information about the current execution context, including the\\r\\n * sender of the transaction and its data. While these are generally available\\r\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\r\\n * manner, since when dealing with meta-transactions the account sending and\\r\\n * paying for execution may not be the actual sender (as far as an application\\r\\n * is concerned).\\r\\n *\\r\\n * This contract is only required for intermediate, library-like contracts.\\r\\n */\\r\\nabstract contract ContextUpgradeable is Initializable {\\r\\n    function __Context_init() internal onlyInitializing {\\r\\n    }\\r\\n\\r\\n    function __Context_init_unchained() internal onlyInitializing {\\r\\n    }\\r\\n    function _msgSender() internal view virtual returns (address) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view virtual returns (bytes calldata) {\\r\\n        return msg.data;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\r\\n     * variables without shifting down storage in the inheritance chain.\\r\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\r\\n     */\\r\\n    uint256[50] private __gap;\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\\r\\n\\r\\npragma solidity ^0.8.2;\\r\\n\\r\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\r\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\r\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\r\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\r\\n *\\r\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\r\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\r\\n * case an upgrade adds a module that needs to be initialized.\\r\\n *\\r\\n * For example:\\r\\n *\\r\\n * [.hljs-theme-light.nopadding]\\r\\n * ```\\r\\n * contract MyToken is ERC20Upgradeable {\\r\\n *     function initialize() initializer public {\\r\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\r\\n *     }\\r\\n * }\\r\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\r\\n *     function initializeV2() reinitializer(2) public {\\r\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\r\\n *     }\\r\\n * }\\r\\n * ```\\r\\n *\\r\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\r\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\r\\n *\\r\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\r\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\r\\n *\\r\\n * [CAUTION]\\r\\n * ====\\r\\n * Avoid leaving a contract uninitialized.\\r\\n *\\r\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\r\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\r\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\r\\n *\\r\\n * [.hljs-theme-light.nopadding]\\r\\n * ```\\r\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\r\\n * constructor() {\\r\\n *     _disableInitializers();\\r\\n * }\\r\\n * ```\\r\\n * ====\\r\\n */\\r\\nabstract contract Initializable {\\r\\n    /**\\r\\n     * @dev Indicates that the contract has been initialized.\\r\\n     * @custom:oz-retyped-from bool\\r\\n     */\\r\\n    uint8 private _initialized;\\r\\n\\r\\n    /**\\r\\n     * @dev Indicates that the contract is in the process of being initialized.\\r\\n     */\\r\\n    bool private _initializing;\\r\\n\\r\\n    /**\\r\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\r\\n     */\\r\\n    event Initialized(uint8 version);\\r\\n\\r\\n    /**\\r\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\r\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\r\\n     *\\r\\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\\r\\n     * constructor.\\r\\n     *\\r\\n     * Emits an {Initialized} event.\\r\\n     */\\r\\n    modifier initializer() {\\r\\n        bool isTopLevelCall = !_initializing;\\r\\n        require(\\r\\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\\r\\n            \\\"Initializable: contract is already initialized\\\"\\r\\n        );\\r\\n        _initialized = 1;\\r\\n        if (isTopLevelCall) {\\r\\n            _initializing = true;\\r\\n        }\\r\\n        _;\\r\\n        if (isTopLevelCall) {\\r\\n            _initializing = false;\\r\\n            emit Initialized(1);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\r\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\r\\n     * used to initialize parent contracts.\\r\\n     *\\r\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\r\\n     * are added through upgrades and that require initialization.\\r\\n     *\\r\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\r\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\r\\n     *\\r\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\r\\n     * a contract, executing them in the right order is up to the developer or operator.\\r\\n     *\\r\\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\\r\\n     *\\r\\n     * Emits an {Initialized} event.\\r\\n     */\\r\\n    modifier reinitializer(uint8 version) {\\r\\n        require(!_initializing && _initialized < version, \\\"Initializable: contract is already initialized\\\");\\r\\n        _initialized = version;\\r\\n        _initializing = true;\\r\\n        _;\\r\\n        _initializing = false;\\r\\n        emit Initialized(version);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\r\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\r\\n     */\\r\\n    modifier onlyInitializing() {\\r\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\r\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\r\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\r\\n     * through proxies.\\r\\n     *\\r\\n     * Emits an {Initialized} event the first time it is successfully executed.\\r\\n     */\\r\\n    function _disableInitializers() internal virtual {\\r\\n        require(!_initializing, \\\"Initializable: contract is initializing\\\");\\r\\n        if (_initialized != type(uint8).max) {\\r\\n            _initialized = type(uint8).max;\\r\\n            emit Initialized(type(uint8).max);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function that returns the initialized version. Returns `_initialized`\\r\\n     */\\r\\n    function _getInitializedVersion() internal view returns (uint8) {\\r\\n        return _initialized;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function that returns the initialized version. Returns `_initializing`\\r\\n     */\\r\\n    function _isInitializing() internal view returns (bool) {\\r\\n        return _initializing;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"src/interfaces/ISwapper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.17;\\n\\n/* ========== STRUCTS ========== */\\n\\n/**\\n * @notice Information needed to make a swap of assets.\\n * @custom:member swapTarget Contract executing the swap.\\n * @custom:member token Token to be swapped.\\n * @custom:member swapCallData Calldata describing the swap itself.\\n */\\nstruct SwapInfo {\\n    address swapTarget;\\n    address token;\\n    bytes swapCallData;\\n}\\n\\n/* ========== ERRORS ========== */\\n\\n/**\\n * @notice Used when trying to do a swap via an exchange that is not allowed to execute a swap.\\n * @param exchange Exchange used.\\n */\\nerror ExchangeNotAllowed(address exchange);\\n\\n/**\\n * @notice Used when trying to execute a swap but are not authorized.\\n * @param caller Caller of the swap method.\\n */\\nerror NotSwapper(address caller);\\n\\n/* ========== INTERFACES ========== */\\n\\ninterface ISwapper {\\n    /* ========== EVENTS ========== */\\n\\n    /**\\n     * @notice Emitted when the exchange allowlist is updated.\\n     * @param exchange Exchange that was updated.\\n     * @param isAllowed Whether the exchange is allowed to be used in a swap or not after the update.\\n     */\\n    event ExchangeAllowlistUpdated(address indexed exchange, bool isAllowed);\\n\\n    event Swapped(\\n        address indexed receiver, address[] tokensIn, address[] tokensOut, uint256[] amountsIn, uint256[] amountsOut\\n    );\\n\\n    /* ========== EXTERNAL MUTATIVE FUNCTIONS ========== */\\n\\n    /**\\n     * @notice Performs a swap of tokens with external contracts.\\n     * - deposit tokens into the swapper contract\\n     * - swapper will swap tokens based on swap info provided\\n     * - swapper will return unswapped tokens to the receiver\\n     * @param tokensIn Addresses of tokens available for the swap.\\n     * @param swapInfo Information needed to perform the swap.\\n     * @param tokensOut Addresses of tokens to swap to.\\n     * @param receiver Receiver of unswapped tokens.\\n     * @return amountsOut Amounts of `tokensOut` sent from the swapper to the receiver.\\n     */\\n    function swap(\\n        address[] calldata tokensIn,\\n        SwapInfo[] calldata swapInfo,\\n        address[] calldata tokensOut,\\n        address receiver\\n    ) external returns (uint256[] memory amountsOut);\\n\\n    /**\\n     * @notice Updates list of exchanges that can be used in a swap.\\n     * @dev Requirements:\\n     *   - can only be called by user granted ROLE_SPOOL_ADMIN\\n     *   - exchanges and allowed arrays need to be of same length\\n     * @param exchanges Addresses of exchanges.\\n     * @param allowed Whether an exchange is allowed to be used in a swap.\\n     */\\n    function updateExchangeAllowlist(address[] calldata exchanges, bool[] calldata allowed) external;\\n\\n    /* ========== EXTERNAL VIEW FUNCTIONS ========== */\\n\\n    /**\\n     * @notice Checks if an exchange is allowed to be used in a swap.\\n     * @param exchange Exchange to check.\\n     * @return isAllowed True if the exchange is allowed to be used in a swap, false otherwise.\\n     */\\n    function isExchangeAllowed(address exchange) external view returns (bool isAllowed);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IUsdPriceFeedManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.17;\\n\\n/// @dev Number of decimals used for USD values.\\nuint256 constant USD_DECIMALS = 18;\\n\\n/**\\n * @notice Emitted when asset is invalid.\\n * @param asset Invalid asset.\\n */\\nerror InvalidAsset(address asset);\\n\\n/**\\n * @notice Emitted when price returned by price aggregator is negative or zero.\\n * @param price Actual price returned by price aggregator.\\n */\\nerror NonPositivePrice(int256 price);\\n\\n/**\\n * @notice Emitted when pricing data returned by price aggregator is not from the current\\n * round or the round hasn't finished.\\n */\\nerror StalePriceData();\\n\\ninterface IUsdPriceFeedManager {\\n    /**\\n     * @notice Gets number of decimals for an asset.\\n     * @param asset Address of the asset.\\n     * @return assetDecimals Number of decimals for the asset.\\n     */\\n    function assetDecimals(address asset) external view returns (uint256 assetDecimals);\\n\\n    /**\\n     * @notice Gets number of decimals for USD.\\n     * @return usdDecimals Number of decimals for USD.\\n     */\\n    function usdDecimals() external view returns (uint256 usdDecimals);\\n\\n    /**\\n     * @notice Calculates asset value in USD using current price.\\n     * @param asset Address of asset.\\n     * @param assetAmount Amount of asset in asset decimals.\\n     * @return usdValue Value in USD in USD decimals.\\n     */\\n    function assetToUsd(address asset, uint256 assetAmount) external view returns (uint256 usdValue);\\n\\n    /**\\n     * @notice Calculates USD value in asset using current price.\\n     * @param asset Address of asset.\\n     * @param usdAmount Amount of USD in USD decimals.\\n     * @return assetValue Value in asset in asset decimals.\\n     */\\n    function usdToAsset(address asset, uint256 usdAmount) external view returns (uint256 assetValue);\\n\\n    /**\\n     * @notice Calculates asset value in USD using provided price.\\n     * @param asset Address of asset.\\n     * @param assetAmount Amount of asset in asset decimals.\\n     * @param price Price of asset in USD.\\n     * @return usdValue Value in USD in USD decimals.\\n     */\\n    function assetToUsdCustomPrice(address asset, uint256 assetAmount, uint256 price)\\n        external\\n        view\\n        returns (uint256 usdValue);\\n\\n    /**\\n     * @notice Calculates assets value in USD using provided prices.\\n     * @param assets Addresses of assets.\\n     * @param assetAmounts Amounts of assets in asset decimals.\\n     * @param prices Prices of asset in USD.\\n     * @return usdValue Value in USD in USD decimals.\\n     */\\n    function assetToUsdCustomPriceBulk(\\n        address[] calldata assets,\\n        uint256[] calldata assetAmounts,\\n        uint256[] calldata prices\\n    ) external view returns (uint256 usdValue);\\n\\n    /**\\n     * @notice Calculates USD value in asset using provided price.\\n     * @param asset Address of asset.\\n     * @param usdAmount Amount of USD in USD decimals.\\n     * @param price Price of asset in USD.\\n     * @return assetValue Value in asset in asset decimals.\\n     */\\n    function usdToAssetCustomPrice(address asset, uint256 usdAmount, uint256 price)\\n        external\\n        view\\n        returns (uint256 assetValue);\\n}\\n\"\r\n    },\r\n    \"src/libraries/uint16a16Lib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\ntype uint16a16 is uint256;\\n\\n/**\\n * @notice This library enables packing of sixteen uint16 elements into one uint256 word.\\n */\\nlibrary uint16a16Lib {\\n    /// @notice Number of bits per stored element.\\n    uint256 constant bits = 16;\\n\\n    /// @notice Maximal number of elements stored.\\n    uint256 constant elements = 16;\\n\\n    // must ensure that bits * elements <= 256\\n\\n    /// @notice Range covered by stored element.\\n    uint256 constant range = 1 << bits;\\n\\n    /// @notice Maximal value of stored element.\\n    uint256 constant max = range - 1;\\n\\n    /**\\n     * @notice Gets element from packed array.\\n     * @param va Packed array.\\n     * @param index Index of element to get.\\n     * @return element Element of va stored in index index.\\n     */\\n    function get(uint16a16 va, uint256 index) internal pure returns (uint256) {\\n        require(index < elements);\\n        return (uint16a16.unwrap(va) >> (bits * index)) & max;\\n    }\\n\\n    /**\\n     * @notice Sets element to packed array.\\n     * @param va Packed array.\\n     * @param index Index under which to store the element\\n     * @param ev Element to store.\\n     * @return va Packed array with stored element.\\n     */\\n    function set(uint16a16 va, uint256 index, uint256 ev) internal pure returns (uint16a16) {\\n        require(index < elements);\\n        require(ev < range);\\n        index *= bits;\\n        return uint16a16.wrap((uint16a16.unwrap(va) & ~(max << index)) | (ev << index));\\n    }\\n\\n    /**\\n     * @notice Sets elements to packed array.\\n     * Elements are stored continuously from index 0 onwards.\\n     * @param va Packed array.\\n     * @param ev Elements to store.\\n     * @return va Packed array with stored elements.\\n     */\\n    function set(uint16a16 va, uint256[] memory ev) internal pure returns (uint16a16) {\\n        for (uint256 i; i < ev.length; ++i) {\\n            va = set(va, i, ev[i]);\\n        }\\n\\n        return va;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ISpoolAccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.17;\\n\\nimport \\\"@openzeppelin-upgradeable/access/IAccessControlUpgradeable.sol\\\";\\n\\n/**\\n * @notice Used when an account is missing a required role.\\n * @param role Required role.\\n * @param account Account missing the required role.\\n */\\nerror MissingRole(bytes32 role, address account);\\n\\n/**\\n * @notice Used when interacting with Spool when the system is paused.\\n */\\nerror SystemPaused();\\n\\n/**\\n * @notice Used when setting smart vault owner\\n */\\nerror SmartVaultOwnerAlreadySet(address smartVault);\\n\\n/**\\n * @notice Used when a contract tries to enter in a non-reentrant state.\\n */\\nerror ReentrantCall();\\n\\n/**\\n * @notice Used when a contract tries to call in a non-reentrant function and doesn't have the correct role.\\n */\\nerror NoReentrantRole();\\n\\ninterface ISpoolAccessControl is IAccessControlUpgradeable {\\n    /* ========== VIEW FUNCTIONS ========== */\\n\\n    /**\\n     * @notice Gets owner of a smart vault.\\n     * @param smartVault Smart vault.\\n     * @return owner Owner of the smart vault.\\n     */\\n    function smartVaultOwner(address smartVault) external view returns (address owner);\\n\\n    /**\\n     * @notice Looks if an account has a role for a smart vault.\\n     * @param smartVault Address of the smart vault.\\n     * @param role Role to look for.\\n     * @param account Account to check.\\n     * @return hasRole True if account has the role for the smart vault, false otherwise.\\n     */\\n    function hasSmartVaultRole(address smartVault, bytes32 role, address account)\\n        external\\n        view\\n        returns (bool hasRole);\\n\\n    /**\\n     * @notice Checks if an account is either Spool admin or admin for a smart vault.\\n     * @dev The function reverts if account is neither.\\n     * @param smartVault Address of the smart vault.\\n     * @param account to check.\\n     */\\n    function checkIsAdminOrVaultAdmin(address smartVault, address account) external view;\\n\\n    /**\\n     * @notice Checks if system is paused or not.\\n     * @return isPaused True if system is paused, false otherwise.\\n     */\\n    function paused() external view returns (bool isPaused);\\n\\n    /* ========== MUTATIVE FUNCTIONS ========== */\\n\\n    /**\\n     * @notice Pauses the whole system.\\n     * @dev Requirements:\\n     * - caller must have role ROLE_PAUSER\\n     */\\n    function pause() external;\\n\\n    /**\\n     * @notice Unpauses the whole system.\\n     * @dev Requirements:\\n     * - caller must have role ROLE_UNPAUSER\\n     */\\n    function unpause() external;\\n\\n    /**\\n     * @notice Grants role to an account for a smart vault.\\n     * @dev Requirements:\\n     * - caller must have either role ROLE_SPOOL_ADMIN or role ROLE_SMART_VAULT_ADMIN for the smart vault\\n     * @param smartVault Address of the smart vault.\\n     * @param role Role to grant.\\n     * @param account Account to grant the role to.\\n     */\\n    function grantSmartVaultRole(address smartVault, bytes32 role, address account) external;\\n\\n    /**\\n     * @notice Revokes role from an account for a smart vault.\\n     * @dev Requirements:\\n     * - caller must have either role ROLE_SPOOL_ADMIN or role ROLE_SMART_VAULT_ADMIN for the smart vault\\n     * @param smartVault Address of the smart vault.\\n     * @param role Role to revoke.\\n     * @param account Account to revoke the role from.\\n     */\\n    function revokeSmartVaultRole(address smartVault, bytes32 role, address account) external;\\n\\n    /**\\n     * @notice Renounce role for a smart vault.\\n     * @param smartVault Address of the smart vault.\\n     * @param role Role to renounce.\\n     */\\n    function renounceSmartVaultRole(address smartVault, bytes32 role) external;\\n\\n    /**\\n     * @notice Grant ownership to smart vault and assigns admin role.\\n     * @dev Ownership can only be granted once and it should be done at vault creation time.\\n     * @param smartVault Address of the smart vault.\\n     * @param owner address to which grant ownership to\\n     */\\n    function grantSmartVaultOwnership(address smartVault, address owner) external;\\n\\n    /**\\n     * @notice Checks and reverts if a system has already entered in the non-reentrant state.\\n     */\\n    function checkNonReentrant() external view;\\n\\n    /**\\n     * @notice Sets the entered flag to true when entering for the first time.\\n     * @dev Reverts if a system has already entered before.\\n     */\\n    function nonReentrantBefore() external;\\n\\n    /**\\n     * @notice Resets the entered flag after the call is finished.\\n     */\\n    function nonReentrantAfter() external;\\n\\n    /**\\n     * @notice Emitted when ownership of a smart vault is granted to an address\\n     * @param smartVault Smart vault address\\n     * @param address_ Address of the new smart vault owner\\n     */\\n    event SmartVaultOwnershipGranted(address indexed smartVault, address indexed address_);\\n\\n    /**\\n     * @notice Smart vault specific role was granted\\n     * @param smartVault Smart vault address\\n     * @param role Role ID\\n     * @param account Account to which the role was granted\\n     */\\n    event SmartVaultRoleGranted(address indexed smartVault, bytes32 indexed role, address indexed account);\\n\\n    /**\\n     * @notice Smart vault specific role was revoked\\n     * @param smartVault Smart vault address\\n     * @param role Role ID\\n     * @param account Account for which the role was revoked\\n     */\\n    event SmartVaultRoleRevoked(address indexed smartVault, bytes32 indexed role, address indexed account);\\n\\n    /**\\n     * @notice Smart vault specific role was renounced\\n     * @param smartVault Smart vault address\\n     * @param role Role ID\\n     * @param account Account that renounced the role\\n     */\\n    event SmartVaultRoleRenounced(address indexed smartVault, bytes32 indexed role, address indexed account);\\n}\\n\"\r\n    },\r\n    \"src/access/Roles.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.17;\\n\\n/**\\n * @dev Grants permission to:\\n * - acts as a default admin for other roles,\\n * - can whitelist an action with action manager,\\n * - can manage asset group registry.\\n *\\n * Is granted to the deployer of the SpoolAccessControl contract.\\n *\\n * Equals to the DEFAULT_ADMIN_ROLE of the OpenZeppelin AccessControl.\\n */\\nbytes32 constant ROLE_SPOOL_ADMIN = 0x00;\\n\\n/**\\n * @dev Grants permission to integrate a new smart vault into the Spool ecosystem.\\n *\\n * Should be granted to smart vault factory contracts.\\n */\\nbytes32 constant ROLE_SMART_VAULT_INTEGRATOR = keccak256(\\\"SMART_VAULT_INTEGRATOR\\\");\\n\\n/**\\n * @dev Grants permission to\\n * - manage rewards on smart vaults,\\n * - manage roles on smart vaults,\\n * - redeem for another user of a smart vault.\\n */\\nbytes32 constant ROLE_SMART_VAULT_ADMIN = keccak256(\\\"SMART_VAULT_ADMIN\\\");\\n\\n/**\\n * @dev Grants permission to manage allowlists with AllowlistGuard for a smart vault.\\n *\\n * Should be granted to whoever is in charge of maintaining allowlists with AllowlistGuard for a smart vault.\\n */\\nbytes32 constant ROLE_GUARD_ALLOWLIST_MANAGER = keccak256(\\\"GUARD_ALLOWLIST_MANAGER\\\");\\n\\n/**\\n * @dev Grants permission to manage assets on master wallet.\\n *\\n * Should be granted to:\\n * - the SmartVaultManager contract,\\n * - the StrategyRegistry contract,\\n * - the DepositManager contract,\\n * - the WithdrawalManager contract.\\n */\\nbytes32 constant ROLE_MASTER_WALLET_MANAGER = keccak256(\\\"MASTER_WALLET_MANAGER\\\");\\n\\n/**\\n * @dev Marks a contract as a smart vault manager.\\n *\\n * Should be granted to:\\n * - the SmartVaultManager contract,\\n * - the DepositManager contract.\\n */\\nbytes32 constant ROLE_SMART_VAULT_MANAGER = keccak256(\\\"SMART_VAULT_MANAGER\\\");\\n\\n/**\\n * @dev Marks a contract as a strategy registry.\\n *\\n * Should be granted to the StrategyRegistry contract.\\n */\\nbytes32 constant ROLE_STRATEGY_REGISTRY = keccak256(\\\"STRATEGY_REGISTRY\\\");\\n\\n/**\\n * @dev Grants permission to act as a risk provider.\\n *\\n * Should be granted to whoever is allowed to provide risk scores.\\n */\\nbytes32 constant ROLE_RISK_PROVIDER = keccak256(\\\"RISK_PROVIDER\\\");\\n\\n/**\\n * @dev Grants permission to act as an allocation provider.\\n *\\n * Should be granted to contracts that are allowed to calculate allocations.\\n */\\nbytes32 constant ROLE_ALLOCATION_PROVIDER = keccak256(\\\"ALLOCATION_PROVIDER\\\");\\n\\n/**\\n * @dev Grants permission to pause the system.\\n */\\nbytes32 constant ROLE_PAUSER = keccak256(\\\"SYSTEM_PAUSER\\\");\\n\\n/**\\n * @dev Grants permission to unpause the system.\\n */\\nbytes32 constant ROLE_UNPAUSER = keccak256(\\\"SYSTEM_UNPAUSER\\\");\\n\\n/**\\n * @dev Grants permission to manage rewards payment pool.\\n */\\nbytes32 constant ROLE_REWARD_POOL_ADMIN = keccak256(\\\"REWARD_POOL_ADMIN\\\");\\n\\n/**\\n * @dev Grants permission to reallocate smart vaults.\\n */\\nbytes32 constant ROLE_REALLOCATOR = keccak256(\\\"REALLOCATOR\\\");\\n\\n/**\\n * @dev Grants permission to be used as a strategy.\\n */\\nbytes32 constant ROLE_STRATEGY = keccak256(\\\"STRATEGY\\\");\\n\\n/**\\n * @dev Grants permission to manually set strategy apy.\\n */\\nbytes32 constant ROLE_STRATEGY_APY_SETTER = keccak256(\\\"STRATEGY_APY_SETTER\\\");\\n\\n/**\\n * @dev Grants permission to manage role ROLE_STRATEGY.\\n */\\nbytes32 constant ADMIN_ROLE_STRATEGY = keccak256(\\\"ADMIN_STRATEGY\\\");\\n\\n/**\\n * @dev Grants permission vault admins to allow redeem on behalf of other users.\\n */\\nbytes32 constant ROLE_SMART_VAULT_ALLOW_REDEEM = keccak256(\\\"SMART_VAULT_ALLOW_REDEEM\\\");\\n\\n/**\\n * @dev Grants permission to manage role ROLE_SMART_VAULT_ALLOW_REDEEM.\\n */\\nbytes32 constant ADMIN_ROLE_SMART_VAULT_ALLOW_REDEEM = keccak256(\\\"ADMIN_SMART_VAULT_ALLOW_REDEEM\\\");\\n\\n/**\\n * @dev Grants permission to run do hard work.\\n */\\nbytes32 constant ROLE_DO_HARD_WORKER = keccak256(\\\"DO_HARD_WORKER\\\");\\n\\n/**\\n * @dev Grants permission to immediately withdraw assets in case of emergency.\\n */\\nbytes32 constant ROLE_EMERGENCY_WITHDRAWAL_EXECUTOR = keccak256(\\\"EMERGENCY_WITHDRAWAL_EXECUTOR\\\");\\n\\n/**\\n * @dev Grants permission to swap with swapper.\\n *\\n * Should be granted to the DepositSwap contract.\\n */\\nbytes32 constant ROLE_SWAPPER = keccak256(\\\"SWAPPER\\\");\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/utils/AddressUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\\r\\n\\r\\npragma solidity ^0.8.1;\\r\\n\\r\\n/**\\r\\n * @dev Collection of functions related to the address type\\r\\n */\\r\\nlibrary AddressUpgradeable {\\r\\n    /**\\r\\n     * @dev Returns true if `account` is a contract.\\r\\n     *\\r\\n     * [IMPORTANT]\\r\\n     * ====\\r\\n     * It is unsafe to assume that an address for which this function returns\\r\\n     * false is an externally-owned account (EOA) and not a contract.\\r\\n     *\\r\\n     * Among others, `isContract` will return false for the following\\r\\n     * types of addresses:\\r\\n     *\\r\\n     *  - an externally-owned account\\r\\n     *  - a contract in construction\\r\\n     *  - an address where a contract will be created\\r\\n     *  - an address where a contract lived, but was destroyed\\r\\n     * ====\\r\\n     *\\r\\n     * [IMPORTANT]\\r\\n     * ====\\r\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\r\\n     *\\r\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\r\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\r\\n     * constructor.\\r\\n     * ====\\r\\n     */\\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n        // This method relies on extcodesize/address.code.length, which returns 0\\r\\n        // for contracts in construction, since the code is only stored at the end\\r\\n        // of the constructor execution.\\r\\n\\r\\n        return account.code.length > 0;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\r\\n     * `recipient`, forwarding all available gas and reverting on errors.\\r\\n     *\\r\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\r\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\r\\n     * imposed by `transfer`, making them unable to receive funds via\\r\\n     * `transfer`. {sendValue} removes this limitation.\\r\\n     *\\r\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\r\\n     *\\r\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\r\\n     * taken to not create reentrancy vulnerabilities. Consider using\\r\\n     * {ReentrancyGuard} or the\\r\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\r\\n     */\\r\\n    function sendValue(address payable recipient, uint256 amount) internal {\\r\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\r\\n\\r\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\r\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Performs a Solidity function call using a low level `call`. A\\r\\n     * plain `call` is an unsafe replacement for a function call: use this\\r\\n     * function instead.\\r\\n     *\\r\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\r\\n     * function (like regular Solidity function calls).\\r\\n     *\\r\\n     * Returns the raw returned data. To convert to the expected return value,\\r\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `target` must be a contract.\\r\\n     * - calling `target` with `data` must not revert.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\r\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCall(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        string memory errorMessage\\r\\n    ) internal returns (bytes memory) {\\r\\n        return functionCallWithValue(target, data, 0, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but also transferring `value` wei to `target`.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the calling contract must have an ETH balance of at least `value`.\\r\\n     * - the called Solidity function must be `payable`.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCallWithValue(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        uint256 value\\r\\n    ) internal returns (bytes memory) {\\r\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\r\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCallWithValue(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        uint256 value,\\r\\n        string memory errorMessage\\r\\n    ) internal returns (bytes memory) {\\r\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\r\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\r\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but performing a static call.\\r\\n     *\\r\\n     * _Available since v3.3._\\r\\n     */\\r\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\r\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\r\\n     * but performing a static call.\\r\\n     *\\r\\n     * _Available since v3.3._\\r\\n     */\\r\\n    function functionStaticCall(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        string memory errorMessage\\r\\n    ) internal view returns (bytes memory) {\\r\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\r\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\r\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\r\\n     *\\r\\n     * _Available since v4.8._\\r\\n     */\\r\\n    function verifyCallResultFromTarget(\\r\\n        address target,\\r\\n        bool success,\\r\\n        bytes memory returndata,\\r\\n        string memory errorMessage\\r\\n    ) internal view returns (bytes memory) {\\r\\n        if (success) {\\r\\n            if (returndata.length == 0) {\\r\\n                // only check isContract if the call was successful and the return data is empty\\r\\n                // otherwise we already know that it was a contract\\r\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\r\\n            }\\r\\n            return returndata;\\r\\n        } else {\\r\\n            _revert(returndata, errorMessage);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\r\\n     * revert reason or using the provided one.\\r\\n     *\\r\\n     * _Available since v4.3._\\r\\n     */\\r\\n    function verifyCallResult(\\r\\n        bool success,\\r\\n        bytes memory returndata,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (bytes memory) {\\r\\n        if (success) {\\r\\n            return returndata;\\r\\n        } else {\\r\\n            _revert(returndata, errorMessage);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\r\\n        // Look for revert reason and bubble it up if present\\r\\n        if (returndata.length > 0) {\\r\\n            // The easiest way to bubble the revert reason is using memory via assembly\\r\\n            /// @solidity memory-safe-assembly\\r\\n            assembly {\\r\\n                let returndata_size := mload(returndata)\\r\\n                revert(add(32, returndata), returndata_size)\\r\\n            }\\r\\n        } else {\\r\\n            revert(errorMessage);\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/access/IAccessControlUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\r\\n */\\r\\ninterface IAccessControlUpgradeable {\\r\\n    /**\\r\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\r\\n     *\\r\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\r\\n     * {RoleAdminChanged} not being emitted signaling this.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `account` is granted `role`.\\r\\n     *\\r\\n     * `sender` is the account that originated the contract call, an admin role\\r\\n     * bearer except when using {AccessControl-_setupRole}.\\r\\n     */\\r\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `account` is revoked `role`.\\r\\n     *\\r\\n     * `sender` is the account that originated the contract call:\\r\\n     *   - if using `revokeRole`, it is the admin role bearer\\r\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\r\\n     */\\r\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns `true` if `account` has been granted `role`.\\r\\n     */\\r\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\r\\n     * {revokeRole}.\\r\\n     *\\r\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\r\\n     */\\r\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\r\\n\\r\\n    /**\\r\\n     * @dev Grants `role` to `account`.\\r\\n     *\\r\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\r\\n     * event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the caller must have ``role``'s admin role.\\r\\n     */\\r\\n    function grantRole(bytes32 role, address account) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Revokes `role` from `account`.\\r\\n     *\\r\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the caller must have ``role``'s admin role.\\r\\n     */\\r\\n    function revokeRole(bytes32 role, address account) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Revokes `role` from the calling account.\\r\\n     *\\r\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\r\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\r\\n     * if they are compromised (such as when a trusted device is misplaced).\\r\\n     *\\r\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\r\\n     * event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the caller must be `account`.\\r\\n     */\\r\\n    function renounceRole(bytes32 role, address account) external;\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@openzeppelin-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/\",\r\n      \"@openzeppelin/=lib/openzeppelin-contracts/contracts/\",\r\n      \"@solmate/=lib/solmate/src/\",\r\n      \"create3/=lib/create3/contracts/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"solmate/=lib/solmate/src/\",\r\n      \"sstore2/=lib/sstore2/contracts/\",\r\n      \"lib/forge-std:ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"lib/openzeppelin-contracts:ds-test/=lib/openzeppelin-contracts/lib/forge-std/lib/ds-test/src/\",\r\n      \"lib/openzeppelin-contracts:erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"lib/openzeppelin-contracts:forge-std/=lib/openzeppelin-contracts/lib/forge-std/src/\",\r\n      \"lib/openzeppelin-contracts-upgradeable:ds-test/=lib/openzeppelin-contracts-upgradeable/lib/forge-std/lib/ds-test/src/\",\r\n      \"lib/openzeppelin-contracts-upgradeable:forge-std/=lib/openzeppelin-contracts-upgradeable/lib/forge-std/src/\",\r\n      \"lib/solmate:ds-test/=lib/solmate/lib/ds-test/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 25000\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {\r\n      \"script/helper/ArraysHelper.sol\": {\r\n        \"ArraysHelper\": \"0xe8699692d47fc2fdaccba8c58aeb8c6373357c2c\"\r\n      },\r\n      \"src/libraries/ArrayMapping.sol\": {\r\n        \"ArrayMappingUint256\": \"0xe3cb6e39e09d989f0ed7282bda801564ad5f240d\"\r\n      },\r\n      \"src/libraries/ReallocationLib.sol\": {\r\n        \"ReallocationLib\": \"0x79ec100b4c7111efd0a79edf3f250625162293ae\"\r\n      },\r\n      \"src/libraries/SpoolUtils.sol\": {\r\n        \"SpoolUtils\": \"0x435a26e3924831512c17133b0707764068bbc022\"\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IAssetGroupRegistry\",\"name\":\"assetGroupRegistry_\",\"type\":\"address\"},{\"internalType\":\"contract ISpoolAccessControl\",\"name\":\"accessControl_\",\"type\":\"address\"},{\"internalType\":\"contract ISwapper\",\"name\":\"swapper_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ConfigurationAddressZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IdleBeforeDepositCheckFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IdleBeforeRedeemalCheckFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IdleCompoundSlippagesFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IdleDepositSlippagesFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IdleRedeemSlippagesFailed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assetGroupId\",\"type\":\"uint256\"}],\"name\":\"InvalidAssetGroup\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidAssetGroupIdInitialization\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidConfiguration\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"MissingRole\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"NotFastRedeemer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"StrategyWorthIsZero\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"BeforeDepositCheckSlippages\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ssts\",\"type\":\"uint256\"}],\"name\":\"BeforeRedeemalCheckSlippages\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mintedShares\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"usdWorthDeposited\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"assetsBeforeSwap\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"assetsDeposited\",\"type\":\"uint256[]\"}],\"name\":\"Deposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sharesMinted\",\"type\":\"uint256\"}],\"name\":\"PlatformFeesCollected\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isDeposit\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"slippage\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"Slippages\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"withdrawnShares\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"usdWorthWithdrawn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"withdrawnAssets\",\"type\":\"uint256[]\"}],\"name\":\"Withdrawn\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"assetGroupId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"assetRatio\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"assets\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"slippages\",\"type\":\"uint256[]\"}],\"name\":\"beforeDepositCheck\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ssts\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"slippages\",\"type\":\"uint256[]\"}],\"name\":\"beforeRedeemalCheck\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"smartVault\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"claimShares\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"assetGroup\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"exchangeRates\",\"type\":\"uint256[]\"},{\"internalType\":\"contract IUsdPriceFeedManager\",\"name\":\"priceFeedManager\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"slippages\",\"type\":\"uint256[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"swapTarget\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"swapCallData\",\"type\":\"bytes\"}],\"internalType\":\"struct SwapInfo[]\",\"name\":\"swapInfo\",\"type\":\"tuple[]\"}],\"name\":\"depositFast\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"swapTarget\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"swapCallData\",\"type\":\"bytes\"}],\"internalType\":\"struct SwapInfo[]\",\"name\":\"swapInfo\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"swapTarget\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"swapCallData\",\"type\":\"bytes\"}],\"internalType\":\"struct SwapInfo[]\",\"name\":\"compoundSwapInfo\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256[]\",\"name\":\"slippages\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"assetGroup\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"exchangeRates\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"withdrawnShares\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"masterWallet\",\"type\":\"address\"},{\"internalType\":\"contract IUsdPriceFeedManager\",\"name\":\"priceFeedManager\",\"type\":\"address\"},{\"internalType\":\"int256\",\"name\":\"baseYield\",\"type\":\"int256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"ecosystemFeeReceiver\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"ecosystemFeePct\",\"type\":\"uint96\"},{\"internalType\":\"address\",\"name\":\"treasuryFeeReceiver\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"treasuryFeePct\",\"type\":\"uint96\"}],\"internalType\":\"struct PlatformFees\",\"name\":\"platformFees\",\"type\":\"tuple\"}],\"internalType\":\"struct StrategyDhwParameterBag\",\"name\":\"dhwParams\",\"type\":\"tuple\"}],\"name\":\"doHardWork\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"sharesMinted\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"assetsWithdrawn\",\"type\":\"uint256[]\"},{\"internalType\":\"int256\",\"name\":\"yieldPercentage\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"valueAtDhw\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSstsAtDhw\",\"type\":\"uint256\"}],\"internalType\":\"struct DhwInfo\",\"name\":\"dhwInfo\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"slippages\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"emergencyWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getProtocolRewards\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUnderlyingAssetAmounts\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"exchangeRates\",\"type\":\"uint256[]\"},{\"internalType\":\"contract IUsdPriceFeedManager\",\"name\":\"priceFeedManager\",\"type\":\"address\"}],\"name\":\"getUsdWorth\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"idleToken\",\"outputs\":[{\"internalType\":\"contract IIdleToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"strategyName_\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"assetGroupId_\",\"type\":\"uint256\"},{\"internalType\":\"contract IIdleToken\",\"name\":\"idleToken_\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oneShare\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"\",\"type\":\"uint96\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"masterWallet\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"assetGroup\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"slippages\",\"type\":\"uint256[]\"}],\"name\":\"redeemFast\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"redeemer\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"assetGroup\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"slippages\",\"type\":\"uint256[]\"}],\"name\":\"redeemShares\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"smartVault\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"releaseShares\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"strategyName\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapper\",\"outputs\":[{\"internalType\":\"contract ISwapper\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"IdleStrategy","CompilerVersion":"v0.8.17+commit.8df45f5f","OptimizationUsed":"1","Runs":"25000","ConstructorArguments":"000000000000000000000000a70c97c4be25b8fedad6c328492e9334dea8dbe30000000000000000000000003e95575c3d6d91ef2f7dd139b1a799edf6a8d88b00000000000000000000000051d9e9162d4e3a683b933e4fe38b249d2f718192","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}