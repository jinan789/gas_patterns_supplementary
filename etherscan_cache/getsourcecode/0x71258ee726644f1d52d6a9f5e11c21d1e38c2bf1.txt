{"status":"1","message":"OK","result":[{"SourceCode":"# @version 0.3.10\r\n\"\"\"\r\n@title Executor\r\n@author 0xkorin, Yearn Finance\r\n@license GNU AGPLv3\r\n@notice\r\n    Responsible for executing governance decisions through a proxy.\r\n    Only appointed governors are allowed to execute calls, subject to access control based on \r\n    the governor, the calling contract and the selector.\r\n    Management has the power to enable and set/unset whitelists and blacklists.\r\n    The management role is intended to be transferred to the proxy, making the system self-governing.\r\n\"\"\"\r\n\r\ninterface Proxy:\r\n    def execute(_to: address, _data: Bytes[2048]): nonpayable\r\n\r\nenum Access:\r\n    WHITELIST\r\n    BLACKLIST\r\n\r\nproxy: public(immutable(Proxy))\r\nmanagement: public(address)\r\npending_management: public(address)\r\ngovernors: public(HashMap[address, bool])\r\naccess: public(HashMap[uint256, Access]) # target => access control setting\r\nwhitelisted: HashMap[uint256, HashMap[address, bool]] # target => governor => whitelisted\r\nblacklisted: HashMap[uint256, HashMap[address, bool]] # target => governor => blacklisted\r\n\r\nevent Execute:\r\n    by: indexed(address)\r\n    contract: indexed(address)\r\n    data: Bytes[2048]\r\n\r\nevent SetGovernor:\r\n    by: indexed(address)\r\n    governor: indexed(address)\r\n    flag: bool\r\n\r\nevent SetAccess:\r\n    by: indexed(address)\r\n    contract: indexed(address)\r\n    identifier: indexed(bytes4)\r\n    access: Access\r\n\r\nevent Whitelist:\r\n    contract: indexed(address)\r\n    identifier: indexed(bytes4)\r\n    by: indexed(address)\r\n    whitelisted: bool\r\n\r\nevent Blacklist:\r\n    contract: indexed(address)\r\n    identifier: indexed(bytes4)\r\n    by: indexed(address)\r\n    blacklisted: bool\r\n\r\nevent PendingManagement:\r\n    management: indexed(address)\r\n\r\nevent SetManagement:\r\n    management: indexed(address)\r\n\r\nTARGET_MASK: public(constant(uint256)) = shift(1, 192) - 1\r\nIDENTIFIER_MASK: constant(uint256) = shift(1, 32) - 1\r\n\r\n@external\r\ndef __init__(_proxy: address):\r\n    \"\"\"\r\n    @notice Constructor\r\n    @param _proxy The ownership proxy\r\n    \"\"\"\r\n    proxy = Proxy(_proxy)\r\n    self.management = msg.sender\r\n    self.governors[msg.sender] = True\r\n\r\n@external\r\ndef execute_single(_to: address, _data: Bytes[2048]):\r\n    \"\"\"\r\n    @notice Execute a single call\r\n    @param _to The contract to call\r\n    @param _data Calldata\r\n    \"\"\"\r\n    assert self.governors[msg.sender]\r\n    assert len(_data) >= 4\r\n    identifier: bytes4 = convert(slice(_data, 0, 4), bytes4)\r\n    target: uint256 = self._pack_target(_to, identifier)\r\n\r\n    # check access control\r\n    access: Access = self.access[target]\r\n    if access == Access.BLACKLIST:\r\n        assert not self.blacklisted[target][msg.sender]\r\n    elif access == Access.WHITELIST:\r\n        assert self.whitelisted[target][msg.sender]\r\n\r\n    proxy.execute(_to, _data)\r\n    log Execute(msg.sender, _to, _data)\r\n\r\n@external\r\ndef execute(_script: Bytes[2048]):\r\n    \"\"\"\r\n    @notice Execute a single script consisting of one or more calls\r\n    @param _script Script to execute\r\n    \"\"\"\r\n    assert self.governors[msg.sender]\r\n\r\n    i: uint256 = 0\r\n    for x in range(32):\r\n        if i == len(_script):\r\n            break\r\n        assert i + 32 <= len(_script)\r\n    \r\n        # extract target and calldata size\r\n        target: uint256 = extract32(_script, i, output_type=uint256) # calldata size (64) | address (160) | identifier (32)\r\n        size: uint256 = shift(target, -192)\r\n        target &= TARGET_MASK\r\n        i += 28 # calldata size (8 bytes) + address (20 bytes)\r\n        assert i + size <= len(_script)\r\n        assert size >= 4 and size <= 2048\r\n\r\n        # check access control\r\n        access: Access = self.access[target]\r\n        if access == Access.BLACKLIST:\r\n            assert not self.blacklisted[target][msg.sender]\r\n        elif access == Access.WHITELIST:\r\n            assert self.whitelisted[target][msg.sender]\r\n\r\n        contract: address = empty(address)\r\n        identifier: bytes4 = empty(bytes4)\r\n        contract, identifier = self._unpack_target(target)\r\n        calldata: Bytes[2048] = slice(_script, i, size)\r\n\r\n        i += size\r\n        assert i <= len(_script)\r\n\r\n        proxy.execute(contract, calldata)\r\n        log Execute(msg.sender, contract, calldata)\r\n\r\n    assert i == len(_script)\r\n\r\n@external\r\n@pure\r\ndef script(_to: address, _data: Bytes[2048]) -> Bytes[2080]:\r\n    \"\"\"\r\n    @notice\r\n        Generate script for a single call.\r\n        Calls can be chained by concatenating their scripts\r\n    @param _to The contract to call\r\n    @param _data Calldata\r\n    \"\"\"\r\n    assert len(_data) >= 4\r\n    prefix: uint256 = shift(len(_data), 160) | convert(_to, uint256)\r\n    return concat(convert(convert(prefix, uint224), bytes28), _data)\r\n\r\n@external\r\ndef set_governor(_governor: address, _flag: bool):\r\n    \"\"\"\r\n    @notice Set the governor role\r\n    @param _governor The account to set the role for\r\n    @param _flag True: set governor, False: unset governor\r\n    \"\"\"\r\n    assert msg.sender == self.management\r\n    assert _governor != empty(address)\r\n    self.governors[_governor] = _flag\r\n    log SetGovernor(msg.sender, _governor, _flag)\r\n\r\n@external\r\ndef set_access(_contract: address, _identifier: bytes4, _access: Access):\r\n    \"\"\"\r\n    @notice Set access control for a contract+identifier combination\r\n    @param _contract Contract address\r\n    @param _identifier Function identifier\r\n    @param _access Whether to enable whitelist or blacklist. Zero to disable access control\r\n    \"\"\"\r\n    assert msg.sender == self.management\r\n    assert _contract != empty(address)\r\n    assert convert(_access, uint256) < 3\r\n    target: uint256 = self._pack_target(_contract, _identifier)\r\n    self.access[target] = _access\r\n    log SetAccess(msg.sender, _contract, _identifier, _access)\r\n\r\n@external\r\ndef whitelist(_contract: address, _identifier: bytes4, _caller: address, _whitelisted: bool):\r\n    \"\"\"\r\n    @notice Whitelist a governor for a contract+identifier combination\r\n    @param _contract Contract address\r\n    @param _identifier Function identifier\r\n    @param _caller Governor to apply the whitelist to\r\n    @param _whitelisted True: add to whitelist, False: remove from whitelist\r\n    \"\"\"\r\n    assert msg.sender == self.management\r\n    assert _contract != empty(address)\r\n    target: uint256 = self._pack_target(_contract, _identifier)\r\n    self.whitelisted[target][_caller] = _whitelisted\r\n    log Whitelist(_contract, _identifier, _caller, _whitelisted)\r\n\r\n@external\r\n@view\r\ndef is_whitelisted(_contract: address, _identifier: bytes4, _caller: address) -> bool:\r\n    \"\"\"\r\n    @notice Query if a governor is whitelisted to call a contract+identifier combination\r\n    @param _contract Contract address\r\n    @param _identifier Function identifier\r\n    @param _caller Governor\r\n    @return True: on whitelist, False: not on whitelist\r\n    \"\"\"\r\n    target: uint256 = self._pack_target(_contract, _identifier)\r\n    return self.whitelisted[target][_caller]\r\n\r\n@external\r\n@view\r\ndef has_whitelist(_contract: address, _identifier: bytes4) -> bool:\r\n    \"\"\"\r\n    @notice Query if a contract+identifier combination has whitelist enabled\r\n    @param _contract Contract address\r\n    @param _identifier Function identifier\r\n    @return True: whitelist enabled, False: whitelist disabled\r\n    \"\"\"\r\n    target: uint256 = self._pack_target(_contract, _identifier)\r\n    return self.access[target] == Access.WHITELIST\r\n\r\n@external\r\ndef blacklist(_contract: address, _identifier: bytes4, _caller: address, _blacklisted: bool):\r\n    \"\"\"\r\n    @notice Blacklist a governor for a contract+identifier combination\r\n    @param _contract Contract address\r\n    @param _identifier Function identifier\r\n    @param _caller Governor to apply the blacklist to\r\n    @param _blacklisted True: add to blacklist, False: remove from blacklist\r\n    \"\"\"\r\n    assert msg.sender == self.management\r\n    assert _contract != empty(address)\r\n    target: uint256 = self._pack_target(_contract, _identifier)\r\n    self.blacklisted[target][_caller] = _blacklisted\r\n    log Blacklist(_contract, _identifier, _caller, _blacklisted)\r\n\r\n@external\r\n@view\r\ndef is_blacklisted(_contract: address, _identifier: bytes4, _caller: address) -> bool:\r\n    \"\"\"\r\n    @notice Query if a governor is blacklisted to call a contract+identifier combination\r\n    @param _contract Contract address\r\n    @param _identifier Function identifier\r\n    @param _caller Governor\r\n    @return True: on blacklist, False: not on blacklist\r\n    \"\"\"\r\n    target: uint256 = self._pack_target(_contract, _identifier)\r\n    return self.blacklisted[target][_caller]\r\n\r\n@external\r\n@view\r\ndef has_blacklist(_contract: address, _identifier: bytes4) -> bool:\r\n    \"\"\"\r\n    @notice Query if a contract+identifier combination has blacklist enabled\r\n    @param _contract Contract address\r\n    @param _identifier Function identifier\r\n    @return True: blacklist enabled, False: blacklist disabled\r\n    \"\"\"\r\n    target: uint256 = self._pack_target(_contract, _identifier)\r\n    return self.access[target] == Access.BLACKLIST\r\n\r\n@external\r\ndef set_management(_management: address):\r\n    \"\"\"\r\n    @notice \r\n        Set the pending management address.\r\n        Needs to be accepted by that account separately to transfer management over\r\n    @param _management New pending management address\r\n    \"\"\"\r\n    assert msg.sender == self.management\r\n    self.pending_management = _management\r\n    log PendingManagement(_management)\r\n\r\n@external\r\ndef accept_management():\r\n    \"\"\"\r\n    @notice \r\n        Accept management role.\r\n        Can only be called by account previously marked as pending management by current management\r\n    \"\"\"\r\n    assert msg.sender == self.pending_management\r\n    self.pending_management = empty(address)\r\n    self.management = msg.sender\r\n    log SetManagement(msg.sender)\r\n\r\n@internal\r\n@pure\r\ndef _pack_target(_contract: address, _identifier: bytes4) -> uint256:\r\n    \"\"\"\r\n    @notice Pack a contract+identifier into a single word\r\n    \"\"\"\r\n    return shift(convert(_contract, uint256), 32) | convert(_identifier, uint256)\r\n\r\n@internal\r\n@pure\r\ndef _unpack_target(_target: uint256) -> (address, bytes4):\r\n    \"\"\"\r\n    @notice Unpack a contract+identifier from a single word\r\n    \"\"\"\r\n    return convert(shift(_target, -32), address), convert(convert(_target & IDENTIFIER_MASK, uint32), bytes4)","ABI":"[{\"name\":\"Execute\",\"inputs\":[{\"name\":\"by\",\"type\":\"address\",\"indexed\":true},{\"name\":\"contract\",\"type\":\"address\",\"indexed\":true},{\"name\":\"data\",\"type\":\"bytes\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetGovernor\",\"inputs\":[{\"name\":\"by\",\"type\":\"address\",\"indexed\":true},{\"name\":\"governor\",\"type\":\"address\",\"indexed\":true},{\"name\":\"flag\",\"type\":\"bool\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetAccess\",\"inputs\":[{\"name\":\"by\",\"type\":\"address\",\"indexed\":true},{\"name\":\"contract\",\"type\":\"address\",\"indexed\":true},{\"name\":\"identifier\",\"type\":\"bytes4\",\"indexed\":true},{\"name\":\"access\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Whitelist\",\"inputs\":[{\"name\":\"contract\",\"type\":\"address\",\"indexed\":true},{\"name\":\"identifier\",\"type\":\"bytes4\",\"indexed\":true},{\"name\":\"by\",\"type\":\"address\",\"indexed\":true},{\"name\":\"whitelisted\",\"type\":\"bool\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Blacklist\",\"inputs\":[{\"name\":\"contract\",\"type\":\"address\",\"indexed\":true},{\"name\":\"identifier\",\"type\":\"bytes4\",\"indexed\":true},{\"name\":\"by\",\"type\":\"address\",\"indexed\":true},{\"name\":\"blacklisted\",\"type\":\"bool\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"PendingManagement\",\"inputs\":[{\"name\":\"management\",\"type\":\"address\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetManagement\",\"inputs\":[{\"name\":\"management\",\"type\":\"address\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"_proxy\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"execute_single\",\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"execute\",\"inputs\":[{\"name\":\"_script\",\"type\":\"bytes\"}],\"outputs\":[]},{\"stateMutability\":\"pure\",\"type\":\"function\",\"name\":\"script\",\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bytes\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_governor\",\"inputs\":[{\"name\":\"_governor\",\"type\":\"address\"},{\"name\":\"_flag\",\"type\":\"bool\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_access\",\"inputs\":[{\"name\":\"_contract\",\"type\":\"address\"},{\"name\":\"_identifier\",\"type\":\"bytes4\"},{\"name\":\"_access\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"whitelist\",\"inputs\":[{\"name\":\"_contract\",\"type\":\"address\"},{\"name\":\"_identifier\",\"type\":\"bytes4\"},{\"name\":\"_caller\",\"type\":\"address\"},{\"name\":\"_whitelisted\",\"type\":\"bool\"}],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"is_whitelisted\",\"inputs\":[{\"name\":\"_contract\",\"type\":\"address\"},{\"name\":\"_identifier\",\"type\":\"bytes4\"},{\"name\":\"_caller\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"has_whitelist\",\"inputs\":[{\"name\":\"_contract\",\"type\":\"address\"},{\"name\":\"_identifier\",\"type\":\"bytes4\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"blacklist\",\"inputs\":[{\"name\":\"_contract\",\"type\":\"address\"},{\"name\":\"_identifier\",\"type\":\"bytes4\"},{\"name\":\"_caller\",\"type\":\"address\"},{\"name\":\"_blacklisted\",\"type\":\"bool\"}],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"is_blacklisted\",\"inputs\":[{\"name\":\"_contract\",\"type\":\"address\"},{\"name\":\"_identifier\",\"type\":\"bytes4\"},{\"name\":\"_caller\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"has_blacklist\",\"inputs\":[{\"name\":\"_contract\",\"type\":\"address\"},{\"name\":\"_identifier\",\"type\":\"bytes4\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_management\",\"inputs\":[{\"name\":\"_management\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"accept_management\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"proxy\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"management\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"pending_management\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"governors\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"access\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"TARGET_MASK\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]}]","ContractName":"Executor","CompilerVersion":"vyper:0.3.10","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"00000000000000000000000056af9c2780e0323810acfdaeab3f58ef6e76fafd","EVMVersion":"Default","Library":"","LicenseType":"GNU AGPLv3","Proxy":"0","Implementation":"","SwarmSource":""}]}