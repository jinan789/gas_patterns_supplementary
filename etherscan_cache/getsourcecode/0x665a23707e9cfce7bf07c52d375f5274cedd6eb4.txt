{"status":"1","message":"OK","result":[{"SourceCode":"# @version 0.3.7\r\n\r\n\"\"\"\r\n@title Voting Escrow\r\n@author Curve Finance\r\n@license MIT\r\n@notice Votes have a weight depending on time, so that users are\r\n        committed to the future of (whatever they are voting for)\r\n@dev Vote weight decays linearly over time. Lock time cannot be\r\n     more than `MAXTIME` (set by creator).\r\n\"\"\"\r\n\r\n# Voting escrow to have time-weighted votes\r\n# Votes have a weight depending on time, so that users are committed\r\n# to the future of (whatever they are voting for).\r\n# The weight in this implementation is linear, and lock cannot be more than maxtime:\r\n# w ^\r\n# 1 +        /\r\n#   |      /\r\n#   |    /\r\n#   |  /\r\n#   |/\r\n# 0 +--------+------> time\r\n#       maxtime\r\n\r\nstruct Point:\r\n    bias: int128\r\n    slope: int128  # - dweight / dt\r\n    ts: uint256\r\n    blk: uint256  # block\r\n# We cannot really do block numbers per se b/c slope is per time, not per block\r\n# and per block could be fairly bad b/c Ethereum changes blocktimes.\r\n# What we can do is to extrapolate ***At functions\r\n\r\nstruct LockedBalance:\r\n    amount: int128\r\n    end: uint256\r\n\r\n\r\ninterface ERC20:\r\n    def decimals() -> uint256: view\r\n    def name() -> String[64]: view\r\n    def symbol() -> String[32]: view\r\n    def balanceOf(account: address) -> uint256: view\r\n    def transfer(to: address, amount: uint256) -> bool: nonpayable\r\n    def approve(spender: address, amount: uint256) -> bool: nonpayable\r\n    def transferFrom(spender: address, to: address, amount: uint256) -> bool: nonpayable\r\n\r\n\r\n# Interface for checking whether address belongs to a whitelisted\r\n# type of a smart wallet.\r\n# When new types are added - the whole contract is changed\r\n# The check() method is modifying to be able to use caching\r\n# for individual wallet addresses\r\ninterface SmartWalletChecker:\r\n    def check(addr: address) -> bool: nonpayable\r\n\r\ninterface BalancerMinter:\r\n    def mint(gauge: address) -> uint256: nonpayable\r\n\r\ninterface RewardDistributor:\r\n    def depositToken(token: address, amount: uint256): nonpayable\r\n\r\nDEPOSIT_FOR_TYPE: constant(int128) = 0\r\nCREATE_LOCK_TYPE: constant(int128) = 1\r\nINCREASE_LOCK_AMOUNT: constant(int128) = 2\r\nINCREASE_UNLOCK_TIME: constant(int128) = 3\r\n\r\n\r\nevent CommitOwnership:\r\n    admin: address\r\n\r\nevent ApplyOwnership:\r\n    admin: address\r\n\r\nevent EarlyUnlock:\r\n    status: bool\r\n\r\nevent PenaltySpeed:\r\n    penalty_k: uint256\r\n\r\nevent PenaltyTreasury:\r\n    penalty_treasury: address\r\n\r\nevent TotalUnlock:\r\n    status: bool\r\n\r\nevent RewardReceiver:\r\n    newReceiver: address\r\n\r\nevent Deposit:\r\n    provider: indexed(address)\r\n    value: uint256\r\n    locktime: indexed(uint256)\r\n    type: int128\r\n    ts: uint256\r\n\r\nevent Withdraw:\r\n    provider: indexed(address)\r\n    value: uint256\r\n    ts: uint256\r\n\r\nevent WithdrawEarly:\r\n    provider: indexed(address)\r\n    penalty: uint256\r\n    time_left: uint256\r\n\r\nevent Supply:\r\n    prevSupply: uint256\r\n    supply: uint256\r\n\r\n\r\nWEEK: constant(uint256) = 7 * 86400  # all future times are rounded by week\r\nMAXTIME: public(uint256)\r\nMULTIPLIER: constant(uint256) = 10**18\r\n\r\nTOKEN: public(address)\r\n\r\nNAME: String[64]\r\nSYMBOL: String[32]\r\nDECIMALS: uint256\r\n\r\nsupply: public(uint256)\r\nlocked: public(HashMap[address, LockedBalance])\r\n\r\nepoch: public(uint256)\r\npoint_history: public(Point[100000000000000000000000000000])  # epoch -> unsigned point\r\nuser_point_history: public(HashMap[address, Point[1000000000]])  # user -> Point[user_epoch]\r\nuser_point_epoch: public(HashMap[address, uint256])\r\nslope_changes: public(HashMap[uint256, int128])  # time -> signed slope change\r\n\r\n# Checker for whitelisted (smart contract) wallets which are allowed to deposit\r\n# The goal is to prevent tokenizing the escrow\r\nfuture_smart_wallet_checker: public(address)\r\nsmart_wallet_checker: public(address)\r\n\r\nadmin: public(address)\r\n\r\n# unlock admins can be set only once. Zero-address means unlock is disabled\r\nadmin_unlock_all: public(address)\r\nadmin_early_unlock: public(address)\r\n\r\nfuture_admin: public(address)\r\n\r\nis_initialized: public(bool)\r\n\r\nearly_unlock: public(bool)\r\npenalty_k: public(uint256)\r\nprev_penalty_k: public(uint256)\r\npenalty_upd_ts: public(uint256)\r\nPENALTY_COOLDOWN: constant(uint256) = 60 # cooldown to prevent font-run on penalty change\r\nPENALTY_MULTIPLIER: constant(uint256) = 10\r\n\r\npenalty_treasury: public(address)\r\n\r\nbalMinter: public(address)\r\nbalToken: public(address)\r\nrewardReceiver: public(address)\r\nrewardReceiverChangeable: public(bool)\r\n\r\nrewardDistributor: public(address)\r\n\r\nall_unlock: public(bool)\r\n\r\n\r\n@external\r\ndef initialize(\r\n    _token_addr: address,\r\n    _name: String[64],\r\n    _symbol: String[32],\r\n    _admin_addr: address,\r\n    _admin_unlock_all: address,\r\n    _admin_early_unlock: address,\r\n    _max_time: uint256,\r\n    _balToken: address,\r\n    _balMinter: address,\r\n    _rewardReceiver: address,\r\n    _rewardReceiverChangeable: bool,\r\n    _rewardDistributor: address\r\n):\r\n    \"\"\"\r\n    @notice Contract constructor\r\n    @param _token_addr 80/20 Token-WETH BPT token address\r\n    @param _name Token name\r\n    @param _symbol Token symbol\r\n    @param _admin_addr Contract admin address\r\n    @param _admin_unlock_all Admin to enable Unlock-All feature (zero-address to disable forever)\r\n    @param _admin_early_unlock Admin to enable Eraly-Unlock feature (zero-address to disable forever)\r\n    @param _max_time Locking max time\r\n    @param _balToken Address of the Balancer token\r\n    @param _balMinter Address of the Balancer minter\r\n    @param _rewardReceiver Address of the reward receiver\r\n    @param _rewardReceiverChangeable Boolean indicating whether the reward receiver is changeable\r\n    @param _rewardDistributor The RewardDistributor contract address\r\n    \"\"\"\r\n\r\n    assert(not self.is_initialized), 'only once'\r\n    self.is_initialized = True\r\n\r\n    assert(_admin_addr != empty(address)), '!empty'\r\n    self.admin = _admin_addr\r\n\r\n    self.penalty_k = 10\r\n    self.prev_penalty_k = 10\r\n    self.penalty_upd_ts = block.timestamp\r\n    self.penalty_treasury = _admin_addr\r\n\r\n    self.TOKEN = _token_addr\r\n    self.point_history[0].blk = block.number\r\n    self.point_history[0].ts = block.timestamp\r\n\r\n    _decimals: uint256 = ERC20(_token_addr).decimals()  # also validates token for non-zero\r\n    assert (_decimals >= 6 and _decimals <= 255), '!decimals'\r\n\r\n    self.NAME = _name\r\n    self.SYMBOL = _symbol\r\n    self.DECIMALS = _decimals\r\n\r\n    assert(_max_time >= WEEK and _max_time <= WEEK * 52 * 5), '!maxlock'\r\n    self.MAXTIME = _max_time\r\n\r\n    self.admin_unlock_all = _admin_unlock_all\r\n    self.admin_early_unlock = _admin_early_unlock\r\n\r\n    self.balToken = _balToken\r\n    self.balMinter = _balMinter\r\n    self.rewardReceiver = _rewardReceiver\r\n    self.rewardReceiverChangeable = _rewardReceiverChangeable\r\n    self.rewardDistributor = _rewardDistributor\r\n\r\n\r\n@external\r\n@view\r\ndef token() -> address:\r\n    return self.TOKEN\r\n\r\n@external\r\n@view\r\ndef name() -> String[64]:\r\n    return self.NAME\r\n\r\n@external\r\n@view\r\ndef symbol() -> String[32]:\r\n    return self.SYMBOL\r\n\r\n@external\r\n@view\r\ndef decimals() -> uint256:\r\n    return self.DECIMALS\r\n\r\n@external\r\ndef commit_transfer_ownership(addr: address):\r\n    \"\"\"\r\n    @notice Transfer ownership of VotingEscrow contract to `addr`\r\n    @param addr Address to have ownership transferred to\r\n    \"\"\"\r\n    assert msg.sender == self.admin  # dev: admin only\r\n    self.future_admin = addr\r\n    log CommitOwnership(addr)\r\n\r\n\r\n@external\r\ndef apply_transfer_ownership():\r\n    \"\"\"\r\n    @notice Apply ownership transfer\r\n    \"\"\"\r\n    assert msg.sender == self.admin  # dev: admin only\r\n    _admin: address = self.future_admin\r\n    assert _admin != empty(address)  # dev: admin not set\r\n    self.admin = _admin\r\n    log ApplyOwnership(_admin)\r\n\r\n\r\n@external\r\ndef commit_smart_wallet_checker(addr: address):\r\n    \"\"\"\r\n    @notice Set an external contract to check for approved smart contract wallets\r\n    @param addr Address of Smart contract checker\r\n    \"\"\"\r\n    assert msg.sender == self.admin\r\n    self.future_smart_wallet_checker = addr\r\n\r\n@external\r\ndef apply_smart_wallet_checker():\r\n    \"\"\"\r\n    @notice Apply setting external contract to check approved smart contract wallets\r\n    \"\"\"\r\n    assert msg.sender == self.admin\r\n    self.smart_wallet_checker = self.future_smart_wallet_checker\r\n\r\n\r\n@internal\r\ndef assert_not_contract(addr: address):\r\n    \"\"\"\r\n    @notice Check if the call is from a whitelisted smart contract, revert if not\r\n    @param addr Address to be checked\r\n    \"\"\"\r\n    if addr != tx.origin:\r\n        checker: address = self.smart_wallet_checker\r\n        if checker != empty(address):\r\n            if SmartWalletChecker(checker).check(addr):\r\n                return\r\n        raise \"Smart contract depositors not allowed\"\r\n\r\n\r\n@external\r\ndef set_early_unlock(_early_unlock: bool):\r\n    \"\"\"\r\n    @notice Sets the availability for users to unlock their locks before lock-end with penalty\r\n    @dev Only the admin_early_unlock can execute this function.\r\n    @param _early_unlock A boolean indicating whether early unlock is allowed or not.\r\n    \"\"\"\r\n    assert msg.sender == self.admin_early_unlock, '!admin'  # dev: admin_early_unlock only\r\n    assert _early_unlock != self.early_unlock, 'already'\r\n    \r\n    self.early_unlock = _early_unlock\r\n    log EarlyUnlock(_early_unlock)\r\n\r\n\r\n@external\r\ndef set_early_unlock_penalty_speed(_penalty_k: uint256):\r\n    \"\"\"\r\n    @notice Sets penalty speed for early unlocking\r\n    @dev Only the admin can execute this function. To prevent frontrunning we use PENALTY_COOLDOWN period\r\n    @param _penalty_k Coefficient indicating the penalty speed for early unlock.\r\n                      Must be between 0 and 50, inclusive. Default 10 - means linear speed.\r\n    \"\"\"\r\n    assert msg.sender == self.admin_early_unlock, '!admin'  # dev: admin_early_unlock only\r\n    assert _penalty_k <= 50, '!k'\r\n    assert block.timestamp > self.penalty_upd_ts + PENALTY_COOLDOWN, 'early' # to avoid frontrun\r\n\r\n    self.prev_penalty_k = self.penalty_k\r\n    self.penalty_k = _penalty_k\r\n    self.penalty_upd_ts = block.timestamp\r\n\r\n    log PenaltySpeed(_penalty_k)\r\n\r\n\r\n@external\r\ndef set_penalty_treasury(_penalty_treasury: address):\r\n    \"\"\"\r\n    @notice Sets penalty treasury address\r\n    @dev Only the admin_early_unlock can execute this function.\r\n    @param _penalty_treasury The address to collect early penalty (default admin address)\r\n    \"\"\"\r\n    assert msg.sender == self.admin_early_unlock, '!admin'  # dev: admin_early_unlock only\r\n    assert _penalty_treasury != empty(address), '!zero'\r\n   \r\n    self.penalty_treasury = _penalty_treasury\r\n    log PenaltyTreasury(_penalty_treasury)\r\n\r\n\r\n@external\r\ndef set_all_unlock():\r\n    \"\"\"\r\n    @notice Deactivates VotingEscrow and allows users to unlock their locks before lock-end. \r\n            New deposits will no longer be accepted.\r\n    @dev Only the admin_unlock_all can execute this function. Make sure there are no rewards for distribution in other contracts.\r\n    \"\"\"\r\n    assert msg.sender == self.admin_unlock_all, '!admin'  # dev: admin_unlock_all only\r\n    self.all_unlock = True\r\n    log TotalUnlock(True)\r\n\r\n\r\n@external\r\n@view\r\ndef get_last_user_slope(addr: address) -> int128:\r\n    \"\"\"\r\n    @notice Get the most recently recorded rate of voting power decrease for `addr`\r\n    @param addr Address of the user wallet\r\n    @return Value of the slope\r\n    \"\"\"\r\n    uepoch: uint256 = self.user_point_epoch[addr]\r\n    return self.user_point_history[addr][uepoch].slope\r\n\r\n\r\n@external\r\n@view\r\ndef user_point_history__ts(_addr: address, _idx: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Get the timestamp for checkpoint `_idx` for `_addr`\r\n    @param _addr User wallet address\r\n    @param _idx User epoch number\r\n    @return Epoch time of the checkpoint\r\n    \"\"\"\r\n    return self.user_point_history[_addr][_idx].ts\r\n\r\n\r\n@external\r\n@view\r\ndef locked__end(_addr: address) -> uint256:\r\n    \"\"\"\r\n    @notice Get timestamp when `_addr`'s lock finishes\r\n    @param _addr User wallet\r\n    @return Epoch time of the lock end\r\n    \"\"\"\r\n    return self.locked[_addr].end\r\n\r\n\r\n@internal\r\ndef _checkpoint(addr: address, old_locked: LockedBalance, new_locked: LockedBalance):\r\n    \"\"\"\r\n    @notice Record global and per-user data to checkpoint\r\n    @param addr User's wallet address. No user checkpoint if 0x0\r\n    @param old_locked Pevious locked amount / end lock time for the user\r\n    @param new_locked New locked amount / end lock time for the user\r\n    \"\"\"\r\n    u_old: Point = empty(Point)\r\n    u_new: Point = empty(Point)\r\n    old_dslope: int128 = 0\r\n    new_dslope: int128 = 0\r\n    _epoch: uint256 = self.epoch\r\n\r\n    if addr != empty(address):\r\n        # Calculate slopes and biases\r\n        # Kept at zero when they have to\r\n        if old_locked.end > block.timestamp and old_locked.amount > 0:\r\n            u_old.slope = old_locked.amount / convert(self.MAXTIME, int128)\r\n            u_old.bias = u_old.slope * convert(old_locked.end - block.timestamp, int128)\r\n        if new_locked.end > block.timestamp and new_locked.amount > 0:\r\n            u_new.slope = new_locked.amount / convert(self.MAXTIME, int128)\r\n            u_new.bias = u_new.slope * convert(new_locked.end - block.timestamp, int128)\r\n\r\n\r\n        # Read values of scheduled changes in the slope\r\n        # old_locked.end can be in the past and in the future\r\n        # new_locked.end can ONLY by in the FUTURE unless everything expired: than zeros\r\n        old_dslope = self.slope_changes[old_locked.end]\r\n        if new_locked.end != 0:\r\n            if new_locked.end == old_locked.end:\r\n                new_dslope = old_dslope\r\n            else:\r\n                new_dslope = self.slope_changes[new_locked.end]\r\n\r\n    last_point: Point = Point({bias: 0, slope: 0, ts: block.timestamp, blk: block.number})\r\n    if _epoch > 0:\r\n        last_point = self.point_history[_epoch]\r\n    last_checkpoint: uint256 = last_point.ts\r\n    # initial_last_point is used for extrapolation to calculate block number\r\n    # (approximately, for *At methods) and save them\r\n    # as we cannot figure that out exactly from inside the contract\r\n    initial_last_point: Point = last_point\r\n    block_slope: uint256 = 0  # dblock/dt\r\n    if block.timestamp > last_point.ts:\r\n        block_slope = MULTIPLIER * (block.number - last_point.blk) / (block.timestamp - last_point.ts)\r\n    # If last point is already recorded in this block, slope=0\r\n    # But that's ok b/c we know the block in such case\r\n\r\n    # Go over weeks to fill history and calculate what the current point is\r\n    t_i: uint256 = (last_checkpoint / WEEK) * WEEK\r\n    for i in range(255):\r\n        # Hopefully it won't happen that this won't get used in 5 years!\r\n        # If it does, users will be able to withdraw but vote weight will be broken\r\n        t_i += WEEK\r\n        d_slope: int128 = 0\r\n        if t_i > block.timestamp:\r\n            t_i = block.timestamp\r\n        else:\r\n            d_slope = self.slope_changes[t_i]\r\n        last_point.bias -= last_point.slope * convert(t_i - last_checkpoint, int128)\r\n        last_point.slope += d_slope\r\n        if last_point.bias < 0:  # This can happen\r\n            last_point.bias = 0\r\n        if last_point.slope < 0:  # This cannot happen - just in case\r\n            last_point.slope = 0\r\n        last_checkpoint = t_i\r\n        last_point.ts = t_i\r\n        last_point.blk = initial_last_point.blk + block_slope * (t_i - initial_last_point.ts) / MULTIPLIER\r\n        _epoch += 1\r\n        if t_i == block.timestamp:\r\n            last_point.blk = block.number\r\n            break\r\n        else:\r\n            self.point_history[_epoch] = last_point\r\n\r\n    self.epoch = _epoch\r\n    # Now point_history is filled until t=now\r\n\r\n    if addr != empty(address):\r\n        # If last point was in this block, the slope change has been applied already\r\n        # But in such case we have 0 slope(s)\r\n        last_point.slope += (u_new.slope - u_old.slope)\r\n        last_point.bias += (u_new.bias - u_old.bias)\r\n        if last_point.slope < 0:\r\n            last_point.slope = 0\r\n        if last_point.bias < 0:\r\n            last_point.bias = 0\r\n\r\n    # Record the changed point into history\r\n    self.point_history[_epoch] = last_point\r\n\r\n    if addr != empty(address):\r\n        # Schedule the slope changes (slope is going down)\r\n        # We subtract new_user_slope from [new_locked.end]\r\n        # and add old_user_slope to [old_locked.end]\r\n        if old_locked.end > block.timestamp:\r\n            # old_dslope was <something> - u_old.slope, so we cancel that\r\n            old_dslope += u_old.slope\r\n            if new_locked.end == old_locked.end:\r\n                old_dslope -= u_new.slope  # It was a new deposit, not extension\r\n            self.slope_changes[old_locked.end] = old_dslope\r\n\r\n        if new_locked.end > block.timestamp:\r\n            if new_locked.end > old_locked.end:\r\n                new_dslope -= u_new.slope  # old slope disappeared at this point\r\n                self.slope_changes[new_locked.end] = new_dslope\r\n            # else: we recorded it already in old_dslope\r\n\r\n        # Now handle user history\r\n        user_epoch: uint256 = self.user_point_epoch[addr] + 1\r\n\r\n        self.user_point_epoch[addr] = user_epoch\r\n        u_new.ts = block.timestamp\r\n        u_new.blk = block.number\r\n        self.user_point_history[addr][user_epoch] = u_new\r\n\r\n\r\n@internal\r\ndef _deposit_for(_addr: address, _value: uint256, unlock_time: uint256, locked_balance: LockedBalance, type: int128):\r\n    \"\"\"\r\n    @notice Deposit and lock tokens for a user\r\n    @param _addr User's wallet address\r\n    @param _value Amount to deposit\r\n    @param unlock_time New time when to unlock the tokens, or 0 if unchanged\r\n    @param locked_balance Previous locked amount / timestamp\r\n    \"\"\"\r\n    # block all new deposits (and extensions) in case of unlocked contract\r\n    assert (not self.all_unlock), \"all unlocked,no sense\"\r\n\r\n    _locked: LockedBalance = locked_balance\r\n    supply_before: uint256 = self.supply\r\n\r\n    self.supply = supply_before + _value\r\n    old_locked: LockedBalance = _locked\r\n    # Adding to existing lock, or if a lock is expired - creating a new one\r\n    _locked.amount += convert(_value, int128)\r\n    if unlock_time != 0:\r\n        _locked.end = unlock_time\r\n    self.locked[_addr] = _locked\r\n\r\n    # Possibilities:\r\n    # Both old_locked.end could be current or expired (>/< block.timestamp)\r\n    # value == 0 (extend lock) or value > 0 (add to lock or extend lock)\r\n    # _locked.end > block.timestamp (always)\r\n    self._checkpoint(_addr, old_locked, _locked)\r\n\r\n    if _value != 0:\r\n        assert ERC20(self.TOKEN).transferFrom(_addr, self, _value, default_return_value=True)\r\n\r\n    log Deposit(_addr, _value, _locked.end, type, block.timestamp)\r\n    log Supply(supply_before, supply_before + _value)\r\n\r\n\r\n@external\r\ndef checkpoint():\r\n    \"\"\"\r\n    @notice Record global data to checkpoint\r\n    \"\"\"\r\n    self._checkpoint(empty(address), empty(LockedBalance), empty(LockedBalance))\r\n\r\n\r\n@external\r\n@nonreentrant(\"lock\")\r\ndef deposit_for(_addr: address, _value: uint256):\r\n    \"\"\"\r\n    @notice Deposit `_value` tokens for `_addr` and add to the lock\r\n    @dev Anyone (even a smart contract) can deposit for someone else, but\r\n         cannot extend their locktime and deposit for a brand new user\r\n    @param _addr User's wallet address\r\n    @param _value Amount to add to user's lock\r\n    \"\"\"\r\n    _locked: LockedBalance = self.locked[_addr]\r\n\r\n    assert _value > 0  # dev: need non-zero value\r\n    assert _locked.amount > 0, \"No existing lock found\"\r\n    assert _locked.end > block.timestamp, \"Cannot add to expired lock. Withdraw\"\r\n\r\n    self._deposit_for(_addr, _value, 0, self.locked[_addr], DEPOSIT_FOR_TYPE)\r\n\r\n\r\n@external\r\n@nonreentrant(\"lock\")\r\ndef create_lock(_value: uint256, _unlock_time: uint256):\r\n    \"\"\"\r\n    @notice Deposit `_value` tokens for `msg.sender` and lock until `_unlock_time`\r\n    @param _value Amount to deposit\r\n    @param _unlock_time Epoch time when tokens unlock, rounded down to whole weeks\r\n    \"\"\"\r\n    self.assert_not_contract(msg.sender)\r\n    unlock_time: uint256 = (_unlock_time / WEEK) * WEEK  # Locktime is rounded down to weeks\r\n    _locked: LockedBalance = self.locked[msg.sender]\r\n\r\n    assert _value > 0  # dev: need non-zero value\r\n    assert _locked.amount == 0, \"Withdraw old tokens first\"\r\n    assert (unlock_time > block.timestamp), \"Can only lock until time in the future\"\r\n    assert (unlock_time <= block.timestamp + self.MAXTIME), \"Voting lock too long\"\r\n\r\n    self._deposit_for(msg.sender, _value, unlock_time, _locked, CREATE_LOCK_TYPE)\r\n\r\n\r\n@external\r\n@nonreentrant(\"lock\")\r\ndef increase_amount(_value: uint256):\r\n    \"\"\"\r\n    @notice Deposit `_value` additional tokens for `msg.sender`\r\n            without modifying the unlock time\r\n    @param _value Amount of tokens to deposit and add to the lock\r\n    \"\"\"\r\n    self.assert_not_contract(msg.sender)\r\n    _locked: LockedBalance = self.locked[msg.sender]\r\n\r\n    assert _value > 0  # dev: need non-zero value\r\n    assert _locked.amount > 0, \"No existing lock found\"\r\n    assert _locked.end > block.timestamp, \"Cannot add to expired lock. Withdraw\"\r\n\r\n    self._deposit_for(msg.sender, _value, 0, _locked, INCREASE_LOCK_AMOUNT)\r\n\r\n\r\n@external\r\n@nonreentrant(\"lock\")\r\ndef increase_unlock_time(_unlock_time: uint256):\r\n    \"\"\"\r\n    @notice Extend the unlock time for `msg.sender` to `_unlock_time`\r\n    @param _unlock_time New epoch time for unlocking\r\n    \"\"\"\r\n    self.assert_not_contract(msg.sender)\r\n    _locked: LockedBalance = self.locked[msg.sender]\r\n    unlock_time: uint256 = (_unlock_time / WEEK) * WEEK  # Locktime is rounded down to weeks\r\n\r\n    assert _locked.end > block.timestamp, \"Lock expired\"\r\n    assert _locked.amount > 0, \"Nothing is locked\"\r\n    assert unlock_time > _locked.end, \"Can only increase lock duration\"\r\n    assert (unlock_time <= block.timestamp + self.MAXTIME), \"Voting lock too long\"\r\n\r\n    self._deposit_for(msg.sender, 0, unlock_time, _locked, INCREASE_UNLOCK_TIME)\r\n\r\n\r\n@external\r\n@nonreentrant(\"lock\")\r\ndef withdraw():\r\n    \"\"\"\r\n    @notice Withdraw all tokens for `msg.sender`\r\n    @dev Only possible if the lock has expired\r\n    \"\"\"\r\n    _locked: LockedBalance = self.locked[msg.sender]\r\n    assert block.timestamp >= _locked.end or self.all_unlock, \"lock !expire or !unlock\"\r\n    value: uint256 = convert(_locked.amount, uint256)\r\n\r\n    old_locked: LockedBalance = _locked\r\n    _locked.end = 0\r\n    _locked.amount = 0\r\n    self.locked[msg.sender] = _locked\r\n    supply_before: uint256 = self.supply\r\n    self.supply = supply_before - value\r\n\r\n    # old_locked can have either expired <= timestamp or zero end\r\n    # _locked has only 0 end\r\n    # Both can have >= 0 amount\r\n    self._checkpoint(msg.sender, old_locked, _locked)\r\n\r\n    assert ERC20(self.TOKEN).transfer(msg.sender, value, default_return_value=True)\r\n\r\n    log Withdraw(msg.sender, value, block.timestamp)\r\n    log Supply(supply_before, supply_before - value)\r\n\r\n\r\n@external\r\n@nonreentrant(\"lock\")\r\ndef withdraw_early():\r\n    \"\"\"\r\n    @notice Withdraws locked tokens for `msg.sender` before lock-end with penalty\r\n    @dev Only possible if `early_unlock` is enabled (true)\r\n    By defualt there is linear formula for calculating penalty. \r\n    In some cases an admin can configure penalty speed using `set_early_unlock_penalty_speed()`\r\n    \r\n    L - lock amount\r\n    k - penalty coefficient, defined by admin (default 1)\r\n    Tleft - left time to unlock\r\n    Tmax - MAXLOCK time\r\n    Penalty amount = L * k * (Tlast / Tmax)\r\n    \"\"\"\r\n    assert(self.early_unlock == True), \"!early unlock\"\r\n\r\n    _locked: LockedBalance = self.locked[msg.sender]\r\n    assert block.timestamp < _locked.end, \"lock expired\"\r\n\r\n    value: uint256 = convert(_locked.amount, uint256)\r\n\r\n    time_left: uint256 = _locked.end - block.timestamp\r\n    \r\n    # to avoid front-run with penalty_k\r\n    penalty_k_: uint256 = 0\r\n    if block.timestamp > self.penalty_upd_ts + PENALTY_COOLDOWN:\r\n        penalty_k_ = self.penalty_k\r\n    else:\r\n        penalty_k_ = self.prev_penalty_k\r\n\r\n    penalty_ratio: uint256 = (time_left * MULTIPLIER / self.MAXTIME) * penalty_k_\r\n    penalty: uint256 = (value * penalty_ratio / MULTIPLIER) / PENALTY_MULTIPLIER    \r\n    if penalty > value:\r\n        penalty = value\r\n    user_amount: uint256 = value - penalty\r\n\r\n    old_locked: LockedBalance = _locked\r\n    _locked.end = 0\r\n    _locked.amount = 0\r\n    self.locked[msg.sender] = _locked\r\n    supply_before: uint256 = self.supply\r\n    self.supply = supply_before - value\r\n\r\n    # old_locked can have either expired <= timestamp or zero end\r\n    # _locked has only 0 end\r\n    # Both can have >= 0 amount\r\n    self._checkpoint(msg.sender, old_locked, _locked)\r\n\r\n    if penalty > 0:\r\n        assert ERC20(self.TOKEN).transfer(self.penalty_treasury, penalty, default_return_value=True)\r\n    if user_amount > 0:\r\n        assert ERC20(self.TOKEN).transfer(msg.sender, user_amount, default_return_value=True)\r\n\r\n    log Withdraw(msg.sender, value, block.timestamp)\r\n    log Supply(supply_before, supply_before - value)\r\n    log WithdrawEarly(msg.sender, penalty, time_left)\r\n\r\n\r\n# The following ERC20/minime-compatible methods are not real balanceOf and supply!\r\n# They measure the weights for the purpose of voting, so they don't represent\r\n# real coins.\r\n\r\n@internal\r\n@view\r\ndef find_block_epoch(_block: uint256, max_epoch: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Binary search to find epoch containing block number\r\n    @param _block Block to find\r\n    @param max_epoch Don't go beyond this epoch\r\n    @return Epoch which contains _block\r\n    \"\"\"\r\n    # Binary search\r\n    _min: uint256 = 0\r\n    _max: uint256 = max_epoch\r\n    for i in range(128):  # Will be always enough for 128-bit numbers\r\n        if _min >= _max:\r\n            break\r\n        _mid: uint256 = (_min + _max + 1) / 2\r\n        if self.point_history[_mid].blk <= _block:\r\n            _min = _mid\r\n        else:\r\n            _max = _mid - 1\r\n    return _min\r\n\r\n@internal\r\n@view\r\ndef find_timestamp_epoch(_timestamp: uint256, max_epoch: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Binary search to find epoch for timestamp\r\n    @param _timestamp timestamp to find\r\n    @param max_epoch Don't go beyond this epoch\r\n    @return Epoch which contains _timestamp\r\n    \"\"\"\r\n    # Binary search\r\n    _min: uint256 = 0\r\n    _max: uint256 = max_epoch\r\n    for i in range(128):  # Will be always enough for 128-bit numbers\r\n        if _min >= _max:\r\n            break\r\n        _mid: uint256 = (_min + _max + 1) / 2\r\n        if self.point_history[_mid].ts <= _timestamp:\r\n            _min = _mid\r\n        else:\r\n            _max = _mid - 1\r\n    return _min\r\n\r\n\r\n@internal\r\n@view\r\ndef find_block_user_epoch(_addr: address, _block: uint256, max_epoch: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Binary search to find epoch for block number\r\n    @param _addr User for which to find user epoch for\r\n    @param _block Block to find\r\n    @param max_epoch Don't go beyond this epoch\r\n    @return Epoch which contains _block\r\n    \"\"\"\r\n    # Binary search\r\n    _min: uint256 = 0\r\n    _max: uint256 = max_epoch\r\n    for i in range(128):  # Will be always enough for 128-bit numbers\r\n        if _min >= _max:\r\n            break\r\n        _mid: uint256 = (_min + _max + 1) / 2\r\n        if self.user_point_history[_addr][_mid].blk <= _block:\r\n            _min = _mid\r\n        else:\r\n            _max = _mid - 1\r\n    return _min\r\n\r\n\r\n@internal\r\n@view\r\ndef find_timestamp_user_epoch(_addr: address, _timestamp: uint256, max_epoch: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Binary search to find user epoch for timestamp\r\n    @param _addr User for which to find user epoch for\r\n    @param _timestamp timestamp to find\r\n    @param max_epoch Don't go beyond this epoch\r\n    @return Epoch which contains _timestamp\r\n    \"\"\"\r\n    # Binary search\r\n    _min: uint256 = 0\r\n    _max: uint256 = max_epoch\r\n    for i in range(128):  # Will be always enough for 128-bit numbers\r\n        if _min >= _max:\r\n            break\r\n        _mid: uint256 = (_min + _max + 1) / 2\r\n        if self.user_point_history[_addr][_mid].ts <= _timestamp:\r\n            _min = _mid\r\n        else:\r\n            _max = _mid - 1\r\n    return _min\r\n\r\n@external\r\n@view\r\ndef balanceOf(addr: address, _t: uint256 = block.timestamp) -> uint256:\r\n    \"\"\"\r\n    @notice Get the current voting power for `msg.sender`\r\n    @dev Adheres to the ERC20 `balanceOf` interface for Aragon compatibility\r\n    @param addr User wallet address\r\n    @param _t Epoch time to return voting power at\r\n    @return User voting power\r\n    \"\"\"\r\n    _epoch: uint256 = 0\r\n    if _t == block.timestamp:\r\n        # No need to do binary search, will always live in current epoch\r\n        _epoch = self.user_point_epoch[addr]\r\n    else:\r\n        _epoch = self.find_timestamp_user_epoch(addr, _t, self.user_point_epoch[addr])\r\n\r\n    if _epoch == 0:\r\n        return 0\r\n    else:\r\n        last_point: Point = self.user_point_history[addr][_epoch]\r\n        last_point.bias -= last_point.slope * convert(_t - last_point.ts, int128)\r\n        if last_point.bias < 0:\r\n            last_point.bias = 0\r\n        return convert(last_point.bias, uint256)\r\n\r\n\r\n@external\r\n@view\r\ndef balanceOfAt(addr: address, _block: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Measure voting power of `addr` at block height `_block`\r\n    @dev Adheres to MiniMe `balanceOfAt` interface: https://github.com/Giveth/minime\r\n    @param addr User's wallet address\r\n    @param _block Block to calculate the voting power at\r\n    @return Voting power\r\n    \"\"\"\r\n    # Copying and pasting totalSupply code because Vyper cannot pass by\r\n    # reference yet\r\n    assert _block <= block.number\r\n\r\n    _user_epoch: uint256 = self.find_block_user_epoch(addr, _block, self.user_point_epoch[addr])\r\n    upoint: Point = self.user_point_history[addr][_user_epoch]\r\n\r\n    max_epoch: uint256 = self.epoch\r\n    _epoch: uint256 = self.find_block_epoch(_block, max_epoch)\r\n    point_0: Point = self.point_history[_epoch]\r\n    d_block: uint256 = 0\r\n    d_t: uint256 = 0\r\n    if _epoch < max_epoch:\r\n        point_1: Point = self.point_history[_epoch + 1]\r\n        d_block = point_1.blk - point_0.blk\r\n        d_t = point_1.ts - point_0.ts\r\n    else:\r\n        d_block = block.number - point_0.blk\r\n        d_t = block.timestamp - point_0.ts\r\n    block_time: uint256 = point_0.ts\r\n    if d_block != 0:\r\n        block_time += d_t * (_block - point_0.blk) / d_block\r\n\r\n    upoint.bias -= upoint.slope * convert(block_time - upoint.ts, int128)\r\n    if upoint.bias >= 0:\r\n        return convert(upoint.bias, uint256)\r\n    else:\r\n        return 0\r\n\r\n\r\n@internal\r\n@view\r\ndef supply_at(point: Point, t: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Calculate total voting power at some point in the past\r\n    @param point The point (bias/slope) to start search from\r\n    @param t Time to calculate the total voting power at\r\n    @return Total voting power at that time\r\n    \"\"\"\r\n    last_point: Point = point\r\n    t_i: uint256 = (last_point.ts / WEEK) * WEEK\r\n    for i in range(255):\r\n        t_i += WEEK\r\n        d_slope: int128 = 0\r\n        if t_i > t:\r\n            t_i = t\r\n        else:\r\n            d_slope = self.slope_changes[t_i]\r\n        last_point.bias -= last_point.slope * convert(t_i - last_point.ts, int128)\r\n        if t_i == t:\r\n            break\r\n        last_point.slope += d_slope\r\n        last_point.ts = t_i\r\n\r\n    if last_point.bias < 0:\r\n        last_point.bias = 0\r\n    return convert(last_point.bias, uint256)\r\n\r\n\r\n@external\r\n@view\r\ndef totalSupply(t: uint256 = block.timestamp) -> uint256:\r\n    \"\"\"\r\n    @notice Calculate total voting power\r\n    @dev Adheres to the ERC20 `totalSupply` interface for Aragon compatibility\r\n    @return Total voting power\r\n    \"\"\"\r\n    _epoch: uint256 = 0\r\n    if t == block.timestamp:\r\n        # No need to do binary search, will always live in current epoch\r\n        _epoch = self.epoch\r\n    else:\r\n        _epoch = self.find_timestamp_epoch(t, self.epoch)\r\n\r\n    if _epoch == 0:\r\n        return 0\r\n    else:\r\n        last_point: Point = self.point_history[_epoch]\r\n        return self.supply_at(last_point, t)\r\n\r\n\r\n@external\r\n@view\r\ndef totalSupplyAt(_block: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Calculate total voting power at some point in the past\r\n    @param _block Block to calculate the total voting power at\r\n    @return Total voting power at `_block`\r\n    \"\"\"\r\n    assert _block <= block.number\r\n    _epoch: uint256 = self.epoch\r\n    target_epoch: uint256 = self.find_block_epoch(_block, _epoch)\r\n\r\n    point: Point = self.point_history[target_epoch]\r\n    dt: uint256 = 0\r\n    if target_epoch < _epoch:\r\n        point_next: Point = self.point_history[target_epoch + 1]\r\n        if point.blk != point_next.blk:\r\n            dt = (_block - point.blk) * (point_next.ts - point.ts) / (point_next.blk - point.blk)\r\n    else:\r\n        if point.blk != block.number:\r\n            dt = (_block - point.blk) * (block.timestamp - point.ts) / (block.number - point.blk)\r\n    # Now dt contains info on how far are we beyond point\r\n\r\n    return self.supply_at(point, point.ts + dt)\r\n\r\n@external\r\n@nonreentrant(\"lock\")\r\ndef claimExternalRewards():\r\n    \"\"\"\r\n    @notice Claims BAL rewards\r\n    @dev Only possible if the TOKEN is Guage contract\r\n    \"\"\"\r\n    BalancerMinter(self.balMinter).mint(self.TOKEN)\r\n    balBalance: uint256 = ERC20(self.balToken).balanceOf(self)\r\n    if balBalance > 0:\r\n        # distributes rewards using rewardDistributor into current week\r\n        if self.rewardReceiver == self.rewardDistributor:\r\n            assert ERC20(self.balToken).approve(self.rewardDistributor, balBalance, default_return_value=True)\r\n            RewardDistributor(self.rewardDistributor).depositToken(self.balToken, balBalance)\r\n        else:\r\n            assert ERC20(self.balToken).transfer(self.rewardReceiver, balBalance, default_return_value=True)\r\n\r\n\r\n@external\r\ndef changeRewardReceiver(newReceiver: address):\r\n    \"\"\"\r\n    @notice Changes the reward receiver address\r\n    @param newReceiver New address to set as the reward receiver\r\n    \"\"\"\r\n    assert msg.sender == self.admin, '!admin'\r\n    assert (self.rewardReceiverChangeable), '!available'\r\n    assert newReceiver != empty(address), '!empty'\r\n\r\n    self.rewardReceiver = newReceiver\r\n    log RewardReceiver(newReceiver)","ABI":"[{\"name\":\"CommitOwnership\",\"inputs\":[{\"name\":\"admin\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"ApplyOwnership\",\"inputs\":[{\"name\":\"admin\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"EarlyUnlock\",\"inputs\":[{\"name\":\"status\",\"type\":\"bool\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"PenaltySpeed\",\"inputs\":[{\"name\":\"penalty_k\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"PenaltyTreasury\",\"inputs\":[{\"name\":\"penalty_treasury\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"TotalUnlock\",\"inputs\":[{\"name\":\"status\",\"type\":\"bool\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"RewardReceiver\",\"inputs\":[{\"name\":\"newReceiver\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Deposit\",\"inputs\":[{\"name\":\"provider\",\"type\":\"address\",\"indexed\":true},{\"name\":\"value\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"locktime\",\"type\":\"uint256\",\"indexed\":true},{\"name\":\"type\",\"type\":\"int128\",\"indexed\":false},{\"name\":\"ts\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Withdraw\",\"inputs\":[{\"name\":\"provider\",\"type\":\"address\",\"indexed\":true},{\"name\":\"value\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"ts\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"WithdrawEarly\",\"inputs\":[{\"name\":\"provider\",\"type\":\"address\",\"indexed\":true},{\"name\":\"penalty\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"time_left\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Supply\",\"inputs\":[{\"name\":\"prevSupply\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"supply\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"initialize\",\"inputs\":[{\"name\":\"_token_addr\",\"type\":\"address\"},{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"},{\"name\":\"_admin_addr\",\"type\":\"address\"},{\"name\":\"_admin_unlock_all\",\"type\":\"address\"},{\"name\":\"_admin_early_unlock\",\"type\":\"address\"},{\"name\":\"_max_time\",\"type\":\"uint256\"},{\"name\":\"_balToken\",\"type\":\"address\"},{\"name\":\"_balMinter\",\"type\":\"address\"},{\"name\":\"_rewardReceiver\",\"type\":\"address\"},{\"name\":\"_rewardReceiverChangeable\",\"type\":\"bool\"},{\"name\":\"_rewardDistributor\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"token\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"name\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"string\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"symbol\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"string\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"decimals\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"commit_transfer_ownership\",\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"apply_transfer_ownership\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"commit_smart_wallet_checker\",\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"apply_smart_wallet_checker\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_early_unlock\",\"inputs\":[{\"name\":\"_early_unlock\",\"type\":\"bool\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_early_unlock_penalty_speed\",\"inputs\":[{\"name\":\"_penalty_k\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_penalty_treasury\",\"inputs\":[{\"name\":\"_penalty_treasury\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_all_unlock\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_last_user_slope\",\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"int128\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"user_point_history__ts\",\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_idx\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"locked__end\",\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"checkpoint\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"deposit_for\",\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"create_lock\",\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_unlock_time\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"increase_amount\",\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"increase_unlock_time\",\"inputs\":[{\"name\":\"_unlock_time\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"withdraw\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"withdraw_early\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"balanceOf\",\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"balanceOf\",\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"_t\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"balanceOfAt\",\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"_block\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"totalSupply\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"totalSupply\",\"inputs\":[{\"name\":\"t\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"totalSupplyAt\",\"inputs\":[{\"name\":\"_block\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"claimExternalRewards\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"changeRewardReceiver\",\"inputs\":[{\"name\":\"newReceiver\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"MAXTIME\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"TOKEN\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"supply\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"locked\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"tuple\",\"components\":[{\"name\":\"amount\",\"type\":\"int128\"},{\"name\":\"end\",\"type\":\"uint256\"}]}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"epoch\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"point_history\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"tuple\",\"components\":[{\"name\":\"bias\",\"type\":\"int128\"},{\"name\":\"slope\",\"type\":\"int128\"},{\"name\":\"ts\",\"type\":\"uint256\"},{\"name\":\"blk\",\"type\":\"uint256\"}]}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"user_point_history\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"},{\"name\":\"arg1\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"tuple\",\"components\":[{\"name\":\"bias\",\"type\":\"int128\"},{\"name\":\"slope\",\"type\":\"int128\"},{\"name\":\"ts\",\"type\":\"uint256\"},{\"name\":\"blk\",\"type\":\"uint256\"}]}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"user_point_epoch\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"slope_changes\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"int128\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"future_smart_wallet_checker\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"smart_wallet_checker\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"admin\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"admin_unlock_all\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"admin_early_unlock\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"future_admin\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"is_initialized\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"early_unlock\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"penalty_k\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"prev_penalty_k\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"penalty_upd_ts\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"penalty_treasury\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"balMinter\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"balToken\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"rewardReceiver\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"rewardReceiverChangeable\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"rewardDistributor\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"all_unlock\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]}]","ContractName":"Voting Escrow","CompilerVersion":"vyper:0.3.7","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]}