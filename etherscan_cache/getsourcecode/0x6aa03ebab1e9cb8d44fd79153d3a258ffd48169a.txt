{"status":"1","message":"OK","result":[{"SourceCode":"# @version 0.3.7\r\n\"\"\"\r\n@title Root Liquidity Gauge Factory\r\n@license MIT\r\n@author Curve Finance\r\n\"\"\"\r\n\r\n\r\ninterface Bridger:\r\n    def check(_addr: address) -> bool: view\r\n    def cost() -> uint256: view\r\n\r\ninterface RootGauge:\r\n    def bridger() -> address: view\r\n    def initialize(_bridger: address, _chain_id: uint256, _relative_weight_cap: uint256): nonpayable\r\n    def transmit_emissions(): payable\r\n\r\n\r\nevent BridgerUpdated:\r\n    _chain_id: indexed(uint256)\r\n    _old_bridger: address\r\n    _new_bridger: address\r\n\r\nevent DeployedGauge:\r\n    _implementation: indexed(address)\r\n    _chain_id: indexed(uint256)\r\n    _vault: address\r\n    _gauge: address\r\n\r\nevent TransferOwnership:\r\n    _old_owner: address\r\n    _new_owner: address\r\n\r\nevent UpdateImplementation:\r\n    _old_implementation: address\r\n    _new_implementation: address\r\n\r\n\r\nget_bridger: public(HashMap[uint256, address])\r\nget_implementation: public(address)\r\n\r\nget_gauge: public(HashMap[uint256, address[max_value(uint256)]])\r\nget_gauge_count: public(HashMap[uint256, uint256])\r\nis_valid_gauge: public(HashMap[address, bool])\r\n\r\nowner: public(address)\r\nfuture_owner: public(address)\r\n\r\n\r\n@external\r\ndef __init__(_owner: address, _implementation: address):\r\n    self.owner = _owner\r\n    log TransferOwnership(empty(address), _owner)\r\n\r\n    self.get_implementation = _implementation\r\n    log UpdateImplementation(empty(address), _implementation)\r\n\r\n\r\n@payable\r\n@external\r\ndef transmit_emissions(_gauge: address):\r\n    \"\"\"\r\n    @notice Call `transmit_emissions` on a root gauge\r\n    @dev Entrypoint to request emissions for a child gauge.\r\n    \"\"\"\r\n    # in most cases this will return True\r\n    # for special bridges *cough cough Multichain, we can only do\r\n    # one bridge per tx, therefore this will verify msg.sender in [tx.origin, self.call_proxy]\r\n    bridger: Bridger = Bridger(RootGauge(_gauge).bridger())\r\n    assert bridger.check(msg.sender)\r\n    cost: uint256 = bridger.cost()\r\n    RootGauge(_gauge).transmit_emissions(value=cost)\r\n\r\n    # refund leftover ETH\r\n    if self.balance != 0:\r\n        raw_call(msg.sender, b\"\", value=self.balance)\r\n\r\n\r\n@payable\r\n@external\r\ndef transmit_emissions_multiple(_gauge_list: DynArray[address, 64]):\r\n    \"\"\"\r\n    @notice Call `transmit_emissions` on a list of root gauges\r\n    @dev Entrypoint to request emissions for a child gauge.\r\n    \"\"\"\r\n    for _gauge in _gauge_list:\r\n        # in most cases this will return True\r\n        # for special bridges *cough cough Multichain, we can only do\r\n        # one bridge per tx, therefore this will verify msg.sender in [tx.origin, self.call_proxy]\r\n        bridger: Bridger = Bridger(RootGauge(_gauge).bridger())\r\n        assert bridger.check(msg.sender)\r\n        cost: uint256 = bridger.cost()\r\n        RootGauge(_gauge).transmit_emissions(value=cost)\r\n\r\n    # refund leftover ETH\r\n    if self.balance != 0:\r\n        raw_call(msg.sender, b\"\", value=self.balance)\r\n\r\n\r\n@payable\r\n@external\r\ndef deploy_gauge(_chain_id: uint256, _vault: address, _relative_weight_cap: uint256) -> address:\r\n    \"\"\"\r\n    @notice Deploy a root liquidity gauge\r\n    @param _chain_id The chain identifier of the counterpart child gauge\r\n    @param _vault The address of the vault\r\n    @param _relative_weight_cap The initial relative weight cap\r\n    \"\"\"\r\n    assert msg.sender == self.owner\r\n\r\n    bridger: address = self.get_bridger[_chain_id]\r\n    assert bridger != empty(address)  # dev: chain id not supported\r\n\r\n    implementation: address = self.get_implementation\r\n    gauge: address = create_minimal_proxy_to(\r\n        implementation,\r\n        value=msg.value,\r\n        salt=keccak256(_abi_encode(_chain_id, _vault))\r\n    )\r\n\r\n    idx: uint256 = self.get_gauge_count[_chain_id]\r\n    self.get_gauge[_chain_id][idx] = gauge\r\n    self.get_gauge_count[_chain_id] = idx + 1\r\n    self.is_valid_gauge[gauge] = True\r\n\r\n    RootGauge(gauge).initialize(bridger, _chain_id, _relative_weight_cap)\r\n\r\n    log DeployedGauge(implementation, _chain_id, _vault, gauge)\r\n    return gauge\r\n\r\n\r\n@external\r\ndef set_bridger(_chain_id: uint256, _bridger: address):\r\n    \"\"\"\r\n    @notice Set the bridger for `_chain_id`\r\n    @param _chain_id The chain identifier to set the bridger for\r\n    @param _bridger The bridger contract to use\r\n    \"\"\"\r\n    assert msg.sender == self.owner  # dev: only owner\r\n\r\n    log BridgerUpdated(_chain_id, self.get_bridger[_chain_id], _bridger)\r\n    self.get_bridger[_chain_id] = _bridger\r\n\r\n\r\n@external\r\ndef set_implementation(_implementation: address):\r\n    \"\"\"\r\n    @notice Set the implementation\r\n    @param _implementation The address of the implementation to use\r\n    \"\"\"\r\n    assert msg.sender == self.owner  # dev: only owner\r\n\r\n    log UpdateImplementation(self.get_implementation, _implementation)\r\n    self.get_implementation = _implementation\r\n\r\n\r\n@external\r\ndef commit_transfer_ownership(_future_owner: address):\r\n    \"\"\"\r\n    @notice Transfer ownership to `_future_owner`\r\n    @param _future_owner The account to commit as the future owner\r\n    \"\"\"\r\n    assert msg.sender == self.owner  # dev: only owner\r\n\r\n    self.future_owner = _future_owner\r\n\r\n\r\n@external\r\ndef accept_transfer_ownership():\r\n    \"\"\"\r\n    @notice Accept the transfer of ownership\r\n    @dev Only the committed future owner can call this function\r\n    \"\"\"\r\n    assert msg.sender == self.future_owner  # dev: only future owner\r\n\r\n    log TransferOwnership(self.owner, msg.sender)\r\n    self.owner = msg.sender","ABI":"[{\"name\":\"BridgerUpdated\",\"inputs\":[{\"name\":\"_chain_id\",\"type\":\"uint256\",\"indexed\":true},{\"name\":\"_old_bridger\",\"type\":\"address\",\"indexed\":false},{\"name\":\"_new_bridger\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"DeployedGauge\",\"inputs\":[{\"name\":\"_implementation\",\"type\":\"address\",\"indexed\":true},{\"name\":\"_chain_id\",\"type\":\"uint256\",\"indexed\":true},{\"name\":\"_vault\",\"type\":\"address\",\"indexed\":false},{\"name\":\"_gauge\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"TransferOwnership\",\"inputs\":[{\"name\":\"_old_owner\",\"type\":\"address\",\"indexed\":false},{\"name\":\"_new_owner\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"UpdateImplementation\",\"inputs\":[{\"name\":\"_old_implementation\",\"type\":\"address\",\"indexed\":false},{\"name\":\"_new_implementation\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_implementation\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"transmit_emissions\",\"inputs\":[{\"name\":\"_gauge\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"transmit_emissions_multiple\",\"inputs\":[{\"name\":\"_gauge_list\",\"type\":\"address[]\"}],\"outputs\":[]},{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"deploy_gauge\",\"inputs\":[{\"name\":\"_chain_id\",\"type\":\"uint256\"},{\"name\":\"_vault\",\"type\":\"address\"},{\"name\":\"_relative_weight_cap\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_bridger\",\"inputs\":[{\"name\":\"_chain_id\",\"type\":\"uint256\"},{\"name\":\"_bridger\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_implementation\",\"inputs\":[{\"name\":\"_implementation\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"commit_transfer_ownership\",\"inputs\":[{\"name\":\"_future_owner\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"accept_transfer_ownership\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_bridger\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_implementation\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_gauge\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"},{\"name\":\"arg1\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_gauge_count\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"is_valid_gauge\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"owner\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"future_owner\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]}]","ContractName":"Root Liquidity Gauge Factory","CompilerVersion":"vyper:0.3.7","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"0000000000000000000000002c3b135cd7dc6c673b358bef214843dab3464278000000000000000000000000260103324e9440c41a7c292d11ff9f87b48cadd6","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]}