{"status":"1","message":"OK","result":[{"SourceCode":"# @version 0.3.7\r\n\r\n\"\"\"\r\n@title Cvg-Finance - Gauge Controller\r\n@license MIT\r\n@notice Controls liquidity gauges and the issuance of coins through the gauges.\r\n\"\"\"\r\n# Adpated fork from: Curve Finance's gauge controller\r\n# Many thanks to Curve Finance\r\n# https://github.com/curvefi/curve-dao-contracts/blob/master/contracts/GaugeController.vy\r\n\r\n# 7 * 86400 seconds - all future times are rounded by week\r\nWEEK: constant(uint256) = 604800\r\n\r\n# Cannot change weight votes more often than once in 10 days\r\nWEIGHT_VOTE_DELAY: constant(uint256) = 10 * 86400\r\n\r\n\r\nstruct Point:\r\n    bias: uint256\r\n    slope: uint256\r\n\r\nstruct VotedSlope:\r\n    slope: uint256\r\n    power: uint256\r\n    end: uint256\r\n\r\nstruct WeightType:\r\n    weight: uint256\r\n    type_weight: uint256\r\n    gauge_type: int128\r\n\r\nstruct TokenData:\r\n    gaugeAddress : address\r\n    nft_slopes : VotedSlope\r\n    last_nft_vote: uint256\r\n\r\nstruct TokenViewInput:\r\n    tokenId : uint256\r\n    gaugeAddresses: DynArray[address, 100]\r\n\r\nstruct TokenViewOutput:\r\n    tokenId : uint256\r\n    nft_power : uint256\r\n    balanceOf  : uint256\r\n    gaugeData: DynArray[TokenData, 100]\r\n\r\n\r\n\r\ninterface CvgRewards:\r\n    def addGauge(gaugeAddress : address):nonpayable\r\n    def removeGauge(gaugeAddress : address):nonpayable\r\n\r\ninterface VotingPowerEscrow:\r\n    def get_last_nft_slope(tokenId: uint256) -> int128: view\r\n    def locked__end(tokenId: uint256) -> uint256: view\r\n    def balanceOf(tokenId: uint256) -> uint256: view\r\n    \r\n\r\ninterface LockingPositionManager:\r\n    def ownerOf(tokenId: uint256) -> address: view\r\n    def unlockingTimestampPerToken(tokenId:uint256) -> uint256:view\r\n\r\ninterface LockingPositionService:\r\n    def isContractLocker(contract: address) -> bool: view\r\n\r\ninterface LockingPositionDelegate:\r\n    def delegatedVeCvg(tokenId: uint256) -> address : view\r\n\r\ninterface CvgControlTower:\r\n    def lockingPositionManager() -> LockingPositionManager: view\r\n    def lockingPositionService() -> LockingPositionService: view\r\n    def lockingPositionDelegate() -> LockingPositionDelegate: view\r\n    def votingPowerEscrow() -> VotingPowerEscrow: view\r\n    def treasuryDao() -> address:view\r\n    def cvgRewards() -> CvgRewards: view\r\n\r\n    def isStakingContract(addr: address) -> bool:view\r\n    \r\nevent CommitOwnership:\r\n    admin: address\r\n\r\nevent ApplyOwnership:\r\n    admin: address\r\n\r\nevent AddType:\r\n    name: String[64]\r\n    type_id: int128\r\n\r\nevent NewTypeWeight:\r\n    type_id: int128\r\n    time: uint256\r\n    weight: uint256\r\n    total_weight: uint256\r\n\r\nevent NewGaugeWeight:\r\n    gauge_address: address\r\n    time: uint256\r\n    weight: uint256\r\n    total_weight: uint256\r\n\r\nevent VoteForGauge:\r\n    time: uint256\r\n    tokenId: uint256\r\n    gauge_addr: address\r\n    weight: uint256\r\n\r\nevent NewGauge:\r\n    addr: address\r\n    gauge_type: int128\r\n    weight: uint256\r\n\r\n\r\nMULTIPLIER: constant(uint256) = 10 ** 18\r\n\r\nadmin: public(address)  # Can and will be a smart contract\r\nfuture_admin: public(address)  # Can and will be a smart contract\r\n\r\ncontrol_tower: public(CvgControlTower) #Control tower\r\n\r\n# Gauge parameters\r\n# All numbers are \"fixed point\" on the basis of 1e18\r\nn_gauge_types: public(int128)\r\nn_gauges: public(int128)\r\ngauge_type_names: public(HashMap[int128, String[64]])\r\n\r\n# Needed for enumeration\r\ngauges: public(address[1000000000])\r\n\r\n# we increment values by 1 prior to storing them here so we can rely on a value\r\n# of zero as meaning the gauge has not been set\r\ngauge_types_: HashMap[address, int128]\r\n\r\nvote_nft_slopes: public(HashMap[uint256, HashMap[address, VotedSlope]])  # nft -> gauge_addr -> VotedSlope\r\nvote_nft_power: public(HashMap[uint256, uint256])  # Total vote power used by nft\r\nlast_nft_vote: public(HashMap[uint256, HashMap[address, uint256]])  # Last nft vote's timestamp for each gauge address\r\n\r\n# Past and scheduled points for gauge weight, sum of weights per type, total weight\r\n# Point is for bias+slope\r\n# changes_* are for changes in slope\r\n# time_* are for the last change timestamp\r\n# timestamps are rounded to whole weeks\r\n\r\npoints_weight: public(HashMap[address, HashMap[uint256, Point]])  # gauge_addr -> time -> Point\r\nchanges_weight: HashMap[address, HashMap[uint256, uint256]]  # gauge_addr -> time -> slope\r\ntime_weight: public(HashMap[address, uint256])  # gauge_addr -> last scheduled time (next week)\r\n\r\npoints_sum: public(HashMap[int128, HashMap[uint256, Point]])  # type_id -> time -> Point\r\nchanges_sum: HashMap[int128, HashMap[uint256, uint256]]  # type_id -> time -> slope\r\ntime_sum: public(uint256[1000000000])  # type_id -> last scheduled time (next week)\r\n\r\npoints_total: public(HashMap[uint256, uint256])  # time -> total weight\r\ntime_total: public(uint256)  # last scheduled time\r\n\r\npoints_type_weight: public(HashMap[int128, HashMap[uint256, uint256]])  # type_id -> time -> type weight\r\ntime_type_weight: public(uint256[1000000000])  # type_id -> last scheduled time (next week)\r\n# @notice Determines whether the vote is locked or not; when it is locked, all the gauges are not available for the vote.\r\nisLock: public(bool)\r\n# @notice Allowed addresses to lock votes.\r\nlockers: public(HashMap[address, bool])\r\n# @notice Determine whether  gauge is killed: killed gauges weigh 0.  Users cannot vote on a gauge but can remove their votes from it.\r\nkilled_gauges: public(HashMap[address, bool])\r\n\r\n# @notice Determining whether a gauge has its vote activated.\r\nvote_activated: public(HashMap[address, bool])\r\n\r\ninitialized: public(bool)\r\n\r\n@external\r\ndef __init__():\r\n    \"\"\"\r\n    @notice Contract constructor.\r\n    @dev The contract has an initializer to prevent the take over of the implementation.\r\n    \"\"\"\r\n    assert self.initialized == False, \"ALREADY_INIT\" #dev: contract is already initialized\r\n    self.initialized = True\r\n\r\n@external\r\ndef initialize(setControlTower: CvgControlTower):\r\n    \"\"\"\r\n    @notice Contract Initializer.\r\n    @param setControlTower Convergence ControlTower contract address\r\n    \"\"\"\r\n    assert self.initialized == False, \"ALREADY_INIT\" #dev: contract is already initialized\r\n    self.initialized = True\r\n    assert setControlTower.address != ZERO_ADDRESS, \"ZERO_ADDRESS\"\r\n\r\n    self.control_tower = setControlTower\r\n    self.admin = msg.sender\r\n    self.time_total = block.timestamp / WEEK * WEEK\r\n\r\n\r\n@external\r\ndef set_lock(isLock: bool):\r\n    \"\"\"\r\n    @notice Lock the vote on all gauges.\r\n    @dev This function is called every cycle by CvgRewards to block votes during the weekly distribution of Cvg.\r\n    @param isLock state of lock\r\n    \"\"\"\r\n    assert self.lockers[msg.sender], \"NOT_LOCKER\"\r\n    self.isLock = isLock\r\n\r\n@external\r\ndef toggle_locker(lockerAddress: address):\r\n    \"\"\"\r\n    @notice Add/remove an address as vote locker.\r\n    @param lockerAddress address to add/remove\r\n    \"\"\"\r\n    assert msg.sender == self.admin, \"NOT_ADMIN\"\r\n    self.lockers[lockerAddress] =  not self.lockers[lockerAddress]\r\n\r\n@external\r\ndef toggle_vote_pause(gaugeAddress: address):\r\n    \"\"\"\r\n    @notice Toggle the vote pause for a gauge.\r\n    @dev Will be used when we deploy a staking contract after the protocol GENESIS.\r\n        The staking contract will be deployed in a paused state, then we will activate votes on it ONLY after cycle N+1\r\n        cycle of deployment to avoid burning CVG rewards.\r\n    @param gaugeAddress address to pause/unpause\r\n    \"\"\"\r\n    assert msg.sender == self.admin, \"NOT_ADMIN\"\r\n    self.vote_activated[gaugeAddress] =  not self.vote_activated[gaugeAddress]\r\n\r\n@external\r\ndef toggle_votes_pause(gaugeAddresses: DynArray[address, 40]):\r\n    \"\"\"\r\n    @notice Toggle the pause state for a list of gauges.\r\n    @param gaugeAddresses list of gauge address.\r\n    \"\"\"\r\n    assert msg.sender == self.admin, \"NOT_ADMIN\"\r\n    for gaugeAddr in gaugeAddresses:\r\n        self.vote_activated[gaugeAddr] =  not self.vote_activated[gaugeAddr]\r\n\r\n@external\r\ndef commit_transfer_ownership(addr: address):\r\n    \"\"\"\r\n    @notice Transfer ownership of GaugeController to `addr`.\r\n    @param addr Address to have ownership transferred to\r\n    \"\"\"\r\n    assert msg.sender == self.admin, \"NOT_ADMIN\"\r\n    self.future_admin = addr\r\n    log CommitOwnership(addr)\r\n\r\n\r\n@external\r\ndef apply_transfer_ownership():\r\n    \"\"\"\r\n    @notice Apply pending ownership transfer.\r\n    \"\"\"\r\n    assert msg.sender == self.future_admin  # dev: future admin only\r\n    _admin: address = self.future_admin\r\n    assert _admin != ZERO_ADDRESS  # dev: admin not set\r\n    self.admin = _admin\r\n    log ApplyOwnership(_admin)\r\n\r\n\r\n@external\r\n@view\r\ndef gauge_types(_addr: address) -> int128:\r\n    \"\"\"\r\n    @notice Get gauge type for address.\r\n    @param _addr Gauge address\r\n    @return Gauge type id\r\n    \"\"\"\r\n    gauge_type: int128 = self.gauge_types_[_addr]\r\n    assert gauge_type != 0\r\n\r\n    return gauge_type - 1\r\n\r\n\r\n@internal\r\ndef _get_type_weight(gauge_type: int128) -> uint256:\r\n    \"\"\"\r\n    @notice Fill historic type weights week-over-week for missed checkins.\r\n            and return the type weight for the future week\r\n    @param gauge_type Gauge type id\r\n    @return Type weight\r\n    \"\"\"\r\n    t: uint256 = self.time_type_weight[gauge_type]\r\n    if t > 0:\r\n        w: uint256 = self.points_type_weight[gauge_type][t]\r\n        for i in range(500):\r\n            if t > block.timestamp:\r\n                break\r\n            t += WEEK\r\n            self.points_type_weight[gauge_type][t] = w\r\n            if t > block.timestamp:\r\n                self.time_type_weight[gauge_type] = t\r\n        return w\r\n    else:\r\n        return 0\r\n\r\n\r\n@internal\r\ndef _get_sum(gauge_type: int128) -> uint256:\r\n    \"\"\"\r\n    @notice Fill sum of gauge weights for the same type week-over-week for.\r\n            missed checkins and return the sum for the future week\r\n    @param gauge_type Gauge type id\r\n    @return Sum of weights\r\n    \"\"\"\r\n    t: uint256 = self.time_sum[gauge_type]\r\n    if t > 0:\r\n        pt: Point = self.points_sum[gauge_type][t]\r\n        for i in range(500):\r\n            if t > block.timestamp:\r\n                break\r\n            t += WEEK\r\n            d_bias: uint256 = pt.slope * WEEK\r\n            if pt.bias > d_bias:\r\n                pt.bias -= d_bias\r\n                d_slope: uint256 = self.changes_sum[gauge_type][t]\r\n                pt.slope -= d_slope\r\n            else:\r\n                pt.bias = 0\r\n                pt.slope = 0\r\n            self.points_sum[gauge_type][t] = pt\r\n            if t > block.timestamp:\r\n                self.time_sum[gauge_type] = t\r\n        return pt.bias\r\n    else:\r\n        return 0\r\n\r\n\r\n@internal\r\ndef _get_total() -> uint256:\r\n    \"\"\"\r\n    @notice Fill historic total weights week-over-week for missed checkins.\r\n            and return the total for the future week\r\n    @return Total weight\r\n    \"\"\"\r\n    t: uint256 = self.time_total\r\n    _n_gauge_types: int128 = self.n_gauge_types\r\n    if t > block.timestamp:\r\n        # If we have already checkpointed - still need to change the value\r\n        t -= WEEK\r\n    pt: uint256 = self.points_total[t]\r\n\r\n    for gauge_type in range(100):\r\n        if gauge_type == _n_gauge_types:\r\n            break\r\n        self._get_sum(gauge_type)\r\n        self._get_type_weight(gauge_type)\r\n\r\n    for i in range(500):\r\n        if t > block.timestamp:\r\n            break\r\n        t += WEEK\r\n        pt = 0\r\n        # Scales as n_types * n_unchecked_weeks (hopefully 1 at most)\r\n        for gauge_type in range(100):\r\n            if gauge_type == _n_gauge_types:\r\n                break\r\n            type_sum: uint256 = self.points_sum[gauge_type][t].bias\r\n            type_weight: uint256 = self.points_type_weight[gauge_type][t]\r\n            pt += type_sum * type_weight\r\n        self.points_total[t] = pt\r\n\r\n        if t > block.timestamp:\r\n            self.time_total = t\r\n    return pt\r\n\r\n\r\n@internal\r\ndef _get_weight(gauge_addr: address) -> uint256:\r\n    \"\"\"\r\n    @notice Fill historic gauge weights week-over-week for missed checkins\r\n            and return the total for the future week.\r\n    @param gauge_addr Address of the gauge\r\n    @return Gauge weight\r\n    \"\"\"\r\n    t: uint256 = self.time_weight[gauge_addr]\r\n    if t > 0:\r\n        pt: Point = self.points_weight[gauge_addr][t]\r\n        for i in range(500):\r\n            if t > block.timestamp:\r\n                break\r\n            t += WEEK\r\n            d_bias: uint256 = pt.slope * WEEK\r\n            if pt.bias > d_bias:\r\n                pt.bias -= d_bias\r\n                d_slope: uint256 = self.changes_weight[gauge_addr][t]\r\n                pt.slope -= d_slope\r\n            else:\r\n                pt.bias = 0\r\n                pt.slope = 0\r\n            self.points_weight[gauge_addr][t] = pt\r\n            if t > block.timestamp:\r\n                self.time_weight[gauge_addr] = t\r\n        return pt.bias\r\n    else:\r\n        return 0\r\n\r\n\r\n@external\r\ndef add_gauge(addr: address, gauge_type: int128, weight: uint256):\r\n    \"\"\"\r\n    @notice Add gauge `addr` of type `gauge_type` with weight `weight`.\r\n    @param addr Gauge address\r\n    @param gauge_type Gauge type\r\n    @param weight Gauge weight\r\n    \"\"\"\r\n    assert msg.sender == self.admin , \"NOT_ADMIN\"\r\n    self._add_gauge(addr, gauge_type, weight)\r\n\r\nstruct AddGauge:\r\n    addr: address\r\n    gauge_type: int128\r\n    weight: uint256\r\n\r\n@external\r\ndef add_gauges(gaugeParams: DynArray[AddGauge,30]):\r\n    assert msg.sender == self.admin , \"NOT_ADMIN\"\r\n    for gauge in gaugeParams:\r\n        self._add_gauge(gauge.addr, gauge.gauge_type, gauge.weight)\r\n\r\n@internal\r\ndef _add_gauge(addr: address, gauge_type: int128, weight: uint256):\r\n    \"\"\"\r\n    @notice Add gauge `addr` of type `gauge_type` with weight `weight`.\r\n    @param addr Gauge address\r\n    @param gauge_type Gauge type\r\n    @param weight Gauge weight\r\n    \"\"\"\r\n    assert (gauge_type >= 0) and (gauge_type < self.n_gauge_types)\r\n    assert self.gauge_types_[addr] == 0 , \"GAUGE_ALREADY_ADDED\" # dev: cannot add the same gauge twice\r\n    assert (self.control_tower).isStakingContract(addr), \"NOT_A_STAKING_CONTRACT\"\r\n\r\n    n: int128 = self.n_gauges\r\n    self.n_gauges = n + 1\r\n    self.gauges[n] = addr\r\n\r\n    self.gauge_types_[addr] = gauge_type + 1\r\n    next_time: uint256 = (block.timestamp + WEEK) / WEEK * WEEK\r\n\r\n    if weight > 0:\r\n        _type_weight: uint256 = self._get_type_weight(gauge_type)\r\n        _old_sum: uint256 = self._get_sum(gauge_type)\r\n        _old_total: uint256 = self._get_total()\r\n\r\n        self.points_sum[gauge_type][next_time].bias = weight + _old_sum\r\n        self.time_sum[gauge_type] = next_time\r\n        self.points_total[next_time] = _old_total + _type_weight * weight\r\n        self.time_total = next_time\r\n\r\n        self.points_weight[addr][next_time].bias = weight\r\n\r\n    if self.time_sum[gauge_type] == 0:\r\n        self.time_sum[gauge_type] = next_time\r\n    self.time_weight[addr] = next_time\r\n\r\n\r\n    self.control_tower.cvgRewards().addGauge(addr)\r\n    log NewGauge(addr, gauge_type, weight)\r\n\r\n\r\n@external\r\ndef checkpoint():\r\n    \"\"\"\r\n    @notice Checkpoint to fill data common for all gauges.\r\n    \"\"\"\r\n    self._get_total()\r\n\r\n\r\n@external\r\ndef checkpoint_gauge(addr: address):\r\n    \"\"\"\r\n    @notice Checkpoint to fill data for both a specific gauge and common for all gauges.\r\n    @param addr Gauge address\r\n    \"\"\"\r\n    self._get_weight(addr)\r\n    self._get_total()\r\n\r\n\r\n@internal\r\n@view\r\ndef _gauge_relative_weight(addr: address, time: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Get Gauge relative weight (not more than 1.0) normalized to 1e18.\r\n            (e.g. 1.0 == 1e18). Inflation which will be received by it is\r\n            inflation_rate * relative_weight / 1e18\r\n    @param addr Gauge address\r\n    @param time Relative weight at the specified timestamp in the past or present\r\n    @return Value of relative weight normalized to 1e18\r\n    \"\"\"\r\n    t: uint256 = time / WEEK * WEEK\r\n    _total_weight: uint256 = self.points_total[t]\r\n\r\n    if _total_weight > 0:\r\n        gauge_type: int128 = self.gauge_types_[addr] - 1\r\n        _type_weight: uint256 = self.points_type_weight[gauge_type][t]\r\n        _gauge_weight: uint256 = self.points_weight[addr][t].bias\r\n        return MULTIPLIER * _type_weight * _gauge_weight / _total_weight\r\n\r\n    else:\r\n        return 0\r\n\r\n\r\n@external\r\n@view\r\ndef gauge_relative_weight(addr: address, time: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Get Gauge relative weight (not more than 1.0) normalized to 1e18.\r\n            (e.g. 1.0 == 1e18). Inflation which will be received by it is\r\n            inflation_rate * relative_weight / 1e18\r\n    @param addr Gauge address\r\n    @param time Relative weight at the specified timestamp in the past or present\r\n    @return Value of relative weight normalized to 1e18\r\n    \"\"\"\r\n    return self._gauge_relative_weight(addr, time)\r\n\r\n\r\n@external\r\ndef gauge_relative_weight_write(addr: address) -> uint256:\r\n    \"\"\"\r\n    @notice Get gauge weight normalized to 1e18 and also fill all the unfilled\r\n            values for type and gauge records.\r\n    @dev Any address can call, however nothing is recorded if the values are filled already.\r\n    @param addr Gauge address\r\n    @return Value of relative weight normalized to 1e18\r\n    \"\"\"\r\n    self._get_weight(addr)\r\n    self._get_total()  # Also calculates get_sum\r\n    return self._gauge_relative_weight(addr, block.timestamp)\r\n\r\n\r\n@external\r\ndef gauge_relative_weight_writes(startId: uint256, length: uint256) :\r\n    \"\"\"\r\n    @notice Get gauge weight normalized to 1e18 and also fill all the unfilled.\r\n            values for type and gauge records\r\n    @dev Any address can call, however nothing is recorded if the values are filled already.\r\n    @param startId  From ID\r\n    @param length Number of gauge to write\r\n    \"\"\"\r\n    for i in range(5000) :\r\n        if length > i :\r\n            self._get_weight(self.gauges[i + startId])\r\n            self._get_total()  # Also calculates get_sum\r\n        else :\r\n            break\r\n\r\n\r\n@internal\r\ndef _change_type_weight(type_id: int128, weight: uint256):\r\n    \"\"\"\r\n    @notice Change type weight.\r\n    @param type_id Type id\r\n    @param weight New type weight\r\n    \"\"\"\r\n    old_weight: uint256 = self._get_type_weight(type_id)\r\n    old_sum: uint256 = self._get_sum(type_id)\r\n    _total_weight: uint256 = self._get_total()\r\n    next_time: uint256 = (block.timestamp + WEEK) / WEEK * WEEK\r\n\r\n    _total_weight = _total_weight + old_sum * weight - old_sum * old_weight\r\n    self.points_total[next_time] = _total_weight\r\n    self.points_type_weight[type_id][next_time] = weight\r\n    self.time_total = next_time\r\n    self.time_type_weight[type_id] = next_time\r\n\r\n    log NewTypeWeight(type_id, next_time, weight, _total_weight)\r\n\r\n\r\n@external\r\ndef add_type(_name: String[64], weight: uint256):\r\n    \"\"\"\r\n    @notice Add gauge type with name `_name` and weight `weight`.\r\n    @param _name Name of gauge type\r\n    @param weight Weight of gauge type\r\n    \"\"\"\r\n    assert msg.sender == self.admin, \"NOT_ADMIN\"\r\n    type_id: int128 = self.n_gauge_types\r\n    self.gauge_type_names[type_id] = _name\r\n    self.n_gauge_types = type_id + 1\r\n    if weight != 0:\r\n        self._change_type_weight(type_id, weight)\r\n        log AddType(_name, type_id)\r\n\r\n\r\n@external\r\ndef change_type_weight(type_id: int128, weight: uint256):\r\n    \"\"\"\r\n    @notice Change gauge type `type_id` weight to `weight`.\r\n    @param type_id Gauge type id\r\n    @param weight New Gauge weight\r\n    \"\"\"\r\n    assert msg.sender == self.admin, \"NOT_ADMIN\"\r\n    self._change_type_weight(type_id, weight)\r\n\r\n\r\n@external\r\ndef kill_gauge(addr: address):\r\n    \"\"\"\r\n    @notice Change weight of gauge `addr` to `weight`.\r\n    @param addr `GaugeController` contract address\r\n    \"\"\"\r\n    assert msg.sender == self.admin, \"NOT_ADMIN\"\r\n    self.killed_gauges[addr] = True\r\n    self.control_tower.cvgRewards().removeGauge(addr)\r\n\r\n\r\n@internal\r\ndef vote_for_gauge_weights(tokenId: uint256, _gauge_addr: address, _user_weight: uint256,_n_gauges: int128, next_time: uint256, lock_end:uint256, slope:uint256):\r\n    \"\"\"\r\n    @notice Assign/update voting power to a gauge to add to its weight, and drag more/less inflation onto it.\r\n    @dev For a killed gauges on.\r\n    @param _gauge_addr Gauge which `msg.sender` votes for\r\n    @param _user_weight Weight for a gauge in bps (units of 0.01%). Minimal is 0.01%. Ignored if 0\r\n    \"\"\"\r\n    \r\n    assert not self.killed_gauges[_gauge_addr] or _user_weight == 0 , \"KILLED_GAUGE\"\r\n    assert self.vote_activated[_gauge_addr], \"VOTE_GAUGE_PAUSED\"\r\n    assert (_user_weight >= 0) and (_user_weight <= 10000), \"You used all your voting power\"\r\n\r\n    if not self.killed_gauges[_gauge_addr]:\r\n        assert block.timestamp >= self.last_nft_vote[tokenId][_gauge_addr] + WEIGHT_VOTE_DELAY, \"Cannot vote so often\"\r\n\r\n    gauge_type: int128 = self.gauge_types_[_gauge_addr] - 1\r\n    assert gauge_type >= 0, \"Gauge not added\"\r\n    # Prepare slopes and biases in memory.\r\n    old_slope: VotedSlope = self.vote_nft_slopes[tokenId][_gauge_addr]\r\n    old_dt: uint256 = 0\r\n    if old_slope.end > next_time:\r\n        old_dt = old_slope.end - next_time\r\n    old_bias: uint256 = old_slope.slope * old_dt\r\n    new_slope: VotedSlope = VotedSlope({\r\n        slope: slope * _user_weight / 10000,\r\n        power: _user_weight,\r\n        end: lock_end,\r\n    })\r\n    new_dt: uint256 = lock_end - next_time  # dev: raises when expired\r\n    new_bias: uint256 = new_slope.slope * new_dt\r\n\r\n    # Check and update powers (weights) used.\r\n    power_used: uint256 = self.vote_nft_power[tokenId]\r\n    power_used = power_used + new_slope.power - old_slope.power\r\n    self.vote_nft_power[tokenId] = power_used\r\n    assert (power_used >= 0) and (power_used <= 10000), 'Used too much power'\r\n\r\n    ## Remove old and schedule new slope changes.\r\n    # Remove slope changes for old slopes.\r\n    # Schedule recording of initial slope for next_time.\r\n    old_weight_bias: uint256 = self._get_weight(_gauge_addr)\r\n    old_weight_slope: uint256 = self.points_weight[_gauge_addr][next_time].slope\r\n    old_sum_bias: uint256 = self._get_sum(gauge_type)\r\n    old_sum_slope: uint256 = self.points_sum[gauge_type][next_time].slope\r\n\r\n    self.points_weight[_gauge_addr][next_time].bias = max(old_weight_bias + new_bias, old_bias) - old_bias\r\n    self.points_sum[gauge_type][next_time].bias = max(old_sum_bias + new_bias, old_bias) - old_bias\r\n    if old_slope.end > next_time:\r\n        self.points_weight[_gauge_addr][next_time].slope = max(old_weight_slope + new_slope.slope, old_slope.slope) - old_slope.slope\r\n        self.points_sum[gauge_type][next_time].slope = max(old_sum_slope + new_slope.slope, old_slope.slope) - old_slope.slope\r\n    else:\r\n        self.points_weight[_gauge_addr][next_time].slope += new_slope.slope\r\n        self.points_sum[gauge_type][next_time].slope += new_slope.slope\r\n    if old_slope.end > block.timestamp:\r\n        # Cancel old slope changes if they still didn't happen\r\n        self.changes_weight[_gauge_addr][old_slope.end] -= old_slope.slope\r\n        self.changes_sum[gauge_type][old_slope.end] -= old_slope.slope\r\n    # Add slope changes for new slopes\r\n    self.changes_weight[_gauge_addr][new_slope.end] += new_slope.slope\r\n    self.changes_sum[gauge_type][new_slope.end] += new_slope.slope\r\n\r\n    self._get_total()\r\n\r\n    self.vote_nft_slopes[tokenId][_gauge_addr] = new_slope\r\n\r\n    # Record last action time\r\n    self.last_nft_vote[tokenId][_gauge_addr] = block.timestamp\r\n\r\n    log VoteForGauge(block.timestamp, tokenId, _gauge_addr, _user_weight)\r\n\r\n\r\n\r\nstruct Votes:\r\n    gauge_address: address\r\n    weight: uint256\r\n\r\nstruct MultiVote:\r\n    tokenId: uint256\r\n    votes: DynArray[Votes, 50]\r\n\r\n@external\r\ndef multi_vote(params: DynArray[MultiVote, 10]):\r\n    \"\"\"\r\n    @notice Allocate votes to several gauges.\r\n    @dev Only a wallet or a WL contract can call the function in order to avoid voting concentration.\r\n    @param params list of vote structure  : [tokenId, [gauge_address, weight]]\r\n    \"\"\"\r\n    lockingManager: LockingPositionManager= self.control_tower.lockingPositionManager()\r\n    lockingDelegate: LockingPositionDelegate = self.control_tower.lockingPositionDelegate()\r\n    escrow: VotingPowerEscrow = self.control_tower.votingPowerEscrow()\r\n    _n_gauges: int128 = self.n_gauges\r\n    assert (msg.sender == tx.origin or self.control_tower.lockingPositionService().isContractLocker(msg.sender)), \"NOT_ALLOWED\"\r\n    assert len(params) != 0, \"NO_VOTES\"\r\n    assert not self.isLock, \"VOTE_LOCKED\"\r\n    next_time: uint256 = (block.timestamp + WEEK) / WEEK * WEEK\r\n\r\n    for param in params:\r\n        tokenId: uint256 = param.tokenId\r\n\r\n        # Check if the sender is the owner or a delegatee for the token.\r\n        assert (lockingManager.ownerOf(tokenId) == msg.sender or lockingDelegate.delegatedVeCvg(tokenId) == msg.sender), \"TOKEN_NOT_OWNED\"\r\n        # Check whether the token is time-locked: a token can be time-locked by its owner to protect a potential buyer from a malicious front run.\r\n        assert (lockingManager.unlockingTimestampPerToken(tokenId) < block.timestamp), \"TOKEN_TIMELOCKED\"\r\n        slope: uint256 = convert(escrow.get_last_nft_slope(tokenId), uint256)\r\n        lock_end: uint256 = escrow.locked__end(tokenId)\r\n        assert lock_end > next_time, \"Your token lock expires too soon\"\r\n\r\n        for vote in param.votes:\r\n            self.vote_for_gauge_weights(tokenId, vote.gauge_address , vote.weight, _n_gauges, next_time, lock_end, slope)\r\n\r\n@external\r\ndef simple_vote(tokenId: uint256, _gauge_addr: address, _user_weight: uint256):\r\n    \"\"\"\r\n    @notice Allocate vote to one gauge.\r\n    @dev Only a wallet or a WL contract can call the function in order to avoid voting concentration.\r\n    @param tokenId source token\r\n    @param _gauge_addr  gauge address\r\n    @param _user_weight source weight to allocate\r\n    \"\"\"\r\n    lockingManager: LockingPositionManager= self.control_tower.lockingPositionManager()\r\n    lockingDelegate: LockingPositionDelegate = self.control_tower.lockingPositionDelegate()\r\n    escrow: VotingPowerEscrow = self.control_tower.votingPowerEscrow()\r\n    _n_gauges: int128 = self.n_gauges\r\n\r\n    assert (msg.sender == tx.origin or self.control_tower.lockingPositionService().isContractLocker(msg.sender)), \"NOT_ALLOWED\"\r\n    assert not self.isLock, \"VOTE_LOCKED\"\r\n    next_time: uint256 = (block.timestamp + WEEK) / WEEK * WEEK\r\n    # Check if the sender is the owner or a delegatee for the token.\r\n    assert (lockingManager.ownerOf(tokenId) == msg.sender or lockingDelegate.delegatedVeCvg(tokenId) == msg.sender), \"TOKEN_NOT_OWNED\"\r\n    # Check whether the token is time-locked: a token can be time-locked by its owner to protect a potential buyer from a malicious front run.\r\n    assert (lockingManager.unlockingTimestampPerToken(tokenId) < block.timestamp), \"TOKEN_TIMELOCKED\"\r\n    slope: uint256 = convert(escrow.get_last_nft_slope(tokenId), uint256)\r\n    lock_end: uint256 = escrow.locked__end(tokenId)\r\n    assert lock_end > next_time, \"Your token lock expires too soon\"\r\n\r\n    self.vote_for_gauge_weights(tokenId, _gauge_addr , _user_weight, _n_gauges, next_time, lock_end, slope)\r\n\r\n@external\r\n@view\r\ndef get_gauge_weight_normal(addr: address) -> uint256:\r\n    \"\"\"\r\n    @notice Get current gauge weight.\r\n    @param addr Gauge address\r\n    @return Gauge weight\r\n    \"\"\"\r\n    return self.points_weight[addr][self.time_weight[addr]].bias\r\n\r\n\r\n@external\r\n@view\r\ndef get_gauge_weight(addr: address) -> uint256:\r\n    \"\"\"\r\n    @notice Get current gauge weight weighted by the gauge type.\r\n    @param addr Gauge address\r\n    @return Gauge weight\r\n    \"\"\"\r\n    typeId: int128 = self.gauge_types_[addr] - 1 \r\n    typeWeight: uint256 = self.points_type_weight[typeId][self.time_type_weight[typeId]]\r\n    return self.points_weight[addr][self.time_weight[addr]].bias * typeWeight\r\n\r\n\r\n\r\n@external\r\n@view\r\ndef get_gauge_weights(addrs: DynArray[address, 100]) -> (DynArray[uint256, 100], uint256):\r\n    \"\"\"\r\n    @notice Get several gauge weights weighted by the gauge type.\r\n    @param addrs Gauge addresses\r\n    @return Gauge weights \r\n    @return Total weight in gauges\r\n    \"\"\"\r\n\r\n    weights: DynArray[uint256, 100] = []\r\n    for addr in addrs:\r\n        typeId: int128 = self.gauge_types_[addr] - 1 \r\n        typeWeight: uint256 = self.points_type_weight[typeId][self.time_type_weight[typeId]]\r\n        weights.append(self.points_weight[addr][self.time_weight[addr]].bias * typeWeight)\r\n    return (weights, self.points_total[self.time_total])\r\n\r\n@external\r\n@view\r\ndef get_gauge_weights_and_types(addrs: DynArray[address, 100]) -> DynArray[WeightType, 100]:\r\n    \"\"\"\r\n    @notice Get several gauge weights weighted by the gauge type.\r\n    @param addrs Gauge addresses\r\n    @return Gauge weights and types\r\n    \"\"\"\r\n    weights_type: DynArray[WeightType, 100] = []\r\n    for addr in addrs:\r\n        typeId: int128 = self.gauge_types_[addr] - 1 \r\n        typeWeight: uint256 = self.points_type_weight[typeId][self.time_type_weight[typeId]]\r\n        weights_type.append(WeightType({weight :self.points_weight[addr][self.time_weight[addr]].bias * typeWeight, type_weight: typeWeight, gauge_type : typeId }))\r\n    return weights_type\r\n\r\n\r\n@external\r\n@view\r\ndef get_nft_datas(inputParams: DynArray[TokenViewInput, 50]) -> DynArray[TokenViewOutput, 50]:\r\n    \"\"\"\r\n    @notice View function to get token weights deployed on each gauges.\r\n    @param inputParams Gauge addresses\r\n    @return nft data params \r\n    \"\"\"\r\n    escrow: VotingPowerEscrow = self.control_tower.votingPowerEscrow()\r\n    result: DynArray[TokenViewOutput, 10] = []\r\n    for inputParam in inputParams:\r\n        token_id : uint256 = inputParam.tokenId\r\n        tokenData: DynArray[TokenData, 100] = []\r\n        for gauge_address in inputParam.gaugeAddresses:\r\n            tokenData.append(TokenData({\r\n                gaugeAddress : gauge_address,\r\n                nft_slopes : self.vote_nft_slopes[token_id][gauge_address],\r\n                last_nft_vote: self.last_nft_vote[token_id][gauge_address]\r\n            }))\r\n        result.append(TokenViewOutput({\r\n            tokenId : token_id,\r\n            nft_power: self.vote_nft_power[token_id],\r\n            balanceOf: escrow.balanceOf(token_id),\r\n            gaugeData: tokenData\r\n        }))\r\n    return result        \r\n\r\n\r\n@external\r\n@view\r\ndef get_type_weight(type_id: int128) -> uint256:\r\n    \"\"\"\r\n    @notice Get current type weight.\r\n    @param type_id Type id\r\n    @return Type weight\r\n    \"\"\"\r\n    return self.points_type_weight[type_id][self.time_type_weight[type_id]]\r\n\r\n\r\n@external\r\n@view\r\ndef get_total_weight() -> uint256:\r\n    \"\"\"\r\n    @notice Get current total (type-weighted) weight.\r\n    @return Total weight\r\n    \"\"\"\r\n    return self.points_total[self.time_total]\r\n\r\n\r\n@external\r\n@view\r\ndef get_weights_sum_per_type(type_id: int128) -> uint256:\r\n    \"\"\"\r\n    @notice Get sum of gauge weights per type.\r\n    @param type_id Type id\r\n    @return Sum of gauge weights\r\n    \"\"\"\r\n    return self.points_sum[type_id][self.time_sum[type_id]].bias","ABI":"[{\"name\":\"CommitOwnership\",\"inputs\":[{\"name\":\"admin\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"ApplyOwnership\",\"inputs\":[{\"name\":\"admin\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"AddType\",\"inputs\":[{\"name\":\"name\",\"type\":\"string\",\"indexed\":false},{\"name\":\"type_id\",\"type\":\"int128\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"NewTypeWeight\",\"inputs\":[{\"name\":\"type_id\",\"type\":\"int128\",\"indexed\":false},{\"name\":\"time\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"weight\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"total_weight\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"NewGaugeWeight\",\"inputs\":[{\"name\":\"gauge_address\",\"type\":\"address\",\"indexed\":false},{\"name\":\"time\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"weight\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"total_weight\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"VoteForGauge\",\"inputs\":[{\"name\":\"time\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"tokenId\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"gauge_addr\",\"type\":\"address\",\"indexed\":false},{\"name\":\"weight\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"NewGauge\",\"inputs\":[{\"name\":\"addr\",\"type\":\"address\",\"indexed\":false},{\"name\":\"gauge_type\",\"type\":\"int128\",\"indexed\":false},{\"name\":\"weight\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"initialize\",\"inputs\":[{\"name\":\"setControlTower\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_lock\",\"inputs\":[{\"name\":\"isLock\",\"type\":\"bool\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"toggle_locker\",\"inputs\":[{\"name\":\"lockerAddress\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"toggle_vote_pause\",\"inputs\":[{\"name\":\"gaugeAddress\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"toggle_votes_pause\",\"inputs\":[{\"name\":\"gaugeAddresses\",\"type\":\"address[]\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"commit_transfer_ownership\",\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"apply_transfer_ownership\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"gauge_types\",\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"int128\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"add_gauge\",\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"gauge_type\",\"type\":\"int128\"},{\"name\":\"weight\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"add_gauges\",\"inputs\":[{\"name\":\"gaugeParams\",\"type\":\"tuple[]\",\"components\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"gauge_type\",\"type\":\"int128\"},{\"name\":\"weight\",\"type\":\"uint256\"}]}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"checkpoint\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"checkpoint_gauge\",\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"gauge_relative_weight\",\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"time\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"gauge_relative_weight_write\",\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"gauge_relative_weight_writes\",\"inputs\":[{\"name\":\"startId\",\"type\":\"uint256\"},{\"name\":\"length\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"add_type\",\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"weight\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"change_type_weight\",\"inputs\":[{\"name\":\"type_id\",\"type\":\"int128\"},{\"name\":\"weight\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"kill_gauge\",\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"multi_vote\",\"inputs\":[{\"name\":\"params\",\"type\":\"tuple[]\",\"components\":[{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"votes\",\"type\":\"tuple[]\",\"components\":[{\"name\":\"gauge_address\",\"type\":\"address\"},{\"name\":\"weight\",\"type\":\"uint256\"}]}]}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"simple_vote\",\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"_gauge_addr\",\"type\":\"address\"},{\"name\":\"_user_weight\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_gauge_weight_normal\",\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_gauge_weight\",\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_gauge_weights\",\"inputs\":[{\"name\":\"addrs\",\"type\":\"address[]\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_gauge_weights_and_types\",\"inputs\":[{\"name\":\"addrs\",\"type\":\"address[]\"}],\"outputs\":[{\"name\":\"\",\"type\":\"tuple[]\",\"components\":[{\"name\":\"weight\",\"type\":\"uint256\"},{\"name\":\"type_weight\",\"type\":\"uint256\"},{\"name\":\"gauge_type\",\"type\":\"int128\"}]}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_nft_datas\",\"inputs\":[{\"name\":\"inputParams\",\"type\":\"tuple[]\",\"components\":[{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"gaugeAddresses\",\"type\":\"address[]\"}]}],\"outputs\":[{\"name\":\"\",\"type\":\"tuple[]\",\"components\":[{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"nft_power\",\"type\":\"uint256\"},{\"name\":\"balanceOf\",\"type\":\"uint256\"},{\"name\":\"gaugeData\",\"type\":\"tuple[]\",\"components\":[{\"name\":\"gaugeAddress\",\"type\":\"address\"},{\"name\":\"nft_slopes\",\"type\":\"tuple\",\"components\":[{\"name\":\"slope\",\"type\":\"uint256\"},{\"name\":\"power\",\"type\":\"uint256\"},{\"name\":\"end\",\"type\":\"uint256\"}]},{\"name\":\"last_nft_vote\",\"type\":\"uint256\"}]}]}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_type_weight\",\"inputs\":[{\"name\":\"type_id\",\"type\":\"int128\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_total_weight\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_weights_sum_per_type\",\"inputs\":[{\"name\":\"type_id\",\"type\":\"int128\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"admin\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"future_admin\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"control_tower\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"n_gauge_types\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"int128\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"n_gauges\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"int128\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"gauge_type_names\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"int128\"}],\"outputs\":[{\"name\":\"\",\"type\":\"string\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"gauges\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"vote_nft_slopes\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"},{\"name\":\"arg1\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"tuple\",\"components\":[{\"name\":\"slope\",\"type\":\"uint256\"},{\"name\":\"power\",\"type\":\"uint256\"},{\"name\":\"end\",\"type\":\"uint256\"}]}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"vote_nft_power\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"last_nft_vote\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"},{\"name\":\"arg1\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"points_weight\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"},{\"name\":\"arg1\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"tuple\",\"components\":[{\"name\":\"bias\",\"type\":\"uint256\"},{\"name\":\"slope\",\"type\":\"uint256\"}]}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"time_weight\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"points_sum\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"int128\"},{\"name\":\"arg1\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"tuple\",\"components\":[{\"name\":\"bias\",\"type\":\"uint256\"},{\"name\":\"slope\",\"type\":\"uint256\"}]}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"time_sum\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"points_total\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"time_total\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"points_type_weight\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"int128\"},{\"name\":\"arg1\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"time_type_weight\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"isLock\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"lockers\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"killed_gauges\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"vote_activated\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"initialized\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]}]","ContractName":"Cvg-Finance - Gauge Controller","CompilerVersion":"vyper:0.3.7","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]}