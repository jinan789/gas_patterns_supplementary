{"status":"1","message":"OK","result":[{"SourceCode":"# @version 0.3.10\r\n\"\"\"\r\n@title Gauge controller\r\n@author Yearn Finance\r\n@license GNU AGPLv3\r\n@notice\r\n    Controls gauge emissions as defined in YIP-73.\r\n    - Gauges can be whitelisted, making them eligible for emissions in future epochs\r\n    - Accounts with a vote weight can distribute their weight over whitelisted gauges every epoch\r\n    - At the end of the epoch the tokens are minted and distributed according to their received vote weights\r\n    - Governance can reserve a percentage of emissions to specific gauges, prior to any votes\r\n    - These reserved emissions are taken out of the pool of votable emissions\r\n    - Votes can be blank. Emissions due to blank votes are partially burned and partially\r\n        reallocated to next epoch\r\n\"\"\"\r\n\r\nfrom vyper.interfaces import ERC20\r\n\r\ninterface Minter:\r\n    def mint(_epoch: uint256) -> uint256: nonpayable\r\n\r\ninterface Burner:\r\n    def burn(_epoch: uint256, _amount: uint256): nonpayable\r\n\r\ninterface Measure:\r\n    def total_vote_weight() -> uint256: view\r\n    def vote_weight(_account: address) -> uint256: view\r\n\r\ngenesis: public(immutable(uint256))\r\ntoken: public(immutable(ERC20))\r\nmanagement: public(address)\r\npending_management: public(address)\r\nwhitelister: public(address)\r\nlegacy_operator: public(address)\r\nmeasure: public(Measure)\r\nminter: public(Minter)\r\nburner: public(Burner)\r\n\r\npacked_emission: uint256 # (epoch, global cumulative emission, global current emission)\r\nblank_emission: public(uint256)\r\npacked_epoch_emission: HashMap[uint256, uint256] # epoch => (_, emission, reserved)\r\npacked_gauge_emission: HashMap[address, uint256] # gauge => (epoch, cumulative emission, current emission)\r\ngauge_claimed: public(HashMap[address, uint256]) # gauge => claimed\r\n\r\nblank_burn_points: public(uint256)\r\nreserved_points: public(uint256)\r\npacked_gauge_reserved: HashMap[address, uint256] # gauge => (_, points, last global cumulative emission)\r\ngauge_whitelisted: public(HashMap[address, bool]) # gauge => whitelisted?\r\nlegacy_gauge: public(HashMap[address, bool]) # gauge => legacy?\r\n\r\nvotes: public(HashMap[uint256, uint256]) # epoch => total votes\r\nvotes_user: public(HashMap[address, HashMap[uint256, uint256]]) # user => epoch => votes\r\ngauge_votes: public(HashMap[uint256, HashMap[address, uint256]]) # epoch => gauge => votes\r\ngauge_votes_user: public(HashMap[address, HashMap[uint256, HashMap[address, uint256]]]) # user => epoch => gauge => votes\r\n\r\nevent NewEpoch:\r\n    epoch: uint256\r\n    emission: uint256\r\n    reserved: uint256\r\n    burned: uint256\r\n    blank: uint256\r\n\r\nevent Claim:\r\n    gauge: indexed(address)\r\n    amount: uint256\r\n\r\nevent Vote:\r\n    epoch: uint256\r\n    account: indexed(address)\r\n    gauge: indexed(address)\r\n    votes: uint256\r\n\r\nevent Whitelist:\r\n    gauge: indexed(address)\r\n    whitelisted: bool\r\n\r\nevent SetReservedPoints:\r\n    gauge: indexed(address)\r\n    points: uint256\r\n\r\nevent SetBlankBurnPoints:\r\n    points: uint256\r\n\r\nevent SetLegacyGauge:\r\n    gauge: indexed(address)\r\n    legacy: bool\r\n\r\nevent SetWhitelister:\r\n    whitelister: address\r\n\r\nevent SetLegacyOperator:\r\n    operator: address\r\n\r\nevent SetMeasure:\r\n    measure: address\r\n\r\nevent SetMinter:\r\n    minter: address\r\n\r\nevent SetBurner:\r\n    burner: address\r\n\r\nevent PendingManagement:\r\n    management: indexed(address)\r\n\r\nevent SetManagement:\r\n    management: indexed(address)\r\n\r\nWEEK_LENGTH: constant(uint256) = 7 * 24 * 60 * 60\r\nEPOCH_LENGTH: constant(uint256) = 2 * WEEK_LENGTH\r\nPOINTS_SCALE: constant(uint256) = 10_000\r\n\r\nMASK: constant(uint256) = 2**112 - 1\r\nEPOCH_MASK: constant(uint256) = 2**32 - 1\r\n\r\n@external\r\ndef __init__(_genesis: uint256, _token: address, _measure: address, _minter: address, _burner: address):\r\n    \"\"\"\r\n    @notice Constructor\r\n    @param _genesis Genesis timestamp\r\n    @param _token Reward token address\r\n    @param _measure Vote weight measure\r\n    @param _minter Reward token minter\r\n    @param _burner Reward token burner\r\n    @dev Genesis should be picked at least one full epoch in the past\r\n    \"\"\"\r\n    genesis = _genesis\r\n    token = ERC20(_token)\r\n    self.management = msg.sender\r\n    self.whitelister = msg.sender\r\n    self.legacy_operator = msg.sender\r\n    self.measure = Measure(_measure)\r\n    self.minter = Minter(_minter)\r\n    self.burner = Burner(_burner)\r\n\r\n    epoch: uint256 = self._epoch()\r\n    self.packed_emission = self._pack(epoch - 1, 0, 0)\r\n\r\n@external\r\n@view\r\ndef epoch() -> uint256:\r\n    \"\"\"\r\n    @notice Get the current epoch\r\n    @return Current epoch\r\n    \"\"\"\r\n    return self._epoch()\r\n\r\n@internal\r\n@view\r\ndef _epoch() -> uint256:\r\n    return (block.timestamp - genesis) / EPOCH_LENGTH\r\n\r\n@external\r\n@view\r\ndef vote_open() -> bool:\r\n    \"\"\"\r\n    @notice Check whether the vote is currently open\r\n    @return True: vote is open, False: vote is closed\r\n    \"\"\"\r\n    return self._vote_open()\r\n\r\n@internal\r\n@view\r\ndef _vote_open() -> bool:\r\n    return (block.timestamp - genesis) % EPOCH_LENGTH >= WEEK_LENGTH\r\n\r\n@external\r\n@view\r\ndef votes_available(_account: address) -> uint256:\r\n    \"\"\"\r\n    @notice Get amount of votes still available\r\n    @param _account Account to check for\r\n    @return Amount of votes still available\r\n    \"\"\"\r\n    total: uint256 = self.measure.vote_weight(_account)\r\n    epoch: uint256 = self._epoch()\r\n    return total - self.votes_user[_account][epoch]\r\n\r\n@external\r\n@view\r\ndef emission() -> (uint256, uint256, uint256):\r\n    \"\"\"\r\n    @notice Get overall emission information\r\n    @return Tuple with:\r\n        - Last finalized epoch. At most one behind the current epoch\r\n        - Cumulative emission for all gauges until the last finalized epoch\r\n        - Emission for all gauges in the last finalized epoch\r\n    \"\"\"\r\n    return self._unpack(self.packed_emission)\r\n\r\n@external\r\n@view\r\ndef epoch_emission(_epoch: uint256) -> (uint256, uint256):\r\n    \"\"\"\r\n    @notice Get emission information for a specific epoch\r\n    @param _epoch Epoch\r\n    @return Tuple with:\r\n        - Emission for all gauges in the epoch\r\n        - Reserved emission in the epoch\r\n    @dev The total emission is inclusive of the reserved emission\r\n    \"\"\"\r\n    return self._unpack_two(self.packed_epoch_emission[_epoch])\r\n\r\n@external\r\n@view\r\ndef gauge_emission(_gauge: address) -> (uint256, uint256, uint256):\r\n    \"\"\"\r\n    @notice Get emission information for a specific gauge\r\n    @param _gauge Gauge address\r\n    @return Tuple with:\r\n        - Last updated epoch. At most equal to the last finalized epoch\r\n        - Cumulative emission for this gauge until the last updated epoch\r\n        - Emission for this gauge in the last finalized epoch\r\n    \"\"\"\r\n    return self._unpack(self.packed_gauge_emission[_gauge])\r\n\r\n@external\r\n@view\r\ndef gauge_reserved_points(_gauge: address) -> uint256:\r\n    \"\"\"\r\n    @notice Get reserved points for a gauge\r\n    @param _gauge Gauge address\r\n    @return Reserved points (bps)\r\n    @dev Gauges with reserved emissions receive a fixed percentage\r\n        of all the emissions, which is subtracted from the available\r\n        emissions for votes\r\n    \"\"\"\r\n    return self._unpack_two(self.packed_gauge_reserved[_gauge])[0]\r\n\r\n@external\r\n@view\r\ndef gauge_reserved_last_cumulative(_gauge: address) -> uint256:\r\n    \"\"\"\r\n    @notice Get gauge's last known overall cumulative emissions\r\n    @param _gauge Gauge address\r\n    @return Last known overall cumulative emission\r\n    @dev Used to fast-forward gauge emissions without having to iterate\r\n    \"\"\"\r\n    return self._unpack_two(self.packed_gauge_reserved[_gauge])[1]\r\n\r\n@external\r\ndef vote(_gauges: DynArray[address, 32], _votes: DynArray[uint256, 32]):\r\n    \"\"\"\r\n    @notice Vote for specific gauges\r\n    @param _gauges Gauge addresses\r\n    @param _votes Votes as a fraction of users total vote weight (bps)\r\n    @dev Can be called multiple times\r\n    @dev Votes are additive, they cant be undone\r\n    @dev Votes can be blank by using the zero address\r\n    \"\"\"\r\n    assert len(_gauges) == len(_votes)\r\n    assert self._vote_open()\r\n\r\n    assert self._update_emission()\r\n    available: uint256 = self.measure.vote_weight(msg.sender)\r\n    epoch: uint256 = self._epoch()\r\n\r\n    used: uint256 = 0\r\n    for i in range(32):\r\n        if i == len(_gauges):\r\n            break\r\n        gauge: address = _gauges[i]\r\n        votes: uint256 = available * _votes[i] / POINTS_SCALE\r\n\r\n        if gauge != empty(address):\r\n            assert self.gauge_whitelisted[gauge]\r\n            self._update_gauge_emission(gauge)\r\n\r\n        self.gauge_votes[epoch][gauge] += votes\r\n        self.gauge_votes_user[msg.sender][epoch][gauge] += votes\r\n        used += votes\r\n        log Vote(epoch, msg.sender, gauge, votes)\r\n    assert used > 0\r\n    self.votes[epoch] += used\r\n\r\n    used += self.votes_user[msg.sender][epoch]\r\n    assert used <= available\r\n    self.votes_user[msg.sender][epoch] = used\r\n\r\n@external\r\ndef claim(_gauge: address = empty(address), _recipient: address = empty(address)) -> (uint256, uint256, uint256):\r\n    \"\"\"\r\n    @notice Claim rewards for distribution by a gauge\r\n    @param _gauge Gauge address to claim for\r\n    @param _recipient Recipient of legacy gauge rewards\r\n    @dev Certain gauges are considered legacy, for which claiming is permissioned\r\n    \"\"\"\r\n    gauge: address = _gauge\r\n    if _gauge == empty(address):\r\n        gauge = msg.sender\r\n    recipient: address = gauge\r\n\r\n    if self.legacy_gauge[gauge]:\r\n        assert msg.sender == self.legacy_operator\r\n        assert _recipient != empty(address)\r\n        recipient = _recipient\r\n\r\n    assert self._update_emission()\r\n    gauge_epoch: uint256 = 0\r\n    cumulative: uint256 = 0\r\n    current: uint256 = 0\r\n    gauge_epoch, cumulative, current = self._update_gauge_emission(gauge)\r\n    claimed: uint256 = self.gauge_claimed[gauge]\r\n    claim: uint256 = cumulative - claimed\r\n    if claim > 0:\r\n        self.gauge_claimed[gauge] = cumulative\r\n        assert token.transfer(recipient, claim, default_return_value=True)\r\n        log Claim(_gauge, claim)\r\n\r\n    epoch_start: uint256 = genesis + self._epoch() * EPOCH_LENGTH\r\n    return cumulative, current, epoch_start\r\n\r\n@external\r\ndef update_emission():\r\n    \"\"\"\r\n    @notice Update overall emissions\r\n    @dev Should be called by anyone to catch-up overall emissions if no \r\n        calls to this contract have been made for more than a full epoch\r\n    \"\"\"\r\n    for _ in range(32):\r\n        if self._update_emission():\r\n            return\r\n\r\n@external\r\ndef whitelist(_gauge: address, _whitelisted: bool):\r\n    \"\"\"\r\n    @notice Add or remove a gauge to the whitelist\r\n    @param _gauge Gauge address\r\n    @param _whitelisted True: add to whitelist, False: remove from whitelist\r\n    @dev Only callable by the whitelister\r\n    \"\"\"\r\n    assert msg.sender == self.whitelister\r\n    assert _gauge != empty(address)\r\n    assert self._update_emission()\r\n\r\n    if _whitelisted == self.gauge_whitelisted[_gauge]:\r\n        return\r\n\r\n    if not _whitelisted:\r\n        self._update_gauge_emission(_gauge)\r\n        points: uint256 = 0\r\n        last: uint256 = 0\r\n        points, last = self._unpack_two(self.packed_gauge_reserved[_gauge])\r\n        if points > 0:\r\n            self.reserved_points -= points\r\n            self.packed_gauge_reserved[_gauge] = 0\r\n    self.gauge_whitelisted[_gauge] = _whitelisted\r\n    log Whitelist(_gauge, _whitelisted)\r\n\r\n@external\r\ndef set_reserved_points(_gauge: address, _points: uint256):\r\n    \"\"\"\r\n    @notice Set the fraction of reserved emissions for a gauge\r\n    @param _gauge Gauge address\r\n    @param _points Reserved emission fraction (bps)\r\n    @dev Only callable by management\r\n    \"\"\"\r\n    assert msg.sender == self.management\r\n    assert self.gauge_whitelisted[_gauge]\r\n    assert self._update_emission()\r\n\r\n    self._update_gauge_emission(_gauge)\r\n    prev_points: uint256 = 0\r\n    last: uint256 = 0\r\n    prev_points, last = self._unpack_two(self.packed_gauge_reserved[_gauge])\r\n    if prev_points == 0:\r\n        # to save gas the cumulative amount is never updated for gauges without \r\n        # reserved points, so we have to do it here\r\n        last = self._unpack_two(self.packed_emission)[0]\r\n\r\n    total_points: uint256 = self.reserved_points - prev_points + _points\r\n    assert total_points <= POINTS_SCALE\r\n    self.reserved_points = total_points\r\n    self.packed_gauge_reserved[_gauge] = self._pack(0, _points, last)\r\n    log SetReservedPoints(_gauge, _points)\r\n\r\n@external\r\ndef set_blank_burn_points(_points: uint256):\r\n    \"\"\"\r\n    @notice Set fraction of blank emissions to be burned\r\n    @param _points Blank burn fraction (bps)\r\n    @dev Only callable by management\r\n    \"\"\"\r\n    assert msg.sender == self.management\r\n    assert _points <= POINTS_SCALE\r\n    assert self._update_emission()\r\n    self.blank_burn_points = _points\r\n    log SetBlankBurnPoints(_points)\r\n\r\n@external\r\ndef set_legacy_gauge(_gauge: address, _legacy: bool):\r\n    \"\"\"\r\n    @notice Set legacy status for a gauge\r\n    @param _gauge Gauge address\r\n    @param _legacy True: legacy, False: no legacy\r\n    @dev Only callable by management\r\n    \"\"\"\r\n    assert msg.sender == self.management\r\n    assert self.gauge_whitelisted[_gauge]\r\n    self.legacy_gauge[_gauge] = _legacy\r\n    log SetLegacyGauge(_gauge, _legacy)\r\n\r\n@external\r\ndef set_whitelister(_whitelister: address):\r\n    \"\"\"\r\n    @notice Set new whitelister address\r\n    @param _whitelister New whitelister address\r\n    @dev Only callable by management\r\n    \"\"\"\r\n    assert msg.sender == self.management\r\n    self.whitelister = _whitelister\r\n    log SetWhitelister(_whitelister)\r\n\r\n@external\r\ndef set_legacy_operator(_operator: address):\r\n    \"\"\"\r\n    @notice Set new legacy operator\r\n    @param _operator New operator address\r\n    @dev Only callable by management\r\n    \"\"\"\r\n    assert msg.sender == self.management\r\n    self.legacy_operator = _operator\r\n    log SetLegacyOperator(_operator)\r\n\r\n@external\r\ndef set_measure(_measure: address):\r\n    \"\"\"\r\n    @notice Set vote weight measure\r\n    @param _measure Measure address\r\n    @dev Only callable by management\r\n    \"\"\"\r\n    assert msg.sender == self.management\r\n    assert _measure != empty(address)\r\n    assert not self._vote_open()\r\n    self.measure = Measure(_measure)\r\n    log SetMeasure(_measure)\r\n\r\n@external\r\ndef set_minter(_minter: address):\r\n    \"\"\"\r\n    @notice Set new reward minter\r\n    @param _minter New minter address\r\n    @dev Only callable by management\r\n    \"\"\"\r\n    assert msg.sender == self.management\r\n    assert _minter != empty(address)\r\n    assert self._update_emission()\r\n    self.minter = Minter(_minter)\r\n    log SetMinter(_minter)\r\n\r\n@external\r\ndef set_burner(_burner: address):\r\n    \"\"\"\r\n    @notice Set new reward burner\r\n    @param _burner New burner address\r\n    @dev Only callable by management\r\n    \"\"\"\r\n    assert msg.sender == self.management\r\n    assert _burner != empty(address)\r\n    assert self._update_emission()\r\n    self.burner = Burner(_burner)\r\n    log SetBurner(_burner)\r\n\r\n@external\r\ndef set_management(_management: address):\r\n    \"\"\"\r\n    @notice \r\n        Set the pending management address.\r\n        Needs to be accepted by that account separately to transfer management over\r\n    @param _management New pending management address\r\n    \"\"\"\r\n    assert msg.sender == self.management\r\n    self.pending_management = _management\r\n    log PendingManagement(_management)\r\n\r\n@external\r\ndef accept_management():\r\n    \"\"\"\r\n    @notice \r\n        Accept management role.\r\n        Can only be called by account previously marked as pending management by current management\r\n    \"\"\"\r\n    assert msg.sender == self.pending_management\r\n    self.pending_management = empty(address)\r\n    self.management = msg.sender\r\n    log SetManagement(msg.sender)\r\n\r\n@internal\r\ndef _update_emission() -> bool:\r\n    \"\"\"\r\n    @notice \r\n        Update global emission. Must be called before:\r\n            - Any gauge is updated\r\n            - Any gauge receives votes\r\n            - Any gauge reserved points is changed\r\n            - Blank vote burn points is changed\r\n    \"\"\"\r\n\r\n    last_epoch: uint256 = self._epoch() - 1\r\n    global_epoch: uint256 = 0\r\n    global_cumulative: uint256 = 0\r\n    global_current: uint256 = 0\r\n    global_epoch, global_cumulative, global_current = self._unpack(self.packed_emission)\r\n\r\n    if global_epoch == last_epoch:\r\n        return True\r\n    global_epoch += 1\r\n\r\n    minted: uint256 = self.minter.mint(global_epoch) + self.blank_emission\r\n    reserved: uint256 = minted * self.reserved_points / POINTS_SCALE\r\n\r\n    blank_votes: uint256 = self.gauge_votes[global_epoch][empty(address)]\r\n    total_votes: uint256 = self.votes[global_epoch]\r\n    blank_emission: uint256 = 0\r\n    if blank_votes > 0:\r\n        blank_emission = (minted - reserved) * blank_votes / total_votes\r\n    elif total_votes == 0:\r\n        # no votes: all non-reserved emissions are considered blank\r\n        blank_emission = minted - reserved\r\n\r\n    burn_amount: uint256 = 0\r\n    if blank_emission > 0:\r\n        # blank emission is partially burned and partially added to next epoch\r\n        burn_amount = blank_emission * self.blank_burn_points / POINTS_SCALE\r\n        if burn_amount > 0:\r\n            blank_emission -= burn_amount\r\n            assert token.approve(self.burner.address, burn_amount, default_return_value=True)\r\n            self.burner.burn(global_epoch, burn_amount)\r\n\r\n    global_cumulative += minted\r\n    global_current = minted\r\n\r\n    self.packed_emission = self._pack(global_epoch, global_cumulative, global_current)\r\n    self.blank_emission = blank_emission\r\n    self.packed_epoch_emission[global_epoch] = self._pack(0, minted, reserved)\r\n    log NewEpoch(global_epoch, minted, reserved, burn_amount, blank_emission)\r\n    return global_epoch == last_epoch\r\n    \r\n@internal\r\ndef _update_gauge_emission(_gauge: address) -> (uint256, uint256, uint256):\r\n    \"\"\"\r\n    @notice \r\n        Update gauge emission. Must be called before:\r\n            - Gauge receives votes\r\n            - Gauge claim\r\n            - Gauge reserved points changes\r\n        Assumes global emission is up to date\r\n    \"\"\"\r\n\r\n    last_epoch: uint256 = self._epoch() - 1\r\n\r\n    gauge_epoch: uint256 = 0\r\n    cumulative: uint256 = 0\r\n    current: uint256 = 0\r\n    gauge_epoch, cumulative, current = self._unpack(self.packed_gauge_emission[_gauge])\r\n\r\n    if gauge_epoch == last_epoch:\r\n        return gauge_epoch, cumulative, current\r\n\r\n    # emission from last updated epoch\r\n    last_updated_epoch: uint256 = gauge_epoch + 1\r\n    current = self.gauge_votes[last_updated_epoch][_gauge]\r\n    if current > 0:\r\n        epoch_emission: uint256 = 0\r\n        epoch_reserved: uint256 = 0\r\n        epoch_emission, epoch_reserved = self._unpack_two(self.packed_epoch_emission[last_updated_epoch])\r\n        current = (epoch_emission - epoch_reserved) * current / self.votes[last_updated_epoch]\r\n        cumulative += current\r\n        if last_updated_epoch != last_epoch:\r\n            # last update was more than 1 epoch ago. the full amount is immediately available.\r\n            # we know the other missing epochs did not have any votes for this gauge because\r\n            # the gauge emissions would have been updated\r\n            current = 0\r\n\r\n    # fast-forward reserved emission\r\n    points: uint256 = 0\r\n    last: uint256 = 0\r\n    points, last = self._unpack_two(self.packed_gauge_reserved[_gauge])\r\n    if points > 0:\r\n        # we know that reserved points for this gauge has remained unchanged since the last \r\n        # gauge update, so we can safely get reserved rewards from potentially multiple epochs\r\n        # by applying the points to the change in global cumulative emission\r\n        global_cumulative: uint256 = 0\r\n        global_current: uint256 = 0\r\n        global_cumulative, global_current = self._unpack_two(self.packed_emission)\r\n        \r\n        current += global_current * points / POINTS_SCALE\r\n        cumulative += (global_cumulative - last) * points / POINTS_SCALE\r\n        self.packed_gauge_reserved[_gauge] = self._pack(0, points, global_cumulative)\r\n\r\n    self.packed_gauge_emission[_gauge] = self._pack(last_epoch, cumulative, current)\r\n    return last_epoch, cumulative, current\r\n\r\n@internal\r\n@pure\r\ndef _pack(_epoch: uint256, _a: uint256, _b: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Pack a 32 bit number with two 112 bit numbers\r\n    \"\"\"\r\n    assert _epoch <= EPOCH_MASK and _a <= MASK and _b <= MASK\r\n    return (_epoch << 224) | (_a << 112) | _b\r\n\r\n@internal\r\n@pure\r\ndef _unpack(_packed: uint256) -> (uint256, uint256, uint256):\r\n    \"\"\"\r\n    @notice Unpack a 32 bit number followed by two 112 bit numbers\r\n    \"\"\"\r\n    return _packed >> 224, (_packed >> 112) & MASK, _packed & MASK\r\n\r\n@internal\r\n@pure\r\ndef _unpack_two(_packed: uint256) -> (uint256, uint256):\r\n    \"\"\"\r\n    @notice Unpack last two 112 bit numbers\r\n    \"\"\"\r\n    return (_packed >> 112) & MASK, _packed & MASK","ABI":"[{\"name\":\"NewEpoch\",\"inputs\":[{\"name\":\"epoch\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"emission\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"reserved\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"burned\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"blank\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Claim\",\"inputs\":[{\"name\":\"gauge\",\"type\":\"address\",\"indexed\":true},{\"name\":\"amount\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Vote\",\"inputs\":[{\"name\":\"epoch\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"account\",\"type\":\"address\",\"indexed\":true},{\"name\":\"gauge\",\"type\":\"address\",\"indexed\":true},{\"name\":\"votes\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Whitelist\",\"inputs\":[{\"name\":\"gauge\",\"type\":\"address\",\"indexed\":true},{\"name\":\"whitelisted\",\"type\":\"bool\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetReservedPoints\",\"inputs\":[{\"name\":\"gauge\",\"type\":\"address\",\"indexed\":true},{\"name\":\"points\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetBlankBurnPoints\",\"inputs\":[{\"name\":\"points\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetLegacyGauge\",\"inputs\":[{\"name\":\"gauge\",\"type\":\"address\",\"indexed\":true},{\"name\":\"legacy\",\"type\":\"bool\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetWhitelister\",\"inputs\":[{\"name\":\"whitelister\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetLegacyOperator\",\"inputs\":[{\"name\":\"operator\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetMeasure\",\"inputs\":[{\"name\":\"measure\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetMinter\",\"inputs\":[{\"name\":\"minter\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetBurner\",\"inputs\":[{\"name\":\"burner\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"PendingManagement\",\"inputs\":[{\"name\":\"management\",\"type\":\"address\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetManagement\",\"inputs\":[{\"name\":\"management\",\"type\":\"address\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"_genesis\",\"type\":\"uint256\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_measure\",\"type\":\"address\"},{\"name\":\"_minter\",\"type\":\"address\"},{\"name\":\"_burner\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"epoch\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"vote_open\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"votes_available\",\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"emission\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"epoch_emission\",\"inputs\":[{\"name\":\"_epoch\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"gauge_emission\",\"inputs\":[{\"name\":\"_gauge\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"gauge_reserved_points\",\"inputs\":[{\"name\":\"_gauge\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"gauge_reserved_last_cumulative\",\"inputs\":[{\"name\":\"_gauge\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"vote\",\"inputs\":[{\"name\":\"_gauges\",\"type\":\"address[]\"},{\"name\":\"_votes\",\"type\":\"uint256[]\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"claim\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"claim\",\"inputs\":[{\"name\":\"_gauge\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"claim\",\"inputs\":[{\"name\":\"_gauge\",\"type\":\"address\"},{\"name\":\"_recipient\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"update_emission\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"whitelist\",\"inputs\":[{\"name\":\"_gauge\",\"type\":\"address\"},{\"name\":\"_whitelisted\",\"type\":\"bool\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_reserved_points\",\"inputs\":[{\"name\":\"_gauge\",\"type\":\"address\"},{\"name\":\"_points\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_blank_burn_points\",\"inputs\":[{\"name\":\"_points\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_legacy_gauge\",\"inputs\":[{\"name\":\"_gauge\",\"type\":\"address\"},{\"name\":\"_legacy\",\"type\":\"bool\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_whitelister\",\"inputs\":[{\"name\":\"_whitelister\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_legacy_operator\",\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_measure\",\"inputs\":[{\"name\":\"_measure\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_minter\",\"inputs\":[{\"name\":\"_minter\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_burner\",\"inputs\":[{\"name\":\"_burner\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_management\",\"inputs\":[{\"name\":\"_management\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"accept_management\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"genesis\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"token\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"management\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"pending_management\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"whitelister\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"legacy_operator\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"measure\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"minter\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"burner\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"blank_emission\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"gauge_claimed\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"blank_burn_points\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"reserved_points\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"gauge_whitelisted\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"legacy_gauge\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"votes\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"votes_user\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"},{\"name\":\"arg1\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"gauge_votes\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"},{\"name\":\"arg1\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"gauge_votes_user\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"},{\"name\":\"arg1\",\"type\":\"uint256\"},{\"name\":\"arg2\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]}]","ContractName":"Gauge controller","CompilerVersion":"vyper:0.3.10","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000650b878000000000000000000000000041252e8691e964f7de35156b68493bab6797a275000000000000000000000000992122bc6f7fed14edc4a564d57039452c63cc88000000000000000000000000c65ac814056fd097ca28850c8466ece7bb3a8bf5000000000000000000000000cac873e93cfe5c79325e73c22975b665c6177f40","EVMVersion":"Default","Library":"","LicenseType":"GNU AGPLv3","Proxy":"0","Implementation":"","SwarmSource":""}]}