{"status":"1","message":"OK","result":[{"SourceCode":"# @version ^0.3.9\r\n\r\ninterface Withdrawler:\r\n  def triggerEmission(_pipe: address): nonpayable\r\n\r\ninterface RewardToken:\r\n  def decimals() -> uint8: view\r\n  def transfer(_to: address, _value: uint256) -> bool: nonpayable\r\n  def transferFrom(_from: address, _to: address, _value: uint256) -> bool: nonpayable\r\n\r\nrewardToken: immutable(RewardToken)\r\nwithdrawler: immutable(Withdrawler)\r\n\r\ninitialBondValue: constant(uint256) = 100000000\r\nprecision: immutable(uint256)\r\nbondValue: public(uint256)\r\n\r\ntemp: public(uint256) # rewards received while there are no stakers\r\ndust: public(uint256) # reward dust from a receipt to be added to next receipt\r\n\r\nstruct StakedBond:\r\n  amount: uint256\r\n  bondValue: uint256\r\n\r\nstakes: public(HashMap[address, StakedBond])\r\ntotalStake: public(uint256)\r\n\r\n@external\r\ndef __init__(rewardTokenAddress: address, withdrawlerAddress: address):\r\n  rewardToken = RewardToken(rewardTokenAddress)\r\n  withdrawler = Withdrawler(withdrawlerAddress)\r\n  precision = 10 ** convert(rewardToken.decimals() / 2, uint256)\r\n  self.bondValue = initialBondValue\r\n\r\nevent Receive:\r\n  amount: indexed(uint256)\r\n  oldBondValue: indexed(uint256)\r\n  newBondValue: indexed(uint256)\r\n\r\n@external\r\ndef receiveReward(_token: address, _from: address, _amount: uint256):\r\n  assert _token == rewardToken.address, \"token\"\r\n  assert rewardToken.transferFrom(_from, self, _amount), \"transferFrom\"\r\n\r\n  if self.totalStake == 0:\r\n    self.temp += _amount\r\n    return\r\n\r\n  amount: uint256 = _amount\r\n  if 0 < self.temp:\r\n    amount += self.temp\r\n    self.temp = 0\r\n\r\n  oldBondValue: uint256 = self.bondValue\r\n  rawReward: uint256 = amount + self.dust\r\n  totalBonds: uint256 = self.totalStake / precision\r\n  bondInc: uint256 = rawReward / totalBonds\r\n  reward: uint256 = totalBonds * bondInc\r\n  self.bondValue += bondInc\r\n  self.dust = rawReward - reward\r\n  log Receive(_amount, oldBondValue, self.bondValue)\r\n\r\nevent Stake:\r\n  user: indexed(address)\r\n  amount: indexed(uint256)\r\n\r\nevent Unstake:\r\n  user: indexed(address)\r\n  amount: indexed(uint256)\r\n  reward: indexed(uint256)\r\n\r\n@internal\r\ndef forceSend(_to: address, _amount: uint256) -> bool:\r\n  # gas=0 should prevent any action on receipt, and hence any chance of reentrancy\r\n  return raw_call(_to, b\"\", value=_amount, gas=0, revert_on_failure=False)\r\n\r\n@internal\r\ndef _stake(user: address, amount: uint256):\r\n  assert 0 < amount, \"amount\"\r\n  self.totalStake += amount\r\n  reward: uint256 = self._reward(user, self.stakes[user].amount)\r\n  self.stakes[user].amount += amount\r\n  bondValue: uint256 = reward * precision / self.stakes[user].amount\r\n  self.stakes[user].bondValue = self.bondValue - bondValue\r\n  log Stake(user, amount)\r\n\r\n@internal\r\ndef _unstake(user: address, amount: uint256):\r\n  assert 0 < amount, \"amount\"\r\n  assert amount <= self.stakes[user].amount, \"balance\"\r\n  reward: uint256 = self._reward(user, amount)\r\n  self.totalStake -= amount\r\n  self.stakes[user].amount -= amount\r\n  assert self.forceSend(user, amount), \"send\"\r\n  log Unstake(user, amount, reward)\r\n  if reward == 0: return\r\n  assert rewardToken.transfer(user, reward), \"transfer\"\r\n\r\n@internal\r\n@view\r\ndef _reward(user: address, stake: uint256) -> uint256:\r\n  return (stake * (self.bondValue - self.stakes[user].bondValue)) / precision\r\n\r\n@external\r\ndef unstake(amount: uint256):\r\n  withdrawler.triggerEmission(self)\r\n  self._unstake(msg.sender, amount)\r\n\r\n@external\r\ndef previewUnstake(user: address, amount: uint256) -> uint256:\r\n  withdrawler.triggerEmission(self)\r\n  return self._reward(user, amount)\r\n\r\n@external\r\n@payable\r\ndef receive(user: address, unused_data: Bytes[1]):\r\n  self._stake(user, msg.value)","ABI":"[{\"name\":\"Receive\",\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\",\"indexed\":true},{\"name\":\"oldBondValue\",\"type\":\"uint256\",\"indexed\":true},{\"name\":\"newBondValue\",\"type\":\"uint256\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Stake\",\"inputs\":[{\"name\":\"user\",\"type\":\"address\",\"indexed\":true},{\"name\":\"amount\",\"type\":\"uint256\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Unstake\",\"inputs\":[{\"name\":\"user\",\"type\":\"address\",\"indexed\":true},{\"name\":\"amount\",\"type\":\"uint256\",\"indexed\":true},{\"name\":\"reward\",\"type\":\"uint256\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"rewardTokenAddress\",\"type\":\"address\"},{\"name\":\"withdrawlerAddress\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"receiveReward\",\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"unstake\",\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"previewUnstake\",\"inputs\":[{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"receive\",\"inputs\":[{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"unused_data\",\"type\":\"bytes\"}],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"bondValue\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"temp\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"dust\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"stakes\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"tuple\",\"components\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"bondValue\",\"type\":\"uint256\"}]}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"totalStake\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]}]","ContractName":"Vyper_contract","CompilerVersion":"vyper:0.3.10","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"000000000000000000000000f68513fc61a040a29f3947ffff47a42e7c81082b000000000000000000000000272347f941fb5f35854d8f5dbdcedef1a515db41","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":""}]}