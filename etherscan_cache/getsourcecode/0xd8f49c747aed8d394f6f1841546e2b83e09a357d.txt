{"status":"1","message":"OK","result":[{"SourceCode":"# @version 0.3.10\r\n\"\"\"\r\n@title AggMonetaryPolicy - monetary policy based on aggregated prices for crvUSD\r\n@author Curve.Fi\r\n@license Copyright (c) Curve.Fi, 2020-2023 - all rights reserved\r\n\"\"\"\r\n\r\n# This version uses min(last day) debt when calculating per-market rates\r\n# Should be used for Controllers which update borrow rate too early (not at the end of every call)\r\n\r\n\r\ninterface PegKeeper:\r\n    def debt() -> uint256: view\r\n\r\ninterface PriceOracle:\r\n    def price() -> uint256: view\r\n    def price_w() -> uint256: nonpayable\r\n\r\ninterface ControllerFactory:\r\n    def total_debt() -> uint256: view\r\n    def debt_ceiling(_for: address) -> uint256: view\r\n    def n_collaterals() -> uint256: view\r\n    def controllers(i: uint256) -> address: view\r\n\r\ninterface Controller:\r\n    def total_debt() -> uint256: view\r\n\r\n\r\nstruct TotalDebts:\r\n    total_debt: uint256\r\n    controller_debt: uint256\r\n    ceiling: uint256\r\n\r\n\r\nevent SetAdmin:\r\n    admin: address\r\n\r\nevent AddPegKeeper:\r\n    peg_keeper: indexed(address)\r\n\r\nevent RemovePegKeeper:\r\n    peg_keeper: indexed(address)\r\n\r\nevent SetRate:\r\n    rate: uint256\r\n\r\nevent SetSigma:\r\n    sigma: int256\r\n\r\nevent SetTargetDebtFraction:\r\n    target_debt_fraction: uint256\r\n\r\n\r\nadmin: public(address)\r\n\r\nrate0: public(uint256)\r\nsigma: public(int256)  # 2 * 10**16 for example\r\ntarget_debt_fraction: public(uint256)\r\n\r\npeg_keepers: public(PegKeeper[1001])\r\nPRICE_ORACLE: public(immutable(PriceOracle))\r\nCONTROLLER_FACTORY: public(immutable(ControllerFactory))\r\n\r\n# Cache for controllers\r\nMAX_CONTROLLERS: constant(uint256) = 50000\r\nn_controllers: public(uint256)\r\ncontrollers: public(address[MAX_CONTROLLERS])\r\n\r\n\r\nstruct DebtCandle:\r\n    candle0: uint256  # earlier 1/2 day candle\r\n    candle1: uint256   # later 1/2 day candle\r\n    timestamp: uint256\r\n\r\nDEBT_CANDLE_TIME: constant(uint256) = 86400 / 2\r\nmin_debt_candles: public(HashMap[address, DebtCandle])\r\n\r\n\r\nMAX_TARGET_DEBT_FRACTION: constant(uint256) = 10**18\r\nMAX_SIGMA: constant(int256) = 10**18\r\nMIN_SIGMA: constant(int256) = 10**14\r\nMAX_EXP: constant(uint256) = 1000 * 10**18\r\nMAX_RATE: constant(uint256) = 43959106799  # 300% APY\r\nTARGET_REMAINDER: constant(uint256) = 10**17  # rate is x1.9 when 10% left before ceiling\r\n\r\n\r\n@external\r\ndef __init__(admin: address,\r\n             price_oracle: PriceOracle,\r\n             controller_factory: ControllerFactory,\r\n             peg_keepers: PegKeeper[5],\r\n             rate: uint256,\r\n             sigma: int256,\r\n             target_debt_fraction: uint256):\r\n    self.admin = admin\r\n    PRICE_ORACLE = price_oracle\r\n    CONTROLLER_FACTORY = controller_factory\r\n    for i in range(5):\r\n        if peg_keepers[i].address == empty(address):\r\n            break\r\n        self.peg_keepers[i] = peg_keepers[i]\r\n\r\n    assert sigma >= MIN_SIGMA\r\n    assert sigma <= MAX_SIGMA\r\n    assert target_debt_fraction > 0\r\n    assert target_debt_fraction <= MAX_TARGET_DEBT_FRACTION\r\n    assert rate <= MAX_RATE\r\n    self.rate0 = rate\r\n    self.sigma = sigma\r\n    self.target_debt_fraction = target_debt_fraction\r\n\r\n\r\n@external\r\ndef set_admin(admin: address):\r\n    assert msg.sender == self.admin\r\n    self.admin = admin\r\n    log SetAdmin(admin)\r\n\r\n\r\n@external\r\ndef add_peg_keeper(pk: PegKeeper):\r\n    assert msg.sender == self.admin\r\n    assert pk.address != empty(address)\r\n    for i in range(1000):\r\n        _pk: PegKeeper = self.peg_keepers[i]\r\n        assert _pk != pk, \"Already added\"\r\n        if _pk.address == empty(address):\r\n            self.peg_keepers[i] = pk\r\n            log AddPegKeeper(pk.address)\r\n            break\r\n\r\n\r\n@external\r\ndef remove_peg_keeper(pk: PegKeeper):\r\n    assert msg.sender == self.admin\r\n    replaced_peg_keeper: uint256 = 10000\r\n    for i in range(1001):  # 1001th element is always 0x0\r\n        _pk: PegKeeper = self.peg_keepers[i]\r\n        if _pk == pk:\r\n            replaced_peg_keeper = i\r\n            log RemovePegKeeper(pk.address)\r\n        if _pk.address == empty(address):\r\n            if replaced_peg_keeper < i:\r\n                if replaced_peg_keeper < i - 1:\r\n                    self.peg_keepers[replaced_peg_keeper] = self.peg_keepers[i - 1]\r\n                self.peg_keepers[i - 1] = PegKeeper(empty(address))\r\n            break\r\n\r\n\r\n@internal\r\n@pure\r\ndef exp(power: int256) -> uint256:\r\n    if power <= -41446531673892821376:\r\n        return 0\r\n\r\n    if power >= 135305999368893231589:\r\n        # Return MAX_EXP when we are in overflow mode\r\n        return MAX_EXP\r\n\r\n    x: int256 = unsafe_div(unsafe_mul(power, 2**96), 10**18)\r\n\r\n    k: int256 = unsafe_div(\r\n        unsafe_add(\r\n            unsafe_div(unsafe_mul(x, 2**96), 54916777467707473351141471128),\r\n            2**95),\r\n        2**96)\r\n    x = unsafe_sub(x, unsafe_mul(k, 54916777467707473351141471128))\r\n\r\n    y: int256 = unsafe_add(x, 1346386616545796478920950773328)\r\n    y = unsafe_add(unsafe_div(unsafe_mul(y, x), 2**96), 57155421227552351082224309758442)\r\n    p: int256 = unsafe_sub(unsafe_add(y, x), 94201549194550492254356042504812)\r\n    p = unsafe_add(unsafe_div(unsafe_mul(p, y), 2**96), 28719021644029726153956944680412240)\r\n    p = unsafe_add(unsafe_mul(p, x), (4385272521454847904659076985693276 * 2**96))\r\n\r\n    q: int256 = x - 2855989394907223263936484059900\r\n    q = unsafe_add(unsafe_div(unsafe_mul(q, x), 2**96), 50020603652535783019961831881945)\r\n    q = unsafe_sub(unsafe_div(unsafe_mul(q, x), 2**96), 533845033583426703283633433725380)\r\n    q = unsafe_add(unsafe_div(unsafe_mul(q, x), 2**96), 3604857256930695427073651918091429)\r\n    q = unsafe_sub(unsafe_div(unsafe_mul(q, x), 2**96), 14423608567350463180887372962807573)\r\n    q = unsafe_add(unsafe_div(unsafe_mul(q, x), 2**96), 26449188498355588339934803723976023)\r\n\r\n    return shift(\r\n        unsafe_mul(convert(unsafe_div(p, q), uint256), 3822833074963236453042738258902158003155416615667),\r\n        unsafe_sub(k, 195))\r\n\r\n\r\n@internal\r\n@view\r\ndef get_total_debt(_for: address) -> (uint256, uint256):\r\n    n_controllers: uint256 = self.n_controllers\r\n    total_debt: uint256 = 0\r\n    debt_for: uint256 = 0\r\n\r\n    for i in range(MAX_CONTROLLERS):\r\n        if i >= n_controllers:\r\n            break\r\n        controller: address = self.controllers[i]\r\n\r\n        success: bool = False\r\n        res: Bytes[32] = empty(Bytes[32])\r\n        success, res = raw_call(controller, method_id(\"total_debt()\"), max_outsize=32, is_static_call=True, revert_on_failure=False)\r\n        debt: uint256 = convert(res, uint256)\r\n        total_debt += debt\r\n        if controller == _for:\r\n            debt_for = debt\r\n\r\n    return total_debt, debt_for\r\n\r\n\r\n@internal\r\n@view\r\ndef read_candle(_for: address) -> uint256:\r\n    out: uint256 = 0\r\n    candle: DebtCandle = self.min_debt_candles[_for]\r\n\r\n    if block.timestamp < candle.timestamp / DEBT_CANDLE_TIME * DEBT_CANDLE_TIME + DEBT_CANDLE_TIME:\r\n        if candle.candle0 > 0:\r\n            out = min(candle.candle0, candle.candle1)\r\n        else:\r\n            out = candle.candle1\r\n    elif block.timestamp < candle.timestamp / DEBT_CANDLE_TIME * DEBT_CANDLE_TIME + DEBT_CANDLE_TIME * 2:\r\n        out = candle.candle1\r\n\r\n    return out\r\n\r\n\r\n@internal\r\ndef save_candle(_for: address, _value: uint256):\r\n    candle: DebtCandle = self.min_debt_candles[_for]\r\n\r\n    if candle.timestamp == 0 and _value == 0:\r\n        # This record did not exist before, and value is zero -> not recording anything\r\n        return\r\n\r\n    if block.timestamp >= candle.timestamp / DEBT_CANDLE_TIME * DEBT_CANDLE_TIME + DEBT_CANDLE_TIME:\r\n        if block.timestamp < candle.timestamp / DEBT_CANDLE_TIME * DEBT_CANDLE_TIME + DEBT_CANDLE_TIME * 2:\r\n            candle.candle0 = candle.candle1\r\n            candle.candle1 = _value\r\n        else:\r\n            candle.candle0 = _value\r\n            candle.candle1 = _value\r\n    else:\r\n        candle.candle1 = min(candle.candle1, _value)\r\n\r\n    candle.timestamp = block.timestamp\r\n    self.min_debt_candles[_for] = candle\r\n\r\n\r\n@internal\r\n@view\r\ndef read_debt(_for: address, ro: bool) -> (uint256, uint256):\r\n    debt_total: uint256 = self.read_candle(empty(address))\r\n    debt_for: uint256 = self.read_candle(_for)\r\n    fresh_total: uint256 = 0\r\n    fresh_for: uint256 = 0\r\n\r\n    if ro:\r\n        fresh_total, fresh_for = self.get_total_debt(_for)\r\n        if debt_total > 0:\r\n            debt_total = min(debt_total, fresh_total)\r\n        else:\r\n            debt_total = fresh_total\r\n        if debt_for > 0:\r\n            debt_for = min(debt_for, fresh_for)\r\n        else:\r\n            debt_for = fresh_for\r\n\r\n    else:\r\n        if debt_total == 0 or debt_for == 0:\r\n            fresh_total, fresh_for = self.get_total_debt(_for)\r\n            if debt_total == 0:\r\n                debt_total = fresh_total\r\n            if debt_for == 0:\r\n                debt_for = fresh_for\r\n\r\n    return debt_total, debt_for\r\n\r\n\r\n@internal\r\n@view\r\ndef calculate_rate(_for: address, _price: uint256, ro: bool) -> uint256:\r\n    sigma: int256 = self.sigma\r\n    target_debt_fraction: uint256 = self.target_debt_fraction\r\n\r\n    p: int256 = convert(_price, int256)\r\n    pk_debt: uint256 = 0\r\n    for pk in self.peg_keepers:\r\n        if pk.address == empty(address):\r\n            break\r\n        pk_debt += pk.debt()\r\n\r\n    total_debt: uint256 = 0\r\n    debt_for: uint256 = 0\r\n    total_debt, debt_for = self.read_debt(_for, ro)\r\n\r\n    power: int256 = (10**18 - p) * 10**18 / sigma  # high price -> negative pow -> low rate\r\n    if pk_debt > 0:\r\n        if total_debt == 0:\r\n            return 0\r\n        else:\r\n            power -= convert(pk_debt * 10**18 / total_debt * 10**18 / target_debt_fraction, int256)\r\n\r\n    # Rate accounting for crvUSD price and PegKeeper debt\r\n    rate: uint256 = self.rate0 * min(self.exp(power), MAX_EXP) / 10**18\r\n\r\n    # Account for individual debt ceiling to dynamically tune rate depending on filling the market\r\n    ceiling: uint256 = CONTROLLER_FACTORY.debt_ceiling(_for)\r\n    if ceiling > 0:\r\n        f: uint256 = min(debt_for * 10**18 / ceiling, 10**18 - TARGET_REMAINDER / 1000)\r\n        rate = min(rate * ((10**18 - TARGET_REMAINDER) + TARGET_REMAINDER * 10**18 / (10**18 - f)) / 10**18, MAX_RATE)\r\n\r\n    # Rate multiplication at different ceilings (target = 0.1):\r\n    # debt = 0:\r\n    #   new_rate = rate * ((1.0 - target) + target) = rate\r\n    #\r\n    # debt = ceiling:\r\n    #   f = 1.0 - 0.1 / 1000 = 0.9999  # instead of infinity to avoid /0\r\n    #   new_rate = min(rate * ((1.0 - target) + target / (1.0 - 0.9999)), max_rate) = max_rate\r\n    #\r\n    # debt = 0.9 * ceiling, target = 0.1\r\n    #   f = 0.9\r\n    #   new_rate = rate * ((1.0 - 0.1) + 0.1 / (1.0 - 0.9)) = rate * (1.0 + 1.0 - 0.1) = 1.9 * rate\r\n\r\n    return rate\r\n\r\n\r\n@view\r\n@external\r\ndef rate(_for: address = msg.sender) -> uint256:\r\n    return self.calculate_rate(_for, PRICE_ORACLE.price(), True)\r\n\r\n\r\n@external\r\ndef rate_write(_for: address = msg.sender) -> uint256:\r\n    # Update controller list\r\n    n_controllers: uint256 = self.n_controllers\r\n    n_factory_controllers: uint256 = CONTROLLER_FACTORY.n_collaterals()\r\n    if n_factory_controllers > n_controllers:\r\n        self.n_controllers = n_factory_controllers\r\n        for i in range(MAX_CONTROLLERS):\r\n            self.controllers[n_controllers] = CONTROLLER_FACTORY.controllers(n_controllers)\r\n            n_controllers += 1\r\n            if n_controllers >= n_factory_controllers:\r\n                break\r\n\r\n    # Update candles\r\n    total_debt: uint256 = 0\r\n    debt_for: uint256 = 0\r\n    total_debt, debt_for = self.get_total_debt(_for)\r\n    self.save_candle(empty(address), total_debt)\r\n    self.save_candle(_for, debt_for)\r\n\r\n    return self.calculate_rate(_for, PRICE_ORACLE.price_w(), False)\r\n\r\n\r\n@external\r\ndef set_rate(rate: uint256):\r\n    assert msg.sender == self.admin\r\n    assert rate <= MAX_RATE\r\n    self.rate0 = rate\r\n    log SetRate(rate)\r\n\r\n\r\n@external\r\ndef set_sigma(sigma: int256):\r\n    assert msg.sender == self.admin\r\n    assert sigma >= MIN_SIGMA\r\n    assert sigma <= MAX_SIGMA\r\n\r\n    self.sigma = sigma\r\n    log SetSigma(sigma)\r\n\r\n\r\n@external\r\ndef set_target_debt_fraction(target_debt_fraction: uint256):\r\n    assert msg.sender == self.admin\r\n    assert target_debt_fraction <= MAX_TARGET_DEBT_FRACTION\r\n    assert target_debt_fraction > 0\r\n\r\n    self.target_debt_fraction = target_debt_fraction\r\n    log SetTargetDebtFraction(target_debt_fraction)","ABI":"[{\"name\":\"SetAdmin\",\"inputs\":[{\"name\":\"admin\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"AddPegKeeper\",\"inputs\":[{\"name\":\"peg_keeper\",\"type\":\"address\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"RemovePegKeeper\",\"inputs\":[{\"name\":\"peg_keeper\",\"type\":\"address\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetRate\",\"inputs\":[{\"name\":\"rate\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetSigma\",\"inputs\":[{\"name\":\"sigma\",\"type\":\"int256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetTargetDebtFraction\",\"inputs\":[{\"name\":\"target_debt_fraction\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"admin\",\"type\":\"address\"},{\"name\":\"price_oracle\",\"type\":\"address\"},{\"name\":\"controller_factory\",\"type\":\"address\"},{\"name\":\"peg_keepers\",\"type\":\"address[5]\"},{\"name\":\"rate\",\"type\":\"uint256\"},{\"name\":\"sigma\",\"type\":\"int256\"},{\"name\":\"target_debt_fraction\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_admin\",\"inputs\":[{\"name\":\"admin\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"add_peg_keeper\",\"inputs\":[{\"name\":\"pk\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"remove_peg_keeper\",\"inputs\":[{\"name\":\"pk\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"rate\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"rate\",\"inputs\":[{\"name\":\"_for\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"rate_write\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"rate_write\",\"inputs\":[{\"name\":\"_for\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_rate\",\"inputs\":[{\"name\":\"rate\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_sigma\",\"inputs\":[{\"name\":\"sigma\",\"type\":\"int256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_target_debt_fraction\",\"inputs\":[{\"name\":\"target_debt_fraction\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"admin\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"rate0\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"sigma\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"target_debt_fraction\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"peg_keepers\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"PRICE_ORACLE\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"CONTROLLER_FACTORY\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"n_controllers\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"controllers\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"min_debt_candles\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"tuple\",\"components\":[{\"name\":\"candle0\",\"type\":\"uint256\"},{\"name\":\"candle1\",\"type\":\"uint256\"},{\"name\":\"timestamp\",\"type\":\"uint256\"}]}]}]","ContractName":"AggMonetaryPolicy - monetary policy based on aggregated prices for crvUSD","CompilerVersion":"vyper:0.3.10","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"00000000000000000000000040907540d8a6c65c637785e8f8b742ae6b0b996800000000000000000000000018672b1b0c623a30089a280ed9256379fb0e4e62000000000000000000000000c9332fdcb1c491dcc683bae86fe3cb70360738bc000000000000000000000000aa346781ddd7009caa644a4980f044c50cd2ae22000000000000000000000000e7cd2b4eb1d98cd6a4a48b6071d46401ac7dc5c80000000000000000000000006b765d07cf966c745b340adca67749fe75b5c3450000000000000000000000001ef89ed0edd93d1ec09e4c07373f69c49f4dccae0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000011b81f43d00000000000000000000000000000000000000000000000000470de4df820000000000000000000000000000000000000000000000000000016345785d8a0000","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":""}]}