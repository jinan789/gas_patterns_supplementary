{"status":"1","message":"OK","result":[{"SourceCode":"# @version 0.3.9\r\n\r\n\"\"\"\r\n@title LOTM Renting Protocol Vault Contract\r\n@author [Zharta](https://zharta.io/)\r\n@notice This contract is the vault implementation for the LOTM Renting Protocol.\r\n@dev This is the implementation contract for each vault, which is deployed as a minimal proxy (ERC1167) by `Renting.vy` and accepts only calls from it. This contract holds the assets (NFT, payment tokens) for each token, holds the listing and rental states, performs rewards and fee payments and sets the delegation to hot wallets. Delegations are performed by warm.xyz HotWalletProxy.\r\nThe information regarding listings and rentals was externalized in order to reduce the gas costs while using the protocol. That requires the state to be passed as an argument to each function and validated by matching it's hash against the one stored in the contract. Conversly, changes to the state are hashed and stored, and the resulting state variables returned to the caller (the Renting contract), to either be published as events or returned directly to the user. The structures that hold the state are the `Listing` and the `Rentals`, although not every member is part of the state if is not required to keep the integrity of the contract.\r\n\"\"\"\r\n\r\n# Interfaces\r\n\r\nfrom vyper.interfaces import ERC20 as IERC20\r\nfrom vyper.interfaces import ERC721 as IERC721\r\n\r\ninterface IDelegationRegistry:\r\n    def getHotWallet(cold_wallet: address) -> address: view\r\n    def setHotWallet(hot_wallet_address: address, expiration_timestamp: uint256, lock_hot_wallet_address: bool): nonpayable\r\n    def setExpirationTimestamp(expiration_timestamp: uint256): nonpayable\r\n\r\n\r\n# Structs\r\n\r\nstruct Rental:\r\n    id: bytes32 # keccak256 of the renter, token_id, start and expiration\r\n    owner: address\r\n    renter: address\r\n    delegate: address\r\n    token_id: uint256\r\n    start: uint256\r\n    min_expiration: uint256\r\n    expiration: uint256\r\n    amount: uint256\r\n    protocol_fee: uint256\r\n    protocol_wallet: address\r\n\r\n\r\nstruct Listing:\r\n    token_id: uint256\r\n    price: uint256 # price per hour, 0 means not listed\r\n    min_duration: uint256 # min duration in hours\r\n    max_duration: uint256 # max duration in hours, 0 means unlimited\r\n\r\nstruct VaultState:\r\n    active_rental: Rental\r\n    listing: Listing\r\n\r\n\r\n# Global Variables\r\n\r\nempty_state_hash: immutable(bytes32)\r\n\r\nowner: public(address)\r\ncaller: public(address)\r\nstate: public(bytes32)\r\nunclaimed_rewards: public(uint256)\r\nunclaimed_protocol_fee: public(uint256)\r\n\r\npayment_token_addr: public(immutable(address))\r\nnft_contract_addr: public(immutable(address))\r\ndelegation_registry_addr: public(immutable(address))\r\n\r\n\r\n##### EXTERNAL METHODS - WRITE #####\r\n\r\n@payable\r\n@external\r\ndef __init__(\r\n    _payment_token_addr: address,\r\n    _nft_contract_addr: address,\r\n    _delegation_registry_addr: address\r\n):\r\n\r\n    \"\"\"\r\n    @dev Sets up the contract by initializing the payment token, NFT contract, and delegation registry addresses.\r\n    @param _payment_token_addr The address of the payment token contract.\r\n    @param _nft_contract_addr The address of the NFT contract.\r\n    @param _delegation_registry_addr The address of the delegation registry contract.\r\n    \"\"\"\r\n\r\n    payment_token_addr = _payment_token_addr\r\n    nft_contract_addr = _nft_contract_addr\r\n    delegation_registry_addr = _delegation_registry_addr\r\n    empty_state_hash = self._state_hash(empty(VaultState))\r\n\r\n\r\n@external\r\ndef initialise(owner: address):\r\n\r\n    \"\"\"\r\n    @notice Initialize a vault with the given owner, enabling it to receive a token\r\n    @dev Ensures that the vault is not already initialized before setting the owner and caller.\r\n    @param owner The address of the vault's owner.\r\n    \"\"\"\r\n\r\n    assert not self._is_initialised(), \"already initialised\"\r\n\r\n    if self.caller != empty(address):\r\n        assert msg.sender == self.caller, \"not caller\"\r\n    else:\r\n        self.caller = msg.sender\r\n\r\n    self.owner = owner\r\n    self.state = empty_state_hash\r\n\r\n\r\n@external\r\ndef deposit(token_id: uint256, price: uint256, min_duration: uint256, max_duration: uint256, delegate: address):\r\n\r\n    \"\"\"\r\n    @notice Deposit an NFT into the vault with specified listing terms and optionaly sets up delegation.\r\n    @dev Validates the initialization and state of the contract before proceeding with the deposit.\r\n    @param token_id The id of the NFT to be deposited.\r\n    @param price The rental price per hour, a value of 0 means unlisted.\r\n    @param min_duration The minimum rental duration in hours.\r\n    @param max_duration The maximum rental duration in hours.\r\n    @param delegate The address to delegate the NFT to while listed. If empty no delegation is done.\r\n    \"\"\"\r\n\r\n    assert self._is_initialised(), \"not initialised\"\r\n    assert msg.sender == self.caller, \"not caller\"\r\n    assert self.state == empty_state_hash, \"invalid state\"\r\n\r\n    if max_duration != 0 and min_duration > max_duration:\r\n        raise \"min duration > max duration\"\r\n\r\n    self.state = self._state_hash2(\r\n        Listing(\r\n            {\r\n                token_id: token_id,\r\n                price: price,\r\n                min_duration: min_duration,\r\n                max_duration: max_duration\r\n            }\r\n        ),\r\n        empty(Rental)\r\n    )\r\n\r\n    # transfer token to this contract\r\n    IERC721(nft_contract_addr).safeTransferFrom(self.owner, self, token_id, b\"\")\r\n\r\n    # create delegation\r\n    if delegate != empty(address):\r\n        self._delegate_to_wallet(delegate)\r\n\r\n\r\n@external\r\ndef set_listing(state: VaultState, token_id: uint256, sender: address, price: uint256, min_duration: uint256, max_duration: uint256, delegate: address):\r\n\r\n    \"\"\"\r\n    @notice Set or update the listing for an NFT in the vault.\r\n    @dev Updates the listing details, including price and duration and optionaly sets up delegation.\r\n    @param state The current state of the vault.\r\n    @param token_id The id of the NFT to be listed.\r\n    @param sender The address setting the listing, expected to be the owner.\r\n    @param price The rental price per hour, a value of 0 means unlisted.\r\n    @param min_duration The minimum rental duration in hours.\r\n    @param max_duration The maximum rental duration in hours, 0 for unlimited.\r\n    @param delegate The address to delegate the NFT to while unlisted. If empty, no delegation is done, neither any possible current delegation is changed.\r\n    \"\"\"\r\n\r\n    assert self._is_initialised(), \"not initialised\"\r\n    assert msg.sender == self.caller, \"not caller\"\r\n    assert sender == self.owner, \"not owner of vault\"\r\n    assert self.state == self._state_hash(state), \"invalid state\"\r\n    assert state.listing.token_id == token_id, \"invalid token_id\"\r\n\r\n    self._set_listing(token_id, price, min_duration, max_duration, state.active_rental)\r\n\r\n    # create delegation\r\n    if delegate != empty(address):\r\n        assert state.active_rental.expiration < block.timestamp, \"deleg while rental ongoing\"\r\n        self._delegate_to_wallet(delegate)\r\n\r\n\r\n@external\r\ndef start_rental(state: VaultState, renter: address, expiration: uint256, delegate: address, protocol_fee: uint256, protocol_wallet: address) -> Rental:\r\n\r\n    \"\"\"\r\n    @notice Start a rental of an NFT from the vault.\r\n    @dev Handles the transfer of rental amount, updates the rental state, and sets up delegation. Any previous rentals' amounts are consolidated into unclaimed_rewards.\r\n    @param state The current state of the vault.\r\n    @param renter The address of the renter.\r\n    @param expiration The expiration timestamp of the rental.\r\n    @param delegate The address to delegate the NFT to.\r\n    @param protocol_fee The protocol fee in bps.\r\n    @param protocol_wallet The wallet to receive the protocol fee.\r\n    @return The details of the new rental.\r\n    \"\"\"\r\n\r\n    assert self._is_initialised(), \"not initialised\"\r\n    assert msg.sender == self.caller, \"not caller\"\r\n    assert state.listing.price > 0, \"listing does not exist\"\r\n    assert state.active_rental.expiration < block.timestamp, \"active rental ongoing\"\r\n    assert self._is_within_duration_range(state.listing, block.timestamp, expiration), \"duration not respected\"\r\n    assert delegate != empty(address), \"delegate is zero address\"\r\n    assert self.state == self._state_hash(state), \"invalid state\"\r\n\r\n    rental_amount: uint256 = self._compute_rental_amount(block.timestamp, expiration, state.listing.price)\r\n    assert IERC20(payment_token_addr).allowance(renter, self) >= rental_amount, \"insufficient allowance\"\r\n\r\n    # transfer rental amount from renter to this contract\r\n    assert IERC20(payment_token_addr).transferFrom(renter, self, rental_amount), \"transferFrom failed\"\r\n\r\n    # create delegation\r\n    if IDelegationRegistry(delegation_registry_addr).getHotWallet(self) == delegate:\r\n        IDelegationRegistry(delegation_registry_addr).setExpirationTimestamp(expiration)\r\n    else:\r\n        IDelegationRegistry(delegation_registry_addr).setHotWallet(delegate, expiration, False)\r\n\r\n    # store unclaimed rewards\r\n    self._consolidate_claims(state)\r\n\r\n    # create rental\r\n    rental_id: bytes32 = self._compute_rental_id(renter, state.listing.token_id, block.timestamp, expiration)\r\n    new_rental: Rental = Rental({\r\n        id: rental_id,\r\n        owner: self.owner,\r\n        renter: renter,\r\n        delegate: delegate,\r\n        token_id: state.listing.token_id,\r\n        start: block.timestamp,\r\n        min_expiration: block.timestamp + state.listing.min_duration * 3600,\r\n        expiration: expiration,\r\n        amount: rental_amount,\r\n        protocol_fee: protocol_fee,\r\n        protocol_wallet: protocol_wallet\r\n    })\r\n\r\n    self.state = self._state_hash2(state.listing, new_rental)\r\n\r\n    return new_rental\r\n\r\n\r\n@external\r\ndef close_rental(state: VaultState, sender: address) -> uint256:\r\n\r\n    \"\"\"\r\n    @notice Close an active rental and handle any transfers of fees or refunds.\r\n    @dev Calculates pro-rata rental amounts and handles transfers of funds and revocation of delegation. The revised rental's amount are consolidated into unclaimed_rewards.\r\n    @param state The current state of the vault.\r\n    @param sender The address closing the rental, must be the renter.\r\n    @return The pro-rata rental amount.\r\n    \"\"\"\r\n\r\n    assert self._is_initialised(), \"not initialised\"\r\n    assert msg.sender == self.caller, \"not caller\"\r\n    assert self.state == self._state_hash(state), \"invalid state\"\r\n\r\n    assert state.active_rental.expiration > block.timestamp, \"active rental does not exist\"\r\n    assert sender == state.active_rental.renter, \"not renter of active rental\"\r\n\r\n    # compute amount to send back to renter\r\n    real_expiration_adjusted: uint256 = block.timestamp\r\n    if block.timestamp < state.active_rental.min_expiration:\r\n        real_expiration_adjusted = state.active_rental.min_expiration\r\n\r\n    pro_rata_rental_amount: uint256 = self._compute_real_rental_amount(\r\n        state.active_rental.expiration - state.active_rental.start,\r\n        real_expiration_adjusted - state.active_rental.start,\r\n        state.active_rental.amount\r\n    )\r\n    payback_amount: uint256 = state.active_rental.amount - pro_rata_rental_amount\r\n\r\n    protocol_fee_amount: uint256 = pro_rata_rental_amount * state.active_rental.protocol_fee / 10000\r\n\r\n    # clear active rental\r\n    self.state = self._state_hash2(state.listing, empty(Rental))\r\n\r\n    # set unclaimed rewards\r\n    self.unclaimed_rewards += pro_rata_rental_amount - protocol_fee_amount\r\n\r\n    # clear unclaimed protocol fee\r\n    if self.unclaimed_protocol_fee > 0:\r\n        protocol_fee_amount += self.unclaimed_protocol_fee\r\n        self.unclaimed_protocol_fee = 0\r\n\r\n    # revoke delegation\r\n    IDelegationRegistry(delegation_registry_addr).setHotWallet(empty(address), 0, False)\r\n\r\n    # transfer unused payment to renter\r\n    assert IERC20(payment_token_addr).transfer(state.active_rental.renter, payback_amount), \"transfer failed\"\r\n\r\n    # transfer protocol fee to protocol wallet\r\n    if protocol_fee_amount > 0:\r\n        assert IERC20(payment_token_addr).transfer(state.active_rental.protocol_wallet, protocol_fee_amount), \"transfer failed\"\r\n\r\n    return pro_rata_rental_amount\r\n\r\n\r\n@external\r\ndef claim(state: VaultState, sender: address) -> (Rental, uint256, uint256):\r\n\r\n    \"\"\"\r\n    @notice Claim unclaimed rewards and protocol fees from the vault.\r\n    @dev Transfers accumulated rewards to the owner and fees to protocol wallet.\r\n    @param state The current state of the vault.\r\n    @param sender The address claiming the rewards, must be the owner.\r\n    @return A tuple with the updated rental, amount of rewards claimed, and amount of protocol fees claimed.\r\n    \"\"\"\r\n\r\n    assert self._is_initialised(), \"not initialised\"\r\n    assert msg.sender == self.caller, \"not caller\"\r\n    assert sender == self.owner, \"not owner of vault\"\r\n    assert self.state == self._state_hash(state), \"invalid state\"\r\n    assert self._claimable_rewards(state.active_rental) > 0, \"no rewards to claim\"\r\n\r\n    # consolidate last renting rewards if existing\r\n    result_active_rental: Rental = self._consolidate_claims(state)\r\n\r\n    rewards_to_claim: uint256 = self.unclaimed_rewards\r\n    protocol_fee_to_claim: uint256 = self.unclaimed_protocol_fee\r\n\r\n    # clear unclaimed rewards and protocol fee\r\n    self.unclaimed_rewards = 0\r\n    self.unclaimed_protocol_fee = 0\r\n\r\n    # transfer reward to nft owner\r\n    assert IERC20(payment_token_addr).transfer(self.owner, rewards_to_claim), \"transfer failed\"\r\n\r\n    # transfer protocol fee to protocol wallet\r\n    if protocol_fee_to_claim > 0:\r\n        assert IERC20(payment_token_addr).transfer(state.active_rental.protocol_wallet, protocol_fee_to_claim), \"transfer failed\"\r\n\r\n    return result_active_rental, rewards_to_claim, protocol_fee_to_claim\r\n\r\n\r\n@external\r\ndef withdraw(state: VaultState, sender: address) -> (uint256, uint256):\r\n\r\n    \"\"\"\r\n    @notice Withdraw an NFT from the vault and claim any unclaimed rewards and protocol fees.\r\n    @dev Handles the transfer of the NFT back to the owner and clears the vault's state.\r\n    @param state The current state of the vault.\r\n    @param sender The address withdrawing the NFT, must be the owner.\r\n    @return A tuple with the amount of rewards and protocol fees claimed.\r\n    \"\"\"\r\n\r\n    assert self._is_initialised(), \"not initialised\"\r\n    assert msg.sender == self.caller, \"not caller\"\r\n    assert sender == self.owner, \"not owner of vault\"\r\n    assert state.active_rental.expiration < block.timestamp, \"active rental ongoing\"\r\n    assert self.state == self._state_hash(state), \"invalid state\"\r\n\r\n    # consolidate last renting rewards if existing\r\n    rental: Rental = self._consolidate_claims(state)\r\n\r\n    rewards_to_claim: uint256 = self.unclaimed_rewards\r\n    protocol_fee_to_claim: uint256 = self.unclaimed_protocol_fee\r\n    owner: address = self.owner\r\n\r\n    # clear vault and set state to zero to uninitialize\r\n    self.unclaimed_rewards = 0\r\n    self.unclaimed_protocol_fee = 0\r\n    self.state = empty(bytes32)\r\n    self.owner = empty(address)\r\n\r\n    # transfer token to owner\r\n    IERC721(nft_contract_addr).safeTransferFrom(self, owner, state.listing.token_id, b\"\")\r\n\r\n    # transfer unclaimed rewards to owner\r\n    if rewards_to_claim > 0:\r\n        assert IERC20(payment_token_addr).transfer(owner, rewards_to_claim), \"transfer failed\"\r\n\r\n    # transfer protocol fee to protocol wallet\r\n    if protocol_fee_to_claim > 0:\r\n        assert IERC20(payment_token_addr).transfer(state.active_rental.protocol_wallet, protocol_fee_to_claim), \"transfer failed\"\r\n\r\n    return rewards_to_claim, protocol_fee_to_claim\r\n\r\n\r\n@external\r\ndef delegate_to_wallet(state: VaultState, sender: address, delegate: address):\r\n\r\n    \"\"\"\r\n    @notice Delegate the NFT in the vault to a specified wallet.\r\n    @dev Validates that no rental is ongoing.\r\n    @param state The current state of the vault.\r\n    @param sender The address delegating the NFT, must be the owner.\r\n    @param delegate The address to delegate the NFT to.\r\n    \"\"\"\r\n\r\n    assert self._is_initialised(), \"not initialised\"\r\n    assert msg.sender == self.caller, \"not caller\"\r\n    assert sender == self.owner, \"not owner of vault\"\r\n    assert state.active_rental.expiration < block.timestamp, \"active rental ongoing\"\r\n    assert self.state == self._state_hash(state), \"invalid state\"\r\n\r\n    self._delegate_to_wallet(delegate)\r\n\r\n\r\n##### INTERNAL METHODS #####\r\n\r\n@internal\r\ndef _consolidate_claims(state: VaultState) -> Rental:\r\n    if state.active_rental.amount == 0 or state.active_rental.expiration >= block.timestamp:\r\n        return state.active_rental\r\n    else:\r\n        protocol_fee_amount: uint256 = state.active_rental.amount * state.active_rental.protocol_fee / 10000\r\n\r\n        self.unclaimed_rewards += state.active_rental.amount - protocol_fee_amount\r\n        self.unclaimed_protocol_fee += protocol_fee_amount\r\n\r\n        new_rental: Rental = Rental({\r\n            id: state.active_rental.id,\r\n            owner: state.active_rental.owner,\r\n            renter: state.active_rental.renter,\r\n            delegate: state.active_rental.delegate,\r\n            token_id: state.active_rental.token_id,\r\n            start: state.active_rental.start,\r\n            min_expiration: state.active_rental.min_expiration,\r\n            expiration: state.active_rental.expiration,\r\n            amount: 0,\r\n            protocol_fee: state.active_rental.protocol_fee,\r\n            protocol_wallet: state.active_rental.protocol_wallet\r\n        })\r\n        self.state = self._state_hash2(state.listing, new_rental)\r\n\r\n        return new_rental\r\n\r\n@internal\r\ndef _is_within_duration_range(listing: Listing, start: uint256, expiration: uint256) -> bool:\r\n    return expiration - start >= listing.min_duration * 3600 and (listing.max_duration == 0 or expiration - start <= listing.max_duration * 3600)\r\n\r\n\r\n@pure\r\n@internal\r\ndef _compute_rental_id(renter: address, token_id: uint256, start: uint256, expiration: uint256) -> bytes32:\r\n    return keccak256(concat(convert(renter, bytes32), convert(token_id, bytes32), convert(start, bytes32), convert(expiration, bytes32)))\r\n\r\n\r\n@pure\r\n@internal\r\ndef _compute_rental_amount(start: uint256, expiration: uint256, price: uint256) -> uint256:\r\n    return (expiration - start) * price / 3600\r\n\r\n\r\n@pure\r\n@internal\r\ndef _compute_real_rental_amount(duration: uint256, real_duration: uint256, rental_amount: uint256) -> uint256:\r\n    return rental_amount * real_duration / duration\r\n\r\n\r\n@view\r\n@internal\r\ndef _claimable_rewards(active_rental: Rental) -> uint256:\r\n    if active_rental.expiration < block.timestamp:\r\n        return self.unclaimed_rewards + active_rental.amount * (10000 - active_rental.protocol_fee) / 10000\r\n    else:\r\n        return self.unclaimed_rewards * (10000 - active_rental.protocol_fee) / 10000\r\n\r\n@internal\r\ndef _delegate_to_wallet(wallet: address):\r\n    delegation_registry: IDelegationRegistry = IDelegationRegistry(delegation_registry_addr)\r\n    if delegation_registry.getHotWallet(self) != wallet:\r\n        delegation_registry.setHotWallet(wallet, max_value(uint256), False)\r\n\r\n\r\n@internal\r\ndef _set_listing(token_id: uint256, price: uint256, min_duration: uint256, max_duration: uint256, active_rental: Rental):\r\n    if max_duration != 0 and min_duration > max_duration:\r\n        raise \"min duration > max duration\"\r\n\r\n    self.state = self._state_hash2(\r\n        Listing(\r\n            {\r\n                token_id: token_id,\r\n                price: price,\r\n                min_duration: min_duration,\r\n                max_duration: max_duration\r\n            }\r\n        ),\r\n        active_rental\r\n    )\r\n\r\n@pure\r\n@internal\r\ndef _state_hash(state: VaultState) -> bytes32:\r\n    return self._state_hash2(state.listing, state.active_rental)\r\n\r\n@pure\r\n@internal\r\ndef _state_hash2(listing: Listing, rental: Rental) -> bytes32:\r\n    return keccak256(\r\n        concat(\r\n            rental.id,\r\n            convert(rental.owner, bytes32),\r\n            convert(rental.renter, bytes32),\r\n            convert(rental.token_id, bytes32),\r\n            convert(rental.start, bytes32),\r\n            convert(rental.min_expiration, bytes32),\r\n            convert(rental.expiration, bytes32),\r\n            convert(rental.amount, bytes32),\r\n            convert(rental.protocol_fee, bytes32),\r\n            convert(rental.protocol_wallet, bytes32),\r\n            convert(listing.token_id, bytes32),\r\n            convert(listing.price, bytes32),\r\n            convert(listing.min_duration, bytes32),\r\n            convert(listing.max_duration, bytes32),\r\n        )\r\n    )\r\n\r\n\r\n@view\r\n@internal\r\ndef _is_initialised() -> bool:\r\n    return self.state != empty(bytes32)\r\n\r\n\r\n##### EXTERNAL METHODS - VIEW #####\r\n\r\n@view\r\n@external\r\ndef claimable_rewards(active_rental: Rental) -> uint256:\r\n    return self._claimable_rewards(active_rental)\r\n\r\n\r\n@view\r\n@external\r\ndef onERC721Received(_operator: address, _from: address, _tokenId: uint256, _data: Bytes[1024]) -> bytes4:\r\n    return method_id(\"onERC721Received(address,address,uint256,bytes)\", output_type=bytes4)\r\n\r\n@view\r\n@external\r\ndef is_initialised() -> bool:\r\n    return self._is_initialised()","ABI":"[{\"stateMutability\":\"payable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"_payment_token_addr\",\"type\":\"address\"},{\"name\":\"_nft_contract_addr\",\"type\":\"address\"},{\"name\":\"_delegation_registry_addr\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"initialise\",\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"deposit\",\"inputs\":[{\"name\":\"token_id\",\"type\":\"uint256\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"min_duration\",\"type\":\"uint256\"},{\"name\":\"max_duration\",\"type\":\"uint256\"},{\"name\":\"delegate\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_listing\",\"inputs\":[{\"name\":\"state\",\"type\":\"tuple\",\"components\":[{\"name\":\"active_rental\",\"type\":\"tuple\",\"components\":[{\"name\":\"id\",\"type\":\"bytes32\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"renter\",\"type\":\"address\"},{\"name\":\"delegate\",\"type\":\"address\"},{\"name\":\"token_id\",\"type\":\"uint256\"},{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"min_expiration\",\"type\":\"uint256\"},{\"name\":\"expiration\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"protocol_fee\",\"type\":\"uint256\"},{\"name\":\"protocol_wallet\",\"type\":\"address\"}]},{\"name\":\"listing\",\"type\":\"tuple\",\"components\":[{\"name\":\"token_id\",\"type\":\"uint256\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"min_duration\",\"type\":\"uint256\"},{\"name\":\"max_duration\",\"type\":\"uint256\"}]}]},{\"name\":\"token_id\",\"type\":\"uint256\"},{\"name\":\"sender\",\"type\":\"address\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"min_duration\",\"type\":\"uint256\"},{\"name\":\"max_duration\",\"type\":\"uint256\"},{\"name\":\"delegate\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"start_rental\",\"inputs\":[{\"name\":\"state\",\"type\":\"tuple\",\"components\":[{\"name\":\"active_rental\",\"type\":\"tuple\",\"components\":[{\"name\":\"id\",\"type\":\"bytes32\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"renter\",\"type\":\"address\"},{\"name\":\"delegate\",\"type\":\"address\"},{\"name\":\"token_id\",\"type\":\"uint256\"},{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"min_expiration\",\"type\":\"uint256\"},{\"name\":\"expiration\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"protocol_fee\",\"type\":\"uint256\"},{\"name\":\"protocol_wallet\",\"type\":\"address\"}]},{\"name\":\"listing\",\"type\":\"tuple\",\"components\":[{\"name\":\"token_id\",\"type\":\"uint256\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"min_duration\",\"type\":\"uint256\"},{\"name\":\"max_duration\",\"type\":\"uint256\"}]}]},{\"name\":\"renter\",\"type\":\"address\"},{\"name\":\"expiration\",\"type\":\"uint256\"},{\"name\":\"delegate\",\"type\":\"address\"},{\"name\":\"protocol_fee\",\"type\":\"uint256\"},{\"name\":\"protocol_wallet\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"tuple\",\"components\":[{\"name\":\"id\",\"type\":\"bytes32\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"renter\",\"type\":\"address\"},{\"name\":\"delegate\",\"type\":\"address\"},{\"name\":\"token_id\",\"type\":\"uint256\"},{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"min_expiration\",\"type\":\"uint256\"},{\"name\":\"expiration\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"protocol_fee\",\"type\":\"uint256\"},{\"name\":\"protocol_wallet\",\"type\":\"address\"}]}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"close_rental\",\"inputs\":[{\"name\":\"state\",\"type\":\"tuple\",\"components\":[{\"name\":\"active_rental\",\"type\":\"tuple\",\"components\":[{\"name\":\"id\",\"type\":\"bytes32\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"renter\",\"type\":\"address\"},{\"name\":\"delegate\",\"type\":\"address\"},{\"name\":\"token_id\",\"type\":\"uint256\"},{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"min_expiration\",\"type\":\"uint256\"},{\"name\":\"expiration\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"protocol_fee\",\"type\":\"uint256\"},{\"name\":\"protocol_wallet\",\"type\":\"address\"}]},{\"name\":\"listing\",\"type\":\"tuple\",\"components\":[{\"name\":\"token_id\",\"type\":\"uint256\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"min_duration\",\"type\":\"uint256\"},{\"name\":\"max_duration\",\"type\":\"uint256\"}]}]},{\"name\":\"sender\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"claim\",\"inputs\":[{\"name\":\"state\",\"type\":\"tuple\",\"components\":[{\"name\":\"active_rental\",\"type\":\"tuple\",\"components\":[{\"name\":\"id\",\"type\":\"bytes32\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"renter\",\"type\":\"address\"},{\"name\":\"delegate\",\"type\":\"address\"},{\"name\":\"token_id\",\"type\":\"uint256\"},{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"min_expiration\",\"type\":\"uint256\"},{\"name\":\"expiration\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"protocol_fee\",\"type\":\"uint256\"},{\"name\":\"protocol_wallet\",\"type\":\"address\"}]},{\"name\":\"listing\",\"type\":\"tuple\",\"components\":[{\"name\":\"token_id\",\"type\":\"uint256\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"min_duration\",\"type\":\"uint256\"},{\"name\":\"max_duration\",\"type\":\"uint256\"}]}]},{\"name\":\"sender\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"tuple\",\"components\":[{\"name\":\"id\",\"type\":\"bytes32\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"renter\",\"type\":\"address\"},{\"name\":\"delegate\",\"type\":\"address\"},{\"name\":\"token_id\",\"type\":\"uint256\"},{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"min_expiration\",\"type\":\"uint256\"},{\"name\":\"expiration\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"protocol_fee\",\"type\":\"uint256\"},{\"name\":\"protocol_wallet\",\"type\":\"address\"}]},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"withdraw\",\"inputs\":[{\"name\":\"state\",\"type\":\"tuple\",\"components\":[{\"name\":\"active_rental\",\"type\":\"tuple\",\"components\":[{\"name\":\"id\",\"type\":\"bytes32\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"renter\",\"type\":\"address\"},{\"name\":\"delegate\",\"type\":\"address\"},{\"name\":\"token_id\",\"type\":\"uint256\"},{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"min_expiration\",\"type\":\"uint256\"},{\"name\":\"expiration\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"protocol_fee\",\"type\":\"uint256\"},{\"name\":\"protocol_wallet\",\"type\":\"address\"}]},{\"name\":\"listing\",\"type\":\"tuple\",\"components\":[{\"name\":\"token_id\",\"type\":\"uint256\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"min_duration\",\"type\":\"uint256\"},{\"name\":\"max_duration\",\"type\":\"uint256\"}]}]},{\"name\":\"sender\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"delegate_to_wallet\",\"inputs\":[{\"name\":\"state\",\"type\":\"tuple\",\"components\":[{\"name\":\"active_rental\",\"type\":\"tuple\",\"components\":[{\"name\":\"id\",\"type\":\"bytes32\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"renter\",\"type\":\"address\"},{\"name\":\"delegate\",\"type\":\"address\"},{\"name\":\"token_id\",\"type\":\"uint256\"},{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"min_expiration\",\"type\":\"uint256\"},{\"name\":\"expiration\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"protocol_fee\",\"type\":\"uint256\"},{\"name\":\"protocol_wallet\",\"type\":\"address\"}]},{\"name\":\"listing\",\"type\":\"tuple\",\"components\":[{\"name\":\"token_id\",\"type\":\"uint256\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"min_duration\",\"type\":\"uint256\"},{\"name\":\"max_duration\",\"type\":\"uint256\"}]}]},{\"name\":\"sender\",\"type\":\"address\"},{\"name\":\"delegate\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"claimable_rewards\",\"inputs\":[{\"name\":\"active_rental\",\"type\":\"tuple\",\"components\":[{\"name\":\"id\",\"type\":\"bytes32\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"renter\",\"type\":\"address\"},{\"name\":\"delegate\",\"type\":\"address\"},{\"name\":\"token_id\",\"type\":\"uint256\"},{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"min_expiration\",\"type\":\"uint256\"},{\"name\":\"expiration\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"protocol_fee\",\"type\":\"uint256\"},{\"name\":\"protocol_wallet\",\"type\":\"address\"}]}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"onERC721Received\",\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"},{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"is_initialised\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"owner\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"caller\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"state\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"unclaimed_rewards\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"unclaimed_protocol_fee\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"payment_token_addr\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"nft_contract_addr\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"delegation_registry_addr\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]}]","ContractName":"LOTM Renting Protocol Vault Contract","CompilerVersion":"vyper:0.3.9","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"0000000000000000000000004d224452801aced8b2f0aebe155379bb5d594381000000000000000000000000e012baf811cf9c05c408e879c399960d1f305903000000000000000000000000c3aa9bc72bd623168860a1e5c6a4530d3d80456c","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":""}]}