{"status":"1","message":"OK","result":[{"SourceCode":"# @version 0.3.7\r\n\"\"\"\r\n@notice Connext bridge wrapper\r\n\"\"\"\r\nfrom vyper.interfaces import ERC20\r\n\r\n\r\ninterface Connext:\r\n    def xcall(\r\n        _destination: uint32,\r\n        _to: address,\r\n        _asset: address,\r\n        _delegate: address,\r\n        _amount: uint256,\r\n        _slippage: uint256,\r\n        _callData: Bytes[128]\r\n    ) -> bytes32: payable\r\n\r\n\r\ninterface XERC20Lockbox:\r\n    def deposit(_amount: uint256): nonpayable\r\n    def depositTo(_to: address, _amount: uint256): nonpayable\r\n    def XERC20() -> address: view\r\n    def ERC20() -> address: view\r\n\r\n\r\nevent TransferOwnership:\r\n    _old_owner: address\r\n    _new_owner: address\r\n\r\n\r\nCONNEXT: immutable(address)\r\nTOKEN: immutable(address)\r\nXTOKEN: immutable(address)\r\nLOCKBOX: immutable(address)\r\nDESTINATION_DOMAIN: immutable(uint32)\r\n\r\nis_approved: public(HashMap[address, bool])\r\n\r\nowner: public(address)\r\nfuture_owner: public(address)\r\n\r\nxcall_cost: uint256\r\n\r\n\r\n@external\r\ndef __init__(_connext: address, _lockbox: address, _destination_domain: uint32, _xcall_cost: uint256, _owner: address):\r\n    CONNEXT = _connext\r\n    LOCKBOX = _lockbox\r\n    DESTINATION_DOMAIN = _destination_domain\r\n\r\n    # fetch token addresses from lockbox\r\n    token: address = XERC20Lockbox(_lockbox).ERC20()\r\n    xtoken: address = XERC20Lockbox(_lockbox).XERC20()\r\n    TOKEN = token\r\n    XTOKEN = xtoken\r\n\r\n    # approve raw token to lockbox and xtoken to connext bridge\r\n    assert ERC20(token).approve(_lockbox, max_value(uint256), default_return_value=True)\r\n    assert ERC20(xtoken).approve(_connext, max_value(uint256), default_return_value=True)\r\n    self.is_approved[token] = True\r\n    self.is_approved[xtoken] = True\r\n\r\n    self.owner = _owner\r\n    log TransferOwnership(empty(address), _owner)\r\n\r\n    self.xcall_cost = _xcall_cost\r\n\r\n\r\n@payable\r\n@external\r\ndef __default__():\r\n    pass\r\n\r\n\r\n@payable\r\n@external\r\ndef bridge(_token: address, _to: address, _amount: uint256):\r\n    \"\"\"\r\n    @notice Bridge an asset using the Connext Bridge\r\n    @param _token The ERC20 asset to bridge\r\n    @param _to The receiver on the destination chain\r\n    @param _amount The amount of `_token` to bridge\r\n    \"\"\"\r\n    assert ERC20(_token).transferFrom(msg.sender, self, _amount, default_return_value=True)\r\n\r\n    if _token == TOKEN:\r\n        # use lockbox to wrap token into xtoken first\r\n        XERC20Lockbox(LOCKBOX).deposit(_amount)\r\n        Connext(CONNEXT).xcall(DESTINATION_DOMAIN, _to, XTOKEN, msg.sender, _amount, 0, b\"\", value=self.xcall_cost)\r\n    else:\r\n        if not self.is_approved[_token]:\r\n            assert ERC20(_token).approve(CONNEXT, max_value(uint256), default_return_value=True)\r\n            self.is_approved[_token] = True\r\n        Connext(CONNEXT).xcall(DESTINATION_DOMAIN, _to, _token, msg.sender, _amount, 0, b\"\", value=self.xcall_cost)\r\n\r\n\r\n    if self.balance != 0:\r\n        raw_call(msg.sender, b\"\", value=self.balance)\r\n\r\n\r\n@view\r\n@external\r\ndef cost() -> uint256:\r\n    \"\"\"\r\n    @notice Cost in ETH to bridge\r\n    \"\"\"\r\n    return self.xcall_cost\r\n\r\n\r\n@pure\r\n@external\r\ndef check(_account: address) -> bool:\r\n    \"\"\"\r\n    @notice Check if `_account` may bridge via `transmit_emissions`\r\n    @param _account The account to check\r\n    \"\"\"\r\n    return True\r\n\r\n\r\n@external\r\ndef set_xcall_cost(_new_cost: uint256):\r\n    assert msg.sender == self.owner  # dev: only owner\r\n\r\n    self.xcall_cost = _new_cost\r\n\r\n\r\n@external\r\ndef commit_transfer_ownership(_future_owner: address):\r\n    \"\"\"\r\n    @notice Transfer ownership to `_future_owner`\r\n    @param _future_owner The account to commit as the future owner\r\n    \"\"\"\r\n    assert msg.sender == self.owner  # dev: only owner\r\n\r\n    self.future_owner = _future_owner\r\n\r\n\r\n@external\r\ndef accept_transfer_ownership():\r\n    \"\"\"\r\n    @notice Accept the transfer of ownership\r\n    @dev Only the committed future owner can call this function\r\n    \"\"\"\r\n    assert msg.sender == self.future_owner  # dev: only future owner\r\n\r\n    log TransferOwnership(self.owner, msg.sender)\r\n    self.owner = msg.sender","ABI":"[{\"name\":\"TransferOwnership\",\"inputs\":[{\"name\":\"_old_owner\",\"type\":\"address\",\"indexed\":false},{\"name\":\"_new_owner\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"_connext\",\"type\":\"address\"},{\"name\":\"_lockbox\",\"type\":\"address\"},{\"name\":\"_destination_domain\",\"type\":\"uint32\"},{\"name\":\"_xcall_cost\",\"type\":\"uint256\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"bridge\",\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"cost\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"pure\",\"type\":\"function\",\"name\":\"check\",\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_xcall_cost\",\"inputs\":[{\"name\":\"_new_cost\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"commit_transfer_ownership\",\"inputs\":[{\"name\":\"_future_owner\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"accept_transfer_ownership\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"is_approved\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"owner\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"future_owner\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]}]","ContractName":"Vyper_contract","CompilerVersion":"vyper:0.3.7","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"0000000000000000000000008898b472c54c31894e3b9bb83cea802a5d0e63c60000000000000000000000002b3c399baeb628a29d8d636e7bc495820f9afb4f000000000000000000000000000000000000000000000000000000006172626f0000000000000000000000000000000000000000000000000000befe6f6720000000000000000000000000009a8fee232dcf73060af348a1b62cdb0a19852d13","EVMVersion":"Default","Library":"","LicenseType":"GNU AGPLv3","Proxy":"0","Implementation":"","SwarmSource":""}]}