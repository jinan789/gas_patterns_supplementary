{"status":"1","message":"OK","result":[{"SourceCode":"# @version ^0.3.9\r\n\r\ninterface Withdrawler:\r\n  def triggerEmission(_pipe: address): nonpayable\r\n\r\nwithdrawler: immutable(Withdrawler)\r\nMAX_DATA: constant(uint256) = 32 * 4\r\n\r\ninterface ERC20:\r\n  def decimals() -> uint8: view\r\n  def balanceOf(_owner: address) -> uint256: view\r\n  def transfer(_to: address, _value: uint256) -> bool: nonpayable\r\n  def transferFrom(_from: address, _to: address, _value: uint256) -> bool: nonpayable\r\n\r\nstruct RewardPool:\r\n  token: ERC20\r\n  precision: uint256\r\n  bondValue: uint256\r\n  temp: uint256\r\n  dust: uint256\r\n\r\nrewardPoolLidont: public(RewardPool)\r\nrewardPoolRocket: public(RewardPool)\r\n\r\nrewardTokenLidont: public(immutable(ERC20))\r\nrewardTokenRocket: public(immutable(ERC20))\r\n\r\ninitialBondValue: constant(uint256) = 100000000\r\nprecision: public(immutable(uint256))\r\nbondValueLidont: public(uint256)\r\nbondValueRocket: public(uint256)\r\n\r\ntempLidont: public(uint256) # rewards received while there are no stakers\r\ndustLidont: public(uint256) # reward dust from a receipt to be added to next receipt\r\ntempRocket: public(uint256) # rewards received while there are no stakers\r\ndustRocket: public(uint256) # reward dust from a receipt to be added to next receipt\r\n\r\nstruct StakedBond:\r\n  amount: uint256\r\n  bondValueLidont: uint256\r\n  bondValueRocket: uint256\r\n\r\nstakes: public(HashMap[address, StakedBond])\r\ntotalStake: public(uint256)\r\n\r\n@external\r\ndef __init__(rewardTokenAddress: address, withdrawlerAddress: address, rocketStorageAddress: address):\r\n  withdrawler = Withdrawler(withdrawlerAddress)\r\n  rewardTokenLidont = ERC20(rewardTokenAddress)\r\n  decimals: uint8 = rewardTokenLidont.decimals()\r\n  rocketStorage = RocketStorage(rocketStorageAddress)\r\n  rewardTokenRocket = ERC20(rocketStorage.getAddress(rocketTokenKey))\r\n  assert rewardTokenRocket.decimals() == decimals, \"decimals\"\r\n  precision = 10 ** convert(decimals / 2, uint256)\r\n  self.bondValueLidont = initialBondValue\r\n  self.bondValueRocket = initialBondValue\r\n  rocketEther = ERC20(rocketStorage.getAddress(rocketEtherKey))\r\n  rocketSwapRouter = SwapRouter(0x16D5A408e807db8eF7c578279BEeEe6b228f1c1C)\r\n\r\ninterface RocketStorage:\r\n  def getAddress(_key: bytes32) -> address: view\r\n\r\ninterface SwapRouter:\r\n  def swapTo(_uniswap: uint256, _balancer: uint256, _minOut: uint256, _idealOut: uint256): payable\r\n\r\nrocketStorage: immutable(RocketStorage)\r\nrocketEther: immutable(ERC20)\r\nrocketEtherKey: constant(bytes32) = keccak256(\"contract.addressrocketTokenRETH\")\r\nrocketTokenKey: constant(bytes32) = keccak256(\"contract.addressrocketTokenRPL\")\r\nrocketSwapRouter: public(immutable(SwapRouter))\r\n\r\n@external\r\ndef receiveReward(_token: address, _from: address, _amount: uint256):\r\n  if _token == rewardTokenLidont.address:\r\n    assert rewardTokenLidont.transferFrom(_from, self, _amount), \"transferFrom lidont\"\r\n\r\n    if self.totalStake == 0:\r\n      self.tempLidont += _amount\r\n      return\r\n\r\n    amount: uint256 = _amount\r\n    if 0 < self.tempLidont:\r\n      amount += self.tempLidont\r\n      self.tempLidont = 0\r\n\r\n    rawReward: uint256 = amount + self.dustLidont\r\n    totalBonds: uint256 = self.totalStake / precision\r\n    bondInc: uint256 = rawReward / totalBonds\r\n    reward: uint256 = totalBonds * bondInc\r\n    self.bondValueLidont += bondInc\r\n    self.dustLidont = rawReward - reward\r\n\r\n  elif _token == rewardTokenRocket.address:\r\n    assert rewardTokenRocket.transferFrom(_from, self, _amount), \"transferFrom RPL\"\r\n\r\n    if self.totalStake == 0:\r\n      self.tempRocket += _amount\r\n      return\r\n\r\n    amount: uint256 = _amount\r\n    if 0 < self.tempRocket:\r\n      amount += self.tempRocket\r\n      self.tempRocket = 0\r\n\r\n    rawReward: uint256 = amount + self.dustRocket\r\n    totalBonds: uint256 = self.totalStake / precision\r\n    bondInc: uint256 = rawReward / totalBonds\r\n    reward: uint256 = totalBonds * bondInc\r\n    self.bondValueRocket += bondInc\r\n    self.dustRocket = rawReward - reward\r\n\r\n  else:\r\n    raise \"token\"\r\n\r\nevent Stake:\r\n  user: indexed(address)\r\n  amount: indexed(uint256)\r\n\r\nevent Unstake:\r\n  user: indexed(address)\r\n  amount: indexed(uint256)\r\n  rewardLidont: uint256\r\n  rewardRocket: uint256\r\n\r\n@internal\r\ndef _stake(user: address, amount: uint256):\r\n  assert 0 < amount, \"amount\"\r\n  self.totalStake += amount\r\n  rewardLidont: uint256 = self._rewardLidont(user, self.stakes[user].amount)\r\n  rewardRocket: uint256 = self._rewardRocket(user, self.stakes[user].amount)\r\n  self.stakes[user].amount += amount\r\n  bondValueLidont: uint256 = rewardLidont * precision / self.stakes[user].amount\r\n  bondValueRocket: uint256 = rewardRocket * precision / self.stakes[user].amount\r\n  self.stakes[user].bondValueLidont = self.bondValueLidont - bondValueLidont\r\n  self.stakes[user].bondValueRocket = self.bondValueRocket - bondValueRocket\r\n  log Stake(user, amount)\r\n\r\n@internal\r\ndef _unstake(user: address, amount: uint256):\r\n  assert 0 < amount, \"amount\"\r\n  assert amount <= self.stakes[user].amount, \"balance\"\r\n  rewardLidont: uint256 = self._rewardLidont(user, amount)\r\n  rewardRocket: uint256 = self._rewardRocket(user, amount)\r\n  self.totalStake -= amount\r\n  self.stakes[user].amount -= amount\r\n  assert rocketEther.transfer(user, amount), \"send\"\r\n  log Unstake(user, amount, rewardLidont, rewardRocket)\r\n  if rewardLidont != 0:\r\n    assert rewardTokenLidont.transfer(user, rewardLidont), \"transfer lidont\"\r\n  if rewardRocket != 0:\r\n    assert rewardTokenRocket.transfer(user, rewardRocket), \"transfer RPL\"\r\n\r\n@internal\r\n@view\r\ndef _rewardLidont(user: address, stake: uint256) -> uint256:\r\n  return (stake * (self.bondValueLidont - self.stakes[user].bondValueLidont)) / precision\r\n\r\n@internal\r\n@view\r\ndef _rewardRocket(user: address, stake: uint256) -> uint256:\r\n  return (stake * (self.bondValueRocket - self.stakes[user].bondValueRocket)) / precision\r\n\r\n@external\r\ndef unstake(amount: uint256):\r\n  withdrawler.triggerEmission(self)\r\n  self._unstake(msg.sender, amount)\r\n\r\n@external\r\ndef previewUnstake(user: address, amount: uint256) -> (uint256, uint256):\r\n  withdrawler.triggerEmission(self)\r\n  return (self._rewardLidont(user, amount), self._rewardRocket(user, amount))\r\n\r\n@external\r\n@payable\r\ndef receive(user: address, data: Bytes[MAX_DATA]):\r\n  rETHBefore: uint256 = rocketEther.balanceOf(self)\r\n  uniswapPortion: uint256 = empty(uint256)\r\n  balancerPortion: uint256 = empty(uint256)\r\n  minOut: uint256 = empty(uint256)\r\n  idealOut: uint256 = empty(uint256)\r\n  uniswapPortion, balancerPortion, minOut, idealOut = _abi_decode(data, (uint256, uint256, uint256, uint256))\r\n  rocketSwapRouter.swapTo(\r\n    uniswapPortion, balancerPortion, minOut, idealOut, value = msg.value)\r\n  rETHMinted: uint256 = rocketEther.balanceOf(self) - rETHBefore\r\n  self._stake(user, rETHMinted)","ABI":"[{\"name\":\"Stake\",\"inputs\":[{\"name\":\"user\",\"type\":\"address\",\"indexed\":true},{\"name\":\"amount\",\"type\":\"uint256\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Unstake\",\"inputs\":[{\"name\":\"user\",\"type\":\"address\",\"indexed\":true},{\"name\":\"amount\",\"type\":\"uint256\",\"indexed\":true},{\"name\":\"rewardLidont\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"rewardRocket\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"rewardTokenAddress\",\"type\":\"address\"},{\"name\":\"withdrawlerAddress\",\"type\":\"address\"},{\"name\":\"rocketStorageAddress\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"receiveReward\",\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"unstake\",\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"previewUnstake\",\"inputs\":[{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"receive\",\"inputs\":[{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"rewardPoolLidont\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"tuple\",\"components\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"precision\",\"type\":\"uint256\"},{\"name\":\"bondValue\",\"type\":\"uint256\"},{\"name\":\"temp\",\"type\":\"uint256\"},{\"name\":\"dust\",\"type\":\"uint256\"}]}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"rewardPoolRocket\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"tuple\",\"components\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"precision\",\"type\":\"uint256\"},{\"name\":\"bondValue\",\"type\":\"uint256\"},{\"name\":\"temp\",\"type\":\"uint256\"},{\"name\":\"dust\",\"type\":\"uint256\"}]}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"rewardTokenLidont\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"rewardTokenRocket\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"precision\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"bondValueLidont\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"bondValueRocket\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"tempLidont\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"dustLidont\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"tempRocket\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"dustRocket\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"stakes\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"tuple\",\"components\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"bondValueLidont\",\"type\":\"uint256\"},{\"name\":\"bondValueRocket\",\"type\":\"uint256\"}]}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"totalStake\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"rocketSwapRouter\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]}]","ContractName":"Vyper_contract","CompilerVersion":"vyper:0.3.10","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"000000000000000000000000f68513fc61a040a29f3947ffff47a42e7c81082b000000000000000000000000272347f941fb5f35854d8f5dbdcedef1a515db410000000000000000000000001d8f8f00cfa6758d7be78336684788fb0ee0fa46","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":""}]}