{"status":"1","message":"OK","result":[{"SourceCode":"# @version 0.3.9\r\n\r\n\"\"\"\r\n@title CurveDeposit&StakeZap\r\n@author Curve.Fi\r\n@license Copyright (c) Curve.Fi, 2020-2023 - all rights reserved\r\n@notice A zap to add liquidity to pool and deposit into gauge in one transaction\r\n\"\"\"\r\n\r\nMAX_COINS: constant(uint256) = 8\r\nETH_ADDRESS: constant(address) = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\r\n\r\n# External Contracts\r\ninterface ERC20:\r\n    def transfer(_receiver: address, _amount: uint256): nonpayable\r\n    def transferFrom(_sender: address, _receiver: address, _amount: uint256): nonpayable\r\n    def approve(_spender: address, _amount: uint256): nonpayable\r\n    def decimals() -> uint256: view\r\n    def balanceOf(_owner: address) -> uint256: view\r\n    def allowance(_owner : address, _spender : address) -> uint256: view\r\n\r\ninterface Pool2:\r\n    def add_liquidity(amounts: uint256[2], min_mint_amount: uint256): payable\r\n\r\ninterface Pool3:\r\n    def add_liquidity(amounts: uint256[3], min_mint_amount: uint256): payable\r\n\r\ninterface Pool4:\r\n    def add_liquidity(amounts: uint256[4], min_mint_amount: uint256): payable\r\n\r\ninterface Pool5:\r\n    def add_liquidity(amounts: uint256[5], min_mint_amount: uint256): payable\r\n\r\ninterface Pool6:\r\n    def add_liquidity(amounts: uint256[6], min_mint_amount: uint256): payable\r\n\r\ninterface PoolUseUnderlying2:\r\n    def add_liquidity(amounts: uint256[2], min_mint_amount: uint256, use_underlying: bool): payable\r\n\r\ninterface PoolUseUnderlying3:\r\n    def add_liquidity(amounts: uint256[3], min_mint_amount: uint256, use_underlying: bool): payable\r\n\r\ninterface PoolUseUnderlying4:\r\n    def add_liquidity(amounts: uint256[4], min_mint_amount: uint256, use_underlying: bool): payable\r\n\r\ninterface PoolUseUnderlying5:\r\n    def add_liquidity(amounts: uint256[5], min_mint_amount: uint256, use_underlying: bool): payable\r\n\r\ninterface PoolUseUnderlying6:\r\n    def add_liquidity(amounts: uint256[6], min_mint_amount: uint256, use_underlying: bool): payable\r\n\r\ninterface PoolFactory2:\r\n    def add_liquidity(pool: address, amounts: uint256[2], min_mint_amount: uint256): payable\r\n\r\ninterface PoolFactory3:\r\n    def add_liquidity(pool: address, amounts: uint256[3], min_mint_amount: uint256): payable\r\n\r\ninterface PoolFactory4:\r\n    def add_liquidity(pool: address, amounts: uint256[4], min_mint_amount: uint256): payable\r\n\r\ninterface PoolFactory5:\r\n    def add_liquidity(pool: address, amounts: uint256[5], min_mint_amount: uint256): payable\r\n\r\ninterface PoolFactory6:  # CRV/ATRICRYPTO, MATIC/ATRICRYPTO\r\n    def add_liquidity(pool: address, amounts: uint256[6], min_mint_amount: uint256, use_eth: bool): payable\r\n\r\ninterface PoolStableNg:\r\n    def add_liquidity(_amounts: DynArray[uint256, MAX_COINS], _min_mint_amount: uint256): nonpayable\r\n\r\ninterface Gauge:\r\n    def deposit(lp_token_amount: uint256, addr: address): nonpayable\r\n\r\n\r\nallowance: public(HashMap[address, HashMap[address, bool]])\r\ngauge_allowance: HashMap[address, bool]\r\n\r\n\r\n@internal\r\ndef _add_liquidity(\r\n        deposit: address,\r\n        n_coins: uint256,\r\n        amounts: DynArray[uint256, MAX_COINS],\r\n        min_mint_amount: uint256,\r\n        eth_value: uint256,\r\n        use_underlying: bool,\r\n        is_plain_stable_ng: bool,\r\n        pool: address\r\n):\r\n    if is_plain_stable_ng:\r\n        PoolStableNg(deposit).add_liquidity(amounts, min_mint_amount)\r\n    elif pool != empty(address):\r\n        if n_coins == 2:\r\n            PoolFactory2(deposit).add_liquidity(pool, [amounts[0], amounts[1]], min_mint_amount, value=eth_value)\r\n        elif n_coins == 3:\r\n            PoolFactory3(deposit).add_liquidity(pool, [amounts[0], amounts[1], amounts[2]], min_mint_amount, value=eth_value)\r\n        elif n_coins == 4:\r\n            PoolFactory4(deposit).add_liquidity(pool, [amounts[0], amounts[1], amounts[2], amounts[3]], min_mint_amount, value=eth_value)\r\n        elif n_coins == 5:\r\n            PoolFactory5(deposit).add_liquidity(pool, [amounts[0], amounts[1], amounts[2], amounts[3], amounts[4]], min_mint_amount, value=eth_value)\r\n        elif n_coins == 6:\r\n            PoolFactory6(deposit).add_liquidity(pool, [amounts[0], amounts[1], amounts[2], amounts[3], amounts[4], amounts[5]], min_mint_amount, True, value=eth_value)\r\n        else:\r\n            raise\r\n    elif use_underlying:\r\n        if n_coins == 2:\r\n            PoolUseUnderlying2(deposit).add_liquidity([amounts[0], amounts[1]], min_mint_amount, True, value=eth_value)\r\n        elif n_coins == 3:\r\n            PoolUseUnderlying3(deposit).add_liquidity([amounts[0], amounts[1], amounts[2]], min_mint_amount, True, value=eth_value)\r\n        elif n_coins == 4:\r\n            PoolUseUnderlying4(deposit).add_liquidity([amounts[0], amounts[1], amounts[2], amounts[3]], min_mint_amount, True, value=eth_value)\r\n        elif n_coins == 5:\r\n            PoolUseUnderlying5(deposit).add_liquidity([amounts[0], amounts[1], amounts[2], amounts[3], amounts[4]], min_mint_amount, True, value=eth_value)\r\n        elif n_coins == 6:\r\n            PoolUseUnderlying6(deposit).add_liquidity([amounts[0], amounts[1], amounts[2], amounts[3], amounts[4], amounts[5]], min_mint_amount, True, value=eth_value)\r\n        else:\r\n            raise\r\n    else:\r\n        if n_coins == 2:\r\n            Pool2(deposit).add_liquidity([amounts[0], amounts[1]], min_mint_amount, value=eth_value)\r\n        elif n_coins == 3:\r\n            Pool3(deposit).add_liquidity([amounts[0], amounts[1], amounts[2]], min_mint_amount, value=eth_value)\r\n        elif n_coins == 4:\r\n            Pool4(deposit).add_liquidity([amounts[0], amounts[1], amounts[2], amounts[3]], min_mint_amount, value=eth_value)\r\n        elif n_coins == 5:\r\n            Pool5(deposit).add_liquidity([amounts[0], amounts[1], amounts[2], amounts[3], amounts[4]], min_mint_amount, value=eth_value)\r\n        elif n_coins == 6:\r\n            Pool6(deposit).add_liquidity([amounts[0], amounts[1], amounts[2], amounts[3], amounts[4], amounts[5]], min_mint_amount, value=eth_value)\r\n        else:\r\n            raise\r\n\r\n\r\n@payable\r\n@external\r\n@nonreentrant('lock')\r\ndef deposit_and_stake(\r\n        deposit: address,\r\n        lp_token: address,\r\n        gauge: address,\r\n        n_coins: uint256,\r\n        coins: DynArray[address, MAX_COINS],\r\n        amounts: DynArray[uint256, MAX_COINS],\r\n        min_mint_amount: uint256,\r\n        use_underlying: bool, # for aave, saave, ib (use_underlying) and crveth, cvxeth (use_eth)\r\n        is_plain_stable_ng: bool,\r\n        pool: address = empty(address), # for factory\r\n):\r\n    assert n_coins >= 2, 'n_coins must be >=2'\r\n    assert n_coins <= MAX_COINS, 'n_coins must be <=MAX_COINS'\r\n\r\n    # Ensure allowance for swap or zap\r\n    for i in range(MAX_COINS):\r\n        if i >= n_coins:\r\n            break\r\n\r\n        if coins[i] == ETH_ADDRESS or amounts[i] == 0 or self.allowance[deposit][coins[i]]:\r\n            continue\r\n\r\n        self.allowance[deposit][coins[i]] = True\r\n        ERC20(coins[i]).approve(deposit, max_value(uint256))\r\n\r\n    # Ensure allowance for gauge\r\n    if not self.gauge_allowance[gauge]:\r\n        self.gauge_allowance[gauge] = True\r\n        ERC20(lp_token).approve(gauge, max_value(uint256))\r\n\r\n    # Transfer coins from owner\r\n    has_eth: bool = False\r\n    for i in range(MAX_COINS):\r\n        if i >= n_coins:\r\n            break\r\n\r\n        if coins[i] == ETH_ADDRESS:\r\n            assert msg.value == amounts[i]\r\n            has_eth = True\r\n            continue\r\n\r\n        if amounts[i] > 0:\r\n            # \"safeTransferFrom\" which works for ERC20s which return bool or not\r\n            _response: Bytes[32] = raw_call(\r\n                coins[i],\r\n                concat(\r\n                    method_id(\"transferFrom(address,address,uint256)\"),\r\n                    convert(msg.sender, bytes32),\r\n                    convert(self, bytes32),\r\n                    convert(amounts[i], bytes32),\r\n                ),\r\n                max_outsize=32,\r\n            )  # dev: failed transfer\r\n            if len(_response) > 0:\r\n                assert convert(_response, bool)  # dev: failed transfer\r\n\r\n    if not has_eth:\r\n        assert msg.value == 0\r\n\r\n    # Reverts if n_coins is wrong\r\n    self._add_liquidity(deposit, n_coins, amounts, min_mint_amount, msg.value, use_underlying, is_plain_stable_ng, pool)\r\n\r\n    lp_token_amount: uint256 = ERC20(lp_token).balanceOf(self)\r\n    assert lp_token_amount > 0 # dev: swap-token mismatch\r\n\r\n    Gauge(gauge).deposit(lp_token_amount, msg.sender)\r\n\r\n\r\n@payable\r\n@external\r\ndef __default__():\r\n    pass","ABI":"[{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"deposit_and_stake\",\"inputs\":[{\"name\":\"deposit\",\"type\":\"address\"},{\"name\":\"lp_token\",\"type\":\"address\"},{\"name\":\"gauge\",\"type\":\"address\"},{\"name\":\"n_coins\",\"type\":\"uint256\"},{\"name\":\"coins\",\"type\":\"address[]\"},{\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"name\":\"min_mint_amount\",\"type\":\"uint256\"},{\"name\":\"use_underlying\",\"type\":\"bool\"},{\"name\":\"is_plain_stable_ng\",\"type\":\"bool\"}],\"outputs\":[]},{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"deposit_and_stake\",\"inputs\":[{\"name\":\"deposit\",\"type\":\"address\"},{\"name\":\"lp_token\",\"type\":\"address\"},{\"name\":\"gauge\",\"type\":\"address\"},{\"name\":\"n_coins\",\"type\":\"uint256\"},{\"name\":\"coins\",\"type\":\"address[]\"},{\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"name\":\"min_mint_amount\",\"type\":\"uint256\"},{\"name\":\"use_underlying\",\"type\":\"bool\"},{\"name\":\"is_plain_stable_ng\",\"type\":\"bool\"},{\"name\":\"pool\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"allowance\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"},{\"name\":\"arg1\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]}]","ContractName":"CurveDeposit&amp;StakeZap","CompilerVersion":"vyper:0.3.9","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":""}]}