{"status":"1","message":"OK","result":[{"SourceCode":"# pragma version 0.3.10\r\n# pragma optimize gas\r\n# pragma evm-version paris\r\n\"\"\"\r\n@title CurveTwocryptoFactory\r\n@author Curve.Fi\r\n@license Copyright (c) Curve.Fi, 2020-2023 - all rights reserved\r\n@notice Permissionless 2-coin cryptoswap pool deployer and registry\r\n\"\"\"\r\n\r\ninterface TwocryptoPool:\r\n    def balances(i: uint256) -> uint256: view\r\n\r\ninterface ERC20:\r\n    def decimals() -> uint256: view\r\n\r\n\r\nevent TwocryptoPoolDeployed:\r\n    pool: address\r\n    name: String[64]\r\n    symbol: String[32]\r\n    coins: address[N_COINS]\r\n    math: address\r\n    salt: bytes32\r\n    precisions: uint256[N_COINS]\r\n    packed_A_gamma: uint256\r\n    packed_fee_params: uint256\r\n    packed_rebalancing_params: uint256\r\n    packed_prices: uint256\r\n    deployer: address\r\n\r\n\r\nevent LiquidityGaugeDeployed:\r\n    pool: address\r\n    gauge: address\r\n\r\nevent UpdateFeeReceiver:\r\n    _old_fee_receiver: address\r\n    _new_fee_receiver: address\r\n\r\nevent UpdatePoolImplementation:\r\n    _implemention_id: uint256\r\n    _old_pool_implementation: address\r\n    _new_pool_implementation: address\r\n\r\nevent UpdateGaugeImplementation:\r\n    _old_gauge_implementation: address\r\n    _new_gauge_implementation: address\r\n\r\nevent UpdateMathImplementation:\r\n    _old_math_implementation: address\r\n    _new_math_implementation: address\r\n\r\nevent UpdateViewsImplementation:\r\n    _old_views_implementation: address\r\n    _new_views_implementation: address\r\n\r\nevent TransferOwnership:\r\n    _old_owner: address\r\n    _new_owner: address\r\n\r\n\r\nstruct PoolArray:\r\n    liquidity_gauge: address\r\n    coins: address[N_COINS]\r\n    decimals: uint256[N_COINS]\r\n    implementation: address\r\n\r\n\r\nN_COINS: constant(uint256) = 2\r\nA_MULTIPLIER: constant(uint256) = 10000\r\n\r\n# Limits\r\nMAX_FEE: constant(uint256) = 10 * 10 ** 9\r\n\r\ndeployer: address\r\nadmin: public(address)\r\nfuture_admin: public(address)\r\n\r\n# fee receiver for all pools:\r\nfee_receiver: public(address)\r\n\r\npool_implementations: public(HashMap[uint256, address])\r\ngauge_implementation: public(address)\r\nviews_implementation: public(address)\r\nmath_implementation: public(address)\r\n\r\n# mapping of coins -> pools for trading\r\n# a mapping key is generated for each pair of addresses via\r\n# `bitwise_xor(convert(a, uint256), convert(b, uint256))`\r\nmarkets: HashMap[uint256, DynArray[address, 4294967296]]\r\npool_data: HashMap[address, PoolArray]\r\npool_list: public(DynArray[address, 4294967296])   # master list of pools\r\n\r\n\r\n@external\r\ndef __init__():\r\n    self.deployer = tx.origin\r\n\r\n\r\n@external\r\ndef initialise_ownership(_fee_receiver: address, _admin: address):\r\n\r\n    assert msg.sender == self.deployer\r\n    assert self.admin == empty(address)\r\n\r\n    self.fee_receiver = _fee_receiver\r\n    self.admin = _admin\r\n\r\n    log UpdateFeeReceiver(empty(address), _fee_receiver)\r\n    log TransferOwnership(empty(address), _admin)\r\n\r\n\r\n@internal\r\n@pure\r\ndef _pack_3(x: uint256[3]) -> uint256:\r\n    \"\"\"\r\n    @notice Packs 3 integers with values <= 10**18 into a uint256\r\n    @param x The uint256[3] to pack\r\n    @return The packed uint256\r\n    \"\"\"\r\n    return (x[0] << 128) | (x[1] << 64) | x[2]\r\n\r\n\r\n@pure\r\n@internal\r\ndef _pack_2(p1: uint256, p2: uint256) -> uint256:\r\n    return p1 | (p2 << 128)\r\n\r\n\r\n# <--- Pool Deployers --->\r\n\r\n@external\r\ndef deploy_pool(\r\n    _name: String[64],\r\n    _symbol: String[32],\r\n    _coins: address[N_COINS],\r\n    implementation_id: uint256,\r\n    A: uint256,\r\n    gamma: uint256,\r\n    mid_fee: uint256,\r\n    out_fee: uint256,\r\n    fee_gamma: uint256,\r\n    allowed_extra_profit: uint256,\r\n    adjustment_step: uint256,\r\n    ma_exp_time: uint256,\r\n    initial_price: uint256,\r\n) -> address:\r\n    \"\"\"\r\n    @notice Deploy a new pool\r\n    @param _name Name of the new plain pool\r\n    @param _symbol Symbol for the new plain pool - will be concatenated with factory symbol\r\n\r\n    @return Address of the deployed pool\r\n    \"\"\"\r\n    pool_implementation: address = self.pool_implementations[implementation_id]\r\n    _math_implementation: address = self.math_implementation\r\n    assert pool_implementation != empty(address), \"Pool implementation not set\"\r\n    assert _math_implementation != empty(address), \"Math implementation not set\"\r\n\r\n    assert mid_fee < MAX_FEE-1  # mid_fee can be zero\r\n    assert out_fee >= mid_fee\r\n    assert out_fee < MAX_FEE-1\r\n    assert fee_gamma < 10**18+1\r\n    assert fee_gamma > 0\r\n\r\n    assert allowed_extra_profit < 10**18+1\r\n\r\n    assert adjustment_step < 10**18+1\r\n    assert adjustment_step > 0\r\n\r\n    assert ma_exp_time < 872542  # 7 * 24 * 60 * 60 / ln(2)\r\n    assert ma_exp_time > 86  # 60 / ln(2)\r\n\r\n    assert initial_price > 10**6 and initial_price < 10**30  # dev: initial price out of bound\r\n\r\n    assert _coins[0] != _coins[1], \"Duplicate coins\"\r\n\r\n    decimals: uint256[N_COINS] = empty(uint256[N_COINS])\r\n    precisions: uint256[N_COINS] = empty(uint256[N_COINS])\r\n    for i in range(N_COINS):\r\n        d: uint256 = ERC20(_coins[i]).decimals()\r\n        assert d < 19, \"Max 18 decimals for coins\"\r\n        decimals[i] = d\r\n        precisions[i] = 10 ** (18 - d)\r\n\r\n    # pack precision\r\n    packed_precisions: uint256 = self._pack_2(precisions[0], precisions[1])\r\n\r\n    # pack fees\r\n    packed_fee_params: uint256 = self._pack_3(\r\n        [mid_fee, out_fee, fee_gamma]\r\n    )\r\n\r\n    # pack liquidity rebalancing params\r\n    packed_rebalancing_params: uint256 = self._pack_3(\r\n        [allowed_extra_profit, adjustment_step, ma_exp_time]\r\n    )\r\n\r\n    # pack gamma and A\r\n    packed_gamma_A: uint256 = self._pack_2(gamma, A)\r\n\r\n    # pool is an ERC20 implementation\r\n    _salt: bytes32 = block.prevhash\r\n    pool: address = create_from_blueprint(\r\n        pool_implementation,  # blueprint: address\r\n        _name,  # String[64]\r\n        _symbol,  # String[32]\r\n        _coins,  # address[N_COINS]\r\n        _math_implementation,  # address\r\n        _salt,  # bytes32\r\n        packed_precisions,  # uint256\r\n        packed_gamma_A,  # uint256\r\n        packed_fee_params,  # uint256\r\n        packed_rebalancing_params,  # uint256\r\n        initial_price,  # uint256\r\n        code_offset=3,\r\n    )\r\n\r\n    # populate pool data\r\n    self.pool_list.append(pool)\r\n\r\n    self.pool_data[pool].decimals = decimals\r\n    self.pool_data[pool].coins = _coins\r\n    self.pool_data[pool].implementation = pool_implementation\r\n\r\n    # add coins to market:\r\n    self._add_coins_to_market(_coins[0], _coins[1], pool)\r\n\r\n    log TwocryptoPoolDeployed(\r\n        pool,\r\n        _name,\r\n        _symbol,\r\n        _coins,\r\n        _math_implementation,\r\n        _salt,\r\n        precisions,\r\n        packed_gamma_A,\r\n        packed_fee_params,\r\n        packed_rebalancing_params,\r\n        initial_price,\r\n        msg.sender,\r\n    )\r\n\r\n    return pool\r\n\r\n\r\n@internal\r\ndef _add_coins_to_market(coin_a: address, coin_b: address, pool: address):\r\n\r\n    key: uint256 = (\r\n        convert(coin_a, uint256) ^ convert(coin_b, uint256)\r\n    )\r\n    self.markets[key].append(pool)\r\n\r\n\r\n@external\r\ndef deploy_gauge(_pool: address) -> address:\r\n    \"\"\"\r\n    @notice Deploy a liquidity gauge for a factory pool\r\n    @param _pool Factory pool address to deploy a gauge for\r\n    @return Address of the deployed gauge\r\n    \"\"\"\r\n    assert self.pool_data[_pool].coins[0] != empty(address), \"Unknown pool\"\r\n    assert self.pool_data[_pool].liquidity_gauge == empty(address), \"Gauge already deployed\"\r\n    assert self.gauge_implementation != empty(address), \"Gauge implementation not set\"\r\n\r\n    gauge: address = create_from_blueprint(self.gauge_implementation, _pool, code_offset=3)\r\n    self.pool_data[_pool].liquidity_gauge = gauge\r\n\r\n    log LiquidityGaugeDeployed(_pool, gauge)\r\n    return gauge\r\n\r\n\r\n# <--- Admin / Guarded Functionality --->\r\n\r\n\r\n@external\r\ndef set_fee_receiver(_fee_receiver: address):\r\n    \"\"\"\r\n    @notice Set fee receiver\r\n    @param _fee_receiver Address that fees are sent to\r\n    \"\"\"\r\n    assert msg.sender == self.admin, \"dev: admin only\"\r\n\r\n    log UpdateFeeReceiver(self.fee_receiver, _fee_receiver)\r\n    self.fee_receiver = _fee_receiver\r\n\r\n\r\n@external\r\ndef set_pool_implementation(\r\n    _pool_implementation: address, _implementation_index: uint256\r\n):\r\n    \"\"\"\r\n    @notice Set pool implementation\r\n    @dev Set to empty(address) to prevent deployment of new pools\r\n    @param _pool_implementation Address of the new pool implementation\r\n    @param _implementation_index Index of the pool implementation\r\n    \"\"\"\r\n    assert msg.sender == self.admin, \"dev: admin only\"\r\n\r\n    log UpdatePoolImplementation(\r\n        _implementation_index,\r\n        self.pool_implementations[_implementation_index],\r\n        _pool_implementation\r\n    )\r\n\r\n    self.pool_implementations[_implementation_index] = _pool_implementation\r\n\r\n\r\n@external\r\ndef set_gauge_implementation(_gauge_implementation: address):\r\n    \"\"\"\r\n    @notice Set gauge implementation\r\n    @dev Set to empty(address) to prevent deployment of new gauges\r\n    @param _gauge_implementation Address of the new token implementation\r\n    \"\"\"\r\n    assert msg.sender == self.admin, \"dev: admin only\"\r\n\r\n    log UpdateGaugeImplementation(self.gauge_implementation, _gauge_implementation)\r\n    self.gauge_implementation = _gauge_implementation\r\n\r\n\r\n@external\r\ndef set_views_implementation(_views_implementation: address):\r\n    \"\"\"\r\n    @notice Set views contract implementation\r\n    @param _views_implementation Address of the new views contract\r\n    \"\"\"\r\n    assert msg.sender == self.admin,  \"dev: admin only\"\r\n\r\n    log UpdateViewsImplementation(self.views_implementation, _views_implementation)\r\n    self.views_implementation = _views_implementation\r\n\r\n\r\n@external\r\ndef set_math_implementation(_math_implementation: address):\r\n    \"\"\"\r\n    @notice Set math implementation\r\n    @param _math_implementation Address of the new math contract\r\n    \"\"\"\r\n    assert msg.sender == self.admin, \"dev: admin only\"\r\n\r\n    log UpdateMathImplementation(self.math_implementation, _math_implementation)\r\n    self.math_implementation = _math_implementation\r\n\r\n\r\n@external\r\ndef commit_transfer_ownership(_addr: address):\r\n    \"\"\"\r\n    @notice Transfer ownership of this contract to `addr`\r\n    @param _addr Address of the new owner\r\n    \"\"\"\r\n    assert msg.sender == self.admin, \"dev: admin only\"\r\n\r\n    self.future_admin = _addr\r\n\r\n\r\n@external\r\ndef accept_transfer_ownership():\r\n    \"\"\"\r\n    @notice Accept a pending ownership transfer\r\n    @dev Only callable by the new owner\r\n    \"\"\"\r\n    assert msg.sender == self.future_admin, \"dev: future admin only\"\r\n\r\n    log TransferOwnership(self.admin, msg.sender)\r\n    self.admin = msg.sender\r\n\r\n\r\n# <--- Factory Getters --->\r\n\r\n\r\n@view\r\n@external\r\ndef find_pool_for_coins(_from: address, _to: address, i: uint256 = 0) -> address:\r\n    \"\"\"\r\n    @notice Find an available pool for exchanging two coins\r\n    @param _from Address of coin to be sent\r\n    @param _to Address of coin to be received\r\n    @param i Index value. When multiple pools are available\r\n            this value is used to return the n'th address.\r\n    @return Pool address\r\n    \"\"\"\r\n    key: uint256 = convert(_from, uint256) ^ convert(_to, uint256)\r\n    return self.markets[key][i]\r\n\r\n\r\n# <--- Pool Getters --->\r\n\r\n\r\n@view\r\n@external\r\ndef pool_count() -> uint256:\r\n    \"\"\"\r\n    @notice Get number of pools deployed from the factory\r\n    @return Number of pools deployed from factory\r\n    \"\"\"\r\n    return len(self.pool_list)\r\n\r\n\r\n@view\r\n@external\r\ndef get_coins(_pool: address) -> address[N_COINS]:\r\n    \"\"\"\r\n    @notice Get the coins within a pool\r\n    @param _pool Pool address\r\n    @return List of coin addresses\r\n    \"\"\"\r\n    return self.pool_data[_pool].coins\r\n\r\n\r\n@view\r\n@external\r\ndef get_decimals(_pool: address) -> uint256[N_COINS]:\r\n    \"\"\"\r\n    @notice Get decimal places for each coin within a pool\r\n    @param _pool Pool address\r\n    @return uint256 list of decimals\r\n    \"\"\"\r\n    return self.pool_data[_pool].decimals\r\n\r\n\r\n@view\r\n@external\r\ndef get_balances(_pool: address) -> uint256[N_COINS]:\r\n    \"\"\"\r\n    @notice Get balances for each coin within a pool\r\n    @dev For pools using lending, these are the wrapped coin balances\r\n    @param _pool Pool address\r\n    @return uint256 list of balances\r\n    \"\"\"\r\n    return [TwocryptoPool(_pool).balances(0), TwocryptoPool(_pool).balances(1)]\r\n\r\n\r\n@view\r\n@external\r\ndef get_coin_indices(\r\n    _pool: address,\r\n    _from: address,\r\n    _to: address\r\n) -> (uint256, uint256):\r\n    \"\"\"\r\n    @notice Convert coin addresses to indices for use with pool methods\r\n    @param _pool Pool address\r\n    @param _from Coin address to be used as `i` within a pool\r\n    @param _to Coin address to be used as `j` within a pool\r\n    @return uint256 `i`, uint256 `j`\r\n    \"\"\"\r\n    coins: address[2] = self.pool_data[_pool].coins\r\n\r\n    if _from == coins[0] and _to == coins[1]:\r\n        return 0, 1\r\n    elif _from == coins[1] and _to == coins[0]:\r\n        return 1, 0\r\n    else:\r\n        raise \"Coins not found\"\r\n\r\n\r\n@view\r\n@external\r\ndef get_gauge(_pool: address) -> address:\r\n    \"\"\"\r\n    @notice Get the address of the liquidity gauge contract for a factory pool\r\n    @dev Returns `empty(address)` if a gauge has not been deployed\r\n    @param _pool Pool address\r\n    @return Implementation contract address\r\n    \"\"\"\r\n    return self.pool_data[_pool].liquidity_gauge\r\n\r\n\r\n@view\r\n@external\r\ndef get_market_counts(coin_a: address, coin_b: address) -> uint256:\r\n    \"\"\"\r\n    @notice Gets the number of markets with the specified coins.\r\n    @return Number of pools with the input coins\r\n    \"\"\"\r\n\r\n    key: uint256 = (\r\n        convert(coin_a, uint256) ^ convert(coin_b, uint256)\r\n    )\r\n\r\n    return len(self.markets[key])","ABI":"[{\"name\":\"TwocryptoPoolDeployed\",\"inputs\":[{\"name\":\"pool\",\"type\":\"address\",\"indexed\":false},{\"name\":\"name\",\"type\":\"string\",\"indexed\":false},{\"name\":\"symbol\",\"type\":\"string\",\"indexed\":false},{\"name\":\"coins\",\"type\":\"address[2]\",\"indexed\":false},{\"name\":\"math\",\"type\":\"address\",\"indexed\":false},{\"name\":\"salt\",\"type\":\"bytes32\",\"indexed\":false},{\"name\":\"precisions\",\"type\":\"uint256[2]\",\"indexed\":false},{\"name\":\"packed_A_gamma\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"packed_fee_params\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"packed_rebalancing_params\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"packed_prices\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"deployer\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"LiquidityGaugeDeployed\",\"inputs\":[{\"name\":\"pool\",\"type\":\"address\",\"indexed\":false},{\"name\":\"gauge\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"UpdateFeeReceiver\",\"inputs\":[{\"name\":\"_old_fee_receiver\",\"type\":\"address\",\"indexed\":false},{\"name\":\"_new_fee_receiver\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"UpdatePoolImplementation\",\"inputs\":[{\"name\":\"_implemention_id\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"_old_pool_implementation\",\"type\":\"address\",\"indexed\":false},{\"name\":\"_new_pool_implementation\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"UpdateGaugeImplementation\",\"inputs\":[{\"name\":\"_old_gauge_implementation\",\"type\":\"address\",\"indexed\":false},{\"name\":\"_new_gauge_implementation\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"UpdateMathImplementation\",\"inputs\":[{\"name\":\"_old_math_implementation\",\"type\":\"address\",\"indexed\":false},{\"name\":\"_new_math_implementation\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"UpdateViewsImplementation\",\"inputs\":[{\"name\":\"_old_views_implementation\",\"type\":\"address\",\"indexed\":false},{\"name\":\"_new_views_implementation\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"TransferOwnership\",\"inputs\":[{\"name\":\"_old_owner\",\"type\":\"address\",\"indexed\":false},{\"name\":\"_new_owner\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"initialise_ownership\",\"inputs\":[{\"name\":\"_fee_receiver\",\"type\":\"address\"},{\"name\":\"_admin\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"deploy_pool\",\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"},{\"name\":\"_coins\",\"type\":\"address[2]\"},{\"name\":\"implementation_id\",\"type\":\"uint256\"},{\"name\":\"A\",\"type\":\"uint256\"},{\"name\":\"gamma\",\"type\":\"uint256\"},{\"name\":\"mid_fee\",\"type\":\"uint256\"},{\"name\":\"out_fee\",\"type\":\"uint256\"},{\"name\":\"fee_gamma\",\"type\":\"uint256\"},{\"name\":\"allowed_extra_profit\",\"type\":\"uint256\"},{\"name\":\"adjustment_step\",\"type\":\"uint256\"},{\"name\":\"ma_exp_time\",\"type\":\"uint256\"},{\"name\":\"initial_price\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"deploy_gauge\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_fee_receiver\",\"inputs\":[{\"name\":\"_fee_receiver\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_pool_implementation\",\"inputs\":[{\"name\":\"_pool_implementation\",\"type\":\"address\"},{\"name\":\"_implementation_index\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_gauge_implementation\",\"inputs\":[{\"name\":\"_gauge_implementation\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_views_implementation\",\"inputs\":[{\"name\":\"_views_implementation\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_math_implementation\",\"inputs\":[{\"name\":\"_math_implementation\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"commit_transfer_ownership\",\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"accept_transfer_ownership\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"find_pool_for_coins\",\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"find_pool_for_coins\",\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"i\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"pool_count\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_coins\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address[2]\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_decimals\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256[2]\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_balances\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256[2]\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_coin_indices\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_gauge\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_market_counts\",\"inputs\":[{\"name\":\"coin_a\",\"type\":\"address\"},{\"name\":\"coin_b\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"admin\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"future_admin\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"fee_receiver\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"pool_implementations\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"gauge_implementation\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"views_implementation\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"math_implementation\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"pool_list\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]}]","ContractName":"CurveTwocryptoFactory","CompilerVersion":"vyper:0.3.10","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":""}]}