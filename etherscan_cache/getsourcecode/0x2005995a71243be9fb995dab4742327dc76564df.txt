{"status":"1","message":"OK","result":[{"SourceCode":"# pragma version 0.3.10\r\n# pragma optimize gas\r\n# pragma evm-version paris\r\n# (c) Curve.Fi, 2020-2023\r\n# AMM Math for 2-coin Curve Cryptoswap Pools\r\n#\r\n# Unless otherwise agreed on, only contracts owned by Curve DAO or\r\n# Swiss Stake GmbH are allowed to call this contract.\r\n\r\n\"\"\"\r\n@title CurveTwocryptoMathOptimized\r\n@author Curve.Fi\r\n@license Copyright (c) Curve.Fi, 2020-2023 - all rights reserved\r\n@notice Curve AMM Math for 2 unpegged assets (e.g. ETH <> USD).\r\n\"\"\"\r\n\r\nN_COINS: constant(uint256) = 2\r\nA_MULTIPLIER: constant(uint256) = 10000\r\n\r\nMIN_GAMMA: constant(uint256) = 10**10\r\nMAX_GAMMA: constant(uint256) = 2 * 10**15\r\n\r\nMIN_A: constant(uint256) = N_COINS**N_COINS * A_MULTIPLIER / 10\r\nMAX_A: constant(uint256) = N_COINS**N_COINS * A_MULTIPLIER * 1000\r\n\r\nversion: public(constant(String[8])) = \"v2.0.0\"\r\n\r\n\r\n# ------------------------ AMM math functions --------------------------------\r\n\r\n\r\n@internal\r\n@pure\r\ndef _snekmate_log_2(x: uint256, roundup: bool) -> uint256:\r\n    \"\"\"\r\n    @notice An `internal` helper function that returns the log in base 2\r\n         of `x`, following the selected rounding direction.\r\n    @dev This implementation is derived from Snekmate, which is authored\r\n         by pcaversaccio (Snekmate), distributed under the AGPL-3.0 license.\r\n         https://github.com/pcaversaccio/snekmate\r\n    @dev Note that it returns 0 if given 0. The implementation is\r\n         inspired by OpenZeppelin's implementation here:\r\n         https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/Math.sol.\r\n    @param x The 32-byte variable.\r\n    @param roundup The Boolean variable that specifies whether\r\n           to round up or not. The default `False` is round down.\r\n    @return uint256 The 32-byte calculation result.\r\n    \"\"\"\r\n    value: uint256 = x\r\n    result: uint256 = empty(uint256)\r\n\r\n    # The following lines cannot overflow because we have the well-known\r\n    # decay behaviour of `log_2(max_value(uint256)) < max_value(uint256)`.\r\n    if x >> 128 != empty(uint256):\r\n        value = x >> 128\r\n        result = 128\r\n    if value >> 64 != empty(uint256):\r\n        value = value >> 64\r\n        result = unsafe_add(result, 64)\r\n    if value >> 32 != empty(uint256):\r\n        value = value >> 32\r\n        result = unsafe_add(result, 32)\r\n    if value >> 16 != empty(uint256):\r\n        value = value >> 16\r\n        result = unsafe_add(result, 16)\r\n    if value >> 8 != empty(uint256):\r\n        value = value >> 8\r\n        result = unsafe_add(result, 8)\r\n    if value >> 4 != empty(uint256):\r\n        value = value >> 4\r\n        result = unsafe_add(result, 4)\r\n    if value >> 2 != empty(uint256):\r\n        value = value >> 2\r\n        result = unsafe_add(result, 2)\r\n    if value >> 1 != empty(uint256):\r\n        result = unsafe_add(result, 1)\r\n\r\n    if (roundup and (1 << result) < x):\r\n        result = unsafe_add(result, 1)\r\n\r\n    return result\r\n\r\n\r\n@internal\r\n@pure\r\ndef _cbrt(x: uint256) -> uint256:\r\n\r\n    xx: uint256 = 0\r\n    if x >= 115792089237316195423570985008687907853269 * 10**18:\r\n        xx = x\r\n    elif x >= 115792089237316195423570985008687907853269:\r\n        xx = unsafe_mul(x, 10**18)\r\n    else:\r\n        xx = unsafe_mul(x, 10**36)\r\n\r\n    log2x: int256 = convert(self._snekmate_log_2(xx, False), int256)\r\n\r\n    # When we divide log2x by 3, the remainder is (log2x % 3).\r\n    # So if we just multiply 2**(log2x/3) and discard the remainder to calculate our\r\n    # guess, the newton method will need more iterations to converge to a solution,\r\n    # since it is missing that precision. It's a few more calculations now to do less\r\n    # calculations later:\r\n    # pow = log2(x) // 3\r\n    # remainder = log2(x) % 3\r\n    # initial_guess = 2 ** pow * cbrt(2) ** remainder\r\n    # substituting -> 2 = 1.26 ≈ 1260 / 1000, we get:\r\n    #\r\n    # initial_guess = 2 ** pow * 1260 ** remainder // 1000 ** remainder\r\n\r\n    remainder: uint256 = convert(log2x, uint256) % 3\r\n    a: uint256 = unsafe_div(\r\n        unsafe_mul(\r\n            pow_mod256(2, unsafe_div(convert(log2x, uint256), 3)),  # <- pow\r\n            pow_mod256(1260, remainder),\r\n        ),\r\n        pow_mod256(1000, remainder),\r\n    )\r\n\r\n    # Because we chose good initial values for cube roots, 7 newton raphson iterations\r\n    # are just about sufficient. 6 iterations would result in non-convergences, and 8\r\n    # would be one too many iterations. Without initial values, the iteration count\r\n    # can go up to 20 or greater. The iterations are unrolled. This reduces gas costs\r\n    # but takes up more bytecode:\r\n    a = unsafe_div(unsafe_add(unsafe_mul(2, a), unsafe_div(xx, unsafe_mul(a, a))), 3)\r\n    a = unsafe_div(unsafe_add(unsafe_mul(2, a), unsafe_div(xx, unsafe_mul(a, a))), 3)\r\n    a = unsafe_div(unsafe_add(unsafe_mul(2, a), unsafe_div(xx, unsafe_mul(a, a))), 3)\r\n    a = unsafe_div(unsafe_add(unsafe_mul(2, a), unsafe_div(xx, unsafe_mul(a, a))), 3)\r\n    a = unsafe_div(unsafe_add(unsafe_mul(2, a), unsafe_div(xx, unsafe_mul(a, a))), 3)\r\n    a = unsafe_div(unsafe_add(unsafe_mul(2, a), unsafe_div(xx, unsafe_mul(a, a))), 3)\r\n    a = unsafe_div(unsafe_add(unsafe_mul(2, a), unsafe_div(xx, unsafe_mul(a, a))), 3)\r\n\r\n    if x >= 115792089237316195423570985008687907853269 * 10**18:\r\n        a = unsafe_mul(a, 10**12)\r\n    elif x >= 115792089237316195423570985008687907853269:\r\n        a = unsafe_mul(a, 10**6)\r\n\r\n    return a\r\n\r\n\r\n@internal\r\n@pure\r\ndef _newton_y(ANN: uint256, gamma: uint256, x: uint256[N_COINS], D: uint256, i: uint256) -> uint256:\r\n    \"\"\"\r\n    Calculating x[i] given other balances x[0..N_COINS-1] and invariant D\r\n    ANN = A * N**N\r\n    This is computationally expensive.\r\n    \"\"\"\r\n\r\n    x_j: uint256 = x[1 - i]\r\n    y: uint256 = D**2 / (x_j * N_COINS**2)\r\n    K0_i: uint256 = (10**18 * N_COINS) * x_j / D\r\n\r\n    assert (K0_i > 10**16*N_COINS - 1) and (K0_i < 10**20*N_COINS + 1)  # dev: unsafe values x[i]\r\n\r\n    convergence_limit: uint256 = max(max(x_j / 10**14, D / 10**14), 100)\r\n\r\n    for j in range(255):\r\n        y_prev: uint256 = y\r\n\r\n        K0: uint256 = K0_i * y * N_COINS / D\r\n        S: uint256 = x_j + y\r\n\r\n        _g1k0: uint256 = gamma + 10**18\r\n        if _g1k0 > K0:\r\n            _g1k0 = _g1k0 - K0 + 1\r\n        else:\r\n            _g1k0 = K0 - _g1k0 + 1\r\n\r\n        # D / (A * N**N) * _g1k0**2 / gamma**2\r\n        mul1: uint256 = 10**18 * D / gamma * _g1k0 / gamma * _g1k0 * A_MULTIPLIER / ANN\r\n\r\n        # 2*K0 / _g1k0\r\n        mul2: uint256 = 10**18 + (2 * 10**18) * K0 / _g1k0\r\n\r\n        yfprime: uint256 = 10**18 * y + S * mul2 + mul1\r\n        _dyfprime: uint256 = D * mul2\r\n        if yfprime < _dyfprime:\r\n            y = y_prev / 2\r\n            continue\r\n        else:\r\n            yfprime -= _dyfprime\r\n        fprime: uint256 = yfprime / y\r\n\r\n        # y -= f / f_prime;  y = (y * fprime - f) / fprime\r\n        # y = (yfprime + 10**18 * D - 10**18 * S) // fprime + mul1 // fprime * (10**18 - K0) // K0\r\n        y_minus: uint256 = mul1 / fprime\r\n        y_plus: uint256 = (yfprime + 10**18 * D) / fprime + y_minus * 10**18 / K0\r\n        y_minus += 10**18 * S / fprime\r\n\r\n        if y_plus < y_minus:\r\n            y = y_prev / 2\r\n        else:\r\n            y = y_plus - y_minus\r\n\r\n        diff: uint256 = 0\r\n        if y > y_prev:\r\n            diff = y - y_prev\r\n        else:\r\n            diff = y_prev - y\r\n\r\n        if diff < max(convergence_limit, y / 10**14):\r\n            return y\r\n\r\n    raise \"Did not converge\"\r\n\r\n\r\n@external\r\n@pure\r\ndef newton_y(ANN: uint256, gamma: uint256, x: uint256[N_COINS], D: uint256, i: uint256) -> uint256:\r\n\r\n    # Safety checks\r\n    assert ANN > MIN_A - 1 and ANN < MAX_A + 1  # dev: unsafe values A\r\n    assert gamma > MIN_GAMMA - 1 and gamma < MAX_GAMMA + 1  # dev: unsafe values gamma\r\n    assert D > 10**17 - 1 and D < 10**15 * 10**18 + 1 # dev: unsafe values D\r\n\r\n    y: uint256 = self._newton_y(ANN, gamma, x, D, i)\r\n    frac: uint256 = y * 10**18 / D\r\n    assert (frac >= 10**16 - 1) and (frac < 10**20 + 1)  # dev: unsafe value for y\r\n\r\n    return y\r\n\r\n\r\n@external\r\n@pure\r\ndef get_y(\r\n    _ANN: uint256,\r\n    _gamma: uint256,\r\n    _x: uint256[N_COINS],\r\n    _D: uint256,\r\n    i: uint256\r\n) -> uint256[2]:\r\n\r\n    # Safety checks\r\n    assert _ANN > MIN_A - 1 and _ANN < MAX_A + 1  # dev: unsafe values A\r\n    assert _gamma > MIN_GAMMA - 1 and _gamma < MAX_GAMMA + 1  # dev: unsafe values gamma\r\n    assert _D > 10**17 - 1 and _D < 10**15 * 10**18 + 1 # dev: unsafe values D\r\n\r\n    ANN: int256 = convert(_ANN, int256)\r\n    gamma: int256 = convert(_gamma, int256)\r\n    D: int256 = convert(_D, int256)\r\n    x_j: int256 = convert(_x[1 - i], int256)\r\n    gamma2: int256 = unsafe_mul(gamma, gamma)\r\n\r\n    # savediv by x_j done here:\r\n    y: int256 = D**2 / (x_j * N_COINS**2)\r\n\r\n    # K0_i: int256 = (10**18 * N_COINS) * x_j / D\r\n    K0_i: int256 = unsafe_div(10**18 * N_COINS * x_j, D)\r\n    assert (K0_i > 10**16 * N_COINS - 1) and (K0_i < 10**20 * N_COINS + 1)  # dev: unsafe values x[i]\r\n\r\n    ann_gamma2: int256 = ANN * gamma2\r\n\r\n    # a = 10**36 / N_COINS**2\r\n    a: int256 = 10**32\r\n\r\n    # b = ANN*D*gamma2/4/10000/x_j/10**4 - 10**32*3 - 2*gamma*10**14\r\n    b: int256 = (\r\n        D*ann_gamma2/400000000/x_j\r\n        - convert(unsafe_mul(10**32, 3), int256)\r\n        - unsafe_mul(unsafe_mul(2, gamma), 10**14)\r\n    )\r\n\r\n    # c = 10**32*3 + 4*gamma*10**14 + gamma2/10**4 + 4*ANN*gamma2*x_j/D/10000/4/10**4 - 4*ANN*gamma2/10000/4/10**4\r\n    c: int256 = (\r\n        unsafe_mul(10**32, convert(3, int256))\r\n        + unsafe_mul(unsafe_mul(4, gamma), 10**14)\r\n        + unsafe_div(gamma2, 10**4)\r\n        + unsafe_div(unsafe_div(unsafe_mul(4, ann_gamma2), 400000000) * x_j, D)\r\n        - unsafe_div(unsafe_mul(4, ann_gamma2), 400000000)\r\n    )\r\n\r\n    # d = -(10**18+gamma)**2 / 10**4\r\n    d: int256 = -unsafe_div(unsafe_add(10**18, gamma) ** 2, 10**4)\r\n\r\n    # delta0: int256 = 3*a*c/b - b\r\n    delta0: int256 = 3 * a * c / b - b  # safediv by b\r\n\r\n    # delta1: int256 = 9*a*c/b - 2*b - 27*a**2/b*d/b\r\n    delta1: int256 = 3 * delta0 + b - 27*a**2/b*d/b\r\n\r\n    divider: int256 = 1\r\n    threshold: int256 = min(min(abs(delta0), abs(delta1)), a)\r\n    if threshold > 10**48:\r\n        divider = 10**30\r\n    elif threshold > 10**46:\r\n        divider = 10**28\r\n    elif threshold > 10**44:\r\n        divider = 10**26\r\n    elif threshold > 10**42:\r\n        divider = 10**24\r\n    elif threshold > 10**40:\r\n        divider = 10**22\r\n    elif threshold > 10**38:\r\n        divider = 10**20\r\n    elif threshold > 10**36:\r\n        divider = 10**18\r\n    elif threshold > 10**34:\r\n        divider = 10**16\r\n    elif threshold > 10**32:\r\n        divider = 10**14\r\n    elif threshold > 10**30:\r\n        divider = 10**12\r\n    elif threshold > 10**28:\r\n        divider = 10**10\r\n    elif threshold > 10**26:\r\n        divider = 10**8\r\n    elif threshold > 10**24:\r\n        divider = 10**6\r\n    elif threshold > 10**20:\r\n        divider = 10**2\r\n\r\n    a = unsafe_div(a, divider)\r\n    b = unsafe_div(b, divider)\r\n    c = unsafe_div(c, divider)\r\n    d = unsafe_div(d, divider)\r\n\r\n    # delta0 = 3*a*c/b - b: here we can do more unsafe ops now:\r\n    delta0 = unsafe_div(unsafe_mul(unsafe_mul(3, a), c), b) - b\r\n\r\n    # delta1 = 9*a*c/b - 2*b - 27*a**2/b*d/b\r\n    delta1 = 3 * delta0 + b - unsafe_div(unsafe_mul(unsafe_div(unsafe_mul(27, a**2), b), d), b)\r\n\r\n    # sqrt_arg: int256 = delta1**2 + 4*delta0**2/b*delta0\r\n    sqrt_arg: int256 = delta1**2 + unsafe_mul(unsafe_div(4*delta0**2, b), delta0)\r\n    sqrt_val: int256 = 0\r\n    if sqrt_arg > 0:\r\n        sqrt_val = convert(isqrt(convert(sqrt_arg, uint256)), int256)\r\n    else:\r\n        return [\r\n            self._newton_y(_ANN, _gamma, _x, _D, i),\r\n            0\r\n        ]\r\n\r\n    b_cbrt: int256 = 0\r\n    if b > 0:\r\n        b_cbrt = convert(self._cbrt(convert(b, uint256)), int256)\r\n    else:\r\n        b_cbrt = -convert(self._cbrt(convert(-b, uint256)), int256)\r\n\r\n    second_cbrt: int256 = 0\r\n    if delta1 > 0:\r\n        # second_cbrt = convert(self._cbrt(convert((delta1 + sqrt_val), uint256) / 2), int256)\r\n        second_cbrt = convert(self._cbrt(convert(unsafe_add(delta1, sqrt_val), uint256) / 2), int256)\r\n    else:\r\n        # second_cbrt = -convert(self._cbrt(convert(unsafe_sub(sqrt_val, delta1), uint256) / 2), int256)\r\n        second_cbrt = -convert(self._cbrt(unsafe_div(convert(unsafe_sub(sqrt_val, delta1), uint256), 2)), int256)\r\n\r\n    # C1: int256 = b_cbrt**2/10**18*second_cbrt/10**18\r\n    C1: int256 = unsafe_div(unsafe_mul(unsafe_div(b_cbrt**2, 10**18), second_cbrt), 10**18)\r\n\r\n    # root: int256 = (10**18*C1 - 10**18*b - 10**18*b*delta0/C1)/(3*a), keep 2 safe ops here.\r\n    root: int256 = (unsafe_mul(10**18, C1) - unsafe_mul(10**18, b) - unsafe_mul(10**18, b)/C1*delta0)/unsafe_mul(3, a)\r\n\r\n    # y_out: uint256[2] =  [\r\n    #     convert(D**2/x_j*root/4/10**18, uint256),   # <--- y\r\n    #     convert(root, uint256)  # <----------------------- K0Prev\r\n    # ]\r\n    y_out: uint256[2] = [convert(unsafe_div(unsafe_div(unsafe_mul(unsafe_div(D**2, x_j), root), 4), 10**18), uint256), convert(root, uint256)]\r\n\r\n    frac: uint256 = unsafe_div(y_out[0] * 10**18, _D)\r\n    assert (frac >= 10**16 - 1) and (frac < 10**20 + 1)  # dev: unsafe value for y\r\n\r\n    return y_out\r\n\r\n\r\n@external\r\n@view\r\ndef newton_D(ANN: uint256, gamma: uint256, x_unsorted: uint256[N_COINS], K0_prev: uint256 = 0) -> uint256:\r\n    \"\"\"\r\n    Finding the invariant using Newton method.\r\n    ANN is higher by the factor A_MULTIPLIER\r\n    ANN is already A * N**N\r\n    \"\"\"\r\n\r\n    # Safety checks\r\n    assert ANN > MIN_A - 1 and ANN < MAX_A + 1  # dev: unsafe values A\r\n    assert gamma > MIN_GAMMA - 1 and gamma < MAX_GAMMA + 1  # dev: unsafe values gamma\r\n\r\n    # Initial value of invariant D is that for constant-product invariant\r\n    x: uint256[N_COINS] = x_unsorted\r\n    if x[0] < x[1]:\r\n        x = [x_unsorted[1], x_unsorted[0]]\r\n\r\n    assert x[0] > 10**9 - 1 and x[0] < 10**15 * 10**18 + 1  # dev: unsafe values x[0]\r\n    assert unsafe_div(x[1] * 10**18, x[0]) > 10**14 - 1  # dev: unsafe values x[i] (input)\r\n\r\n    S: uint256 = unsafe_add(x[0], x[1])  # can unsafe add here because we checked x[0] bounds\r\n\r\n    D: uint256 = 0\r\n    if K0_prev == 0:\r\n        D = N_COINS * isqrt(unsafe_mul(x[0], x[1]))\r\n    else:\r\n        # D = isqrt(x[0] * x[1] * 4 / K0_prev * 10**18)\r\n        D = isqrt(unsafe_mul(unsafe_div(unsafe_mul(unsafe_mul(4, x[0]), x[1]), K0_prev), 10**18))\r\n        if S < D:\r\n            D = S\r\n\r\n    __g1k0: uint256 = gamma + 10**18\r\n    diff: uint256 = 0\r\n\r\n    for i in range(255):\r\n        D_prev: uint256 = D\r\n        assert D > 0\r\n        # Unsafe division by D and D_prev is now safe\r\n\r\n        # K0: uint256 = 10**18\r\n        # for _x in x:\r\n        #     K0 = K0 * _x * N_COINS / D\r\n        # collapsed for 2 coins\r\n        K0: uint256 = unsafe_div(unsafe_div((10**18 * N_COINS**2) * x[0], D) * x[1], D)\r\n\r\n        _g1k0: uint256 = __g1k0\r\n        if _g1k0 > K0:\r\n            _g1k0 = unsafe_add(unsafe_sub(_g1k0, K0), 1)  # > 0\r\n        else:\r\n            _g1k0 = unsafe_add(unsafe_sub(K0, _g1k0), 1)  # > 0\r\n\r\n        # D / (A * N**N) * _g1k0**2 / gamma**2\r\n        mul1: uint256 = unsafe_div(unsafe_div(unsafe_div(10**18 * D, gamma) * _g1k0, gamma) * _g1k0 * A_MULTIPLIER, ANN)\r\n\r\n        # 2*N*K0 / _g1k0\r\n        mul2: uint256 = unsafe_div(((2 * 10**18) * N_COINS) * K0, _g1k0)\r\n\r\n        # calculate neg_fprime. here K0 > 0 is being validated (safediv).\r\n        neg_fprime: uint256 = (S + unsafe_div(S * mul2, 10**18)) + mul1 * N_COINS / K0 - unsafe_div(mul2 * D, 10**18)\r\n\r\n        # D -= f / fprime; neg_fprime safediv being validated\r\n        D_plus: uint256 = D * (neg_fprime + S) / neg_fprime\r\n        D_minus: uint256 = unsafe_div(D * D,  neg_fprime)\r\n        if 10**18 > K0:\r\n            D_minus += unsafe_div(unsafe_div(D * unsafe_div(mul1, neg_fprime), 10**18) * unsafe_sub(10**18, K0), K0)\r\n        else:\r\n            D_minus -= unsafe_div(unsafe_div(D * unsafe_div(mul1, neg_fprime), 10**18) * unsafe_sub(K0, 10**18), K0)\r\n\r\n        if D_plus > D_minus:\r\n            D = unsafe_sub(D_plus, D_minus)\r\n        else:\r\n            D = unsafe_div(unsafe_sub(D_minus, D_plus), 2)\r\n\r\n        if D > D_prev:\r\n            diff = unsafe_sub(D, D_prev)\r\n        else:\r\n            diff = unsafe_sub(D_prev, D)\r\n\r\n        if diff * 10**14 < max(10**16, D):  # Could reduce precision for gas efficiency here\r\n\r\n            for _x in x:\r\n                frac: uint256 = _x * 10**18 / D\r\n                assert (frac >= 10**16 - 1) and (frac < 10**20 + 1)  # dev: unsafe values x[i]\r\n            return D\r\n\r\n    raise \"Did not converge\"\r\n\r\n\r\n@external\r\n@view\r\ndef get_p(\r\n    _xp: uint256[N_COINS], _D: uint256, _A_gamma: uint256[N_COINS]\r\n) -> uint256:\r\n    \"\"\"\r\n    @notice Calculates dx/dy.\r\n    @dev Output needs to be multiplied with price_scale to get the actual value.\r\n    @param _xp Balances of the pool.\r\n    @param _D Current value of D.\r\n    @param _A_gamma Amplification coefficient and gamma.\r\n    \"\"\"\r\n\r\n    assert _D > 10**17 - 1 and _D < 10**15 * 10**18 + 1  # dev: unsafe D values\r\n\r\n    # K0 = P * N**N / D**N.\r\n    # K0 is dimensionless and has 10**36 precision:\r\n    K0: uint256 = unsafe_div(\r\n        unsafe_div(4 * _xp[0] * _xp[1], _D) * 10**36,\r\n        _D\r\n    )\r\n\r\n    # GK0 is in 10**36 precision and is dimensionless.\r\n    # GK0 = (\r\n    #     2 * _K0 * _K0 / 10**36 * _K0 / 10**36\r\n    #     + (gamma + 10**18)**2\r\n    #     - (_K0 * _K0 / 10**36 * (2 * gamma + 3 * 10**18) / 10**18)\r\n    # )\r\n    # GK0 is always positive. So the following should never revert:\r\n    GK0: uint256 = (\r\n        unsafe_div(unsafe_div(2 * K0 * K0, 10**36) * K0, 10**36)\r\n        + pow_mod256(unsafe_add(_A_gamma[1], 10**18), 2)\r\n        - unsafe_div(\r\n            unsafe_div(pow_mod256(K0, 2), 10**36) * unsafe_add(unsafe_mul(2, _A_gamma[1]), 3 * 10**18),\r\n            10**18\r\n        )\r\n    )\r\n\r\n    # NNAG2 = N**N * A * gamma**2\r\n    NNAG2: uint256 = unsafe_div(unsafe_mul(_A_gamma[0], pow_mod256(_A_gamma[1], 2)), A_MULTIPLIER)\r\n\r\n    # denominator = (GK0 + NNAG2 * x / D * _K0 / 10**36)\r\n    denominator: uint256 = (GK0 + unsafe_div(unsafe_div(NNAG2 * _xp[0], _D) * K0, 10**36) )\r\n\r\n    # p_xy = x * (GK0 + NNAG2 * y / D * K0 / 10**36) / y * 10**18 / denominator\r\n    # p is in 10**18 precision.\r\n    return unsafe_div(\r\n        _xp[0] * ( GK0 + unsafe_div(unsafe_div(NNAG2 * _xp[1], _D) * K0, 10**36) ) / _xp[1] * 10**18,\r\n        denominator\r\n    )\r\n\r\n\r\n@external\r\n@pure\r\ndef wad_exp(x: int256) -> int256:\r\n    \"\"\"\r\n    @dev Calculates the natural exponential function of a signed integer with\r\n         a precision of 1e18.\r\n    @notice Note that this function consumes about 810 gas units. The implementation\r\n            is inspired by Remco Bloemen's implementation under the MIT license here:\r\n            https://xn--2-umb.com/22/exp-ln.\r\n    @param x The 32-byte variable.\r\n    @return int256 The 32-byte calculation result.\r\n    \"\"\"\r\n    value: int256 = x\r\n\r\n    # If the result is `< 0.5`, we return zero. This happens when we have the following:\r\n    # \"x <= floor(log(0.5e18) * 1e18) ~ -42e18\".\r\n    if (x <= -42_139_678_854_452_767_551):\r\n        return empty(int256)\r\n\r\n    # When the result is \"> (2 ** 255 - 1) / 1e18\" we cannot represent it as a signed integer.\r\n    # This happens when \"x >= floor(log((2 ** 255 - 1) / 1e18) * 1e18) ~ 135\".\r\n    assert x < 135_305_999_368_893_231_589, \"Math: wad_exp overflow\"\r\n\r\n    # `x` is now in the range \"(-42, 136) * 1e18\". Convert to \"(-42, 136) * 2 ** 96\" for higher\r\n    # intermediate precision and a binary base. This base conversion is a multiplication with\r\n    # \"1e18 / 2 ** 96 = 5 ** 18 / 2 ** 78\".\r\n    value = unsafe_div(x << 78, 5 ** 18)\r\n\r\n    # Reduce the range of `x` to \"(-½ ln 2, ½ ln 2) * 2 ** 96\" by factoring out powers of two\r\n    # so that \"exp(x) = exp(x') * 2 ** k\", where `k` is a signer integer. Solving this gives\r\n    # \"k = round(x / log(2))\" and \"x' = x - k * log(2)\". Thus, `k` is in the range \"[-61, 195]\".\r\n    k: int256 = unsafe_add(unsafe_div(value << 96, 54_916_777_467_707_473_351_141_471_128), 2 ** 95) >> 96\r\n    value = unsafe_sub(value, unsafe_mul(k, 54_916_777_467_707_473_351_141_471_128))\r\n\r\n    # Evaluate using a \"(6, 7)\"-term rational approximation. Since `p` is monic,\r\n    # we will multiply by a scaling factor later.\r\n    y: int256 = unsafe_add(unsafe_mul(unsafe_add(value, 1_346_386_616_545_796_478_920_950_773_328), value) >> 96, 57_155_421_227_552_351_082_224_309_758_442)\r\n    p: int256 = unsafe_add(unsafe_mul(unsafe_add(unsafe_mul(unsafe_sub(unsafe_add(y, value), 94_201_549_194_550_492_254_356_042_504_812), y) >> 96,\\\r\n                           28_719_021_644_029_726_153_956_944_680_412_240), value), 4_385_272_521_454_847_904_659_076_985_693_276 << 96)\r\n\r\n    # We leave `p` in the \"2 ** 192\" base so that we do not have to scale it up\r\n    # again for the division.\r\n    q: int256 = unsafe_add(unsafe_mul(unsafe_sub(value, 2_855_989_394_907_223_263_936_484_059_900), value) >> 96, 50_020_603_652_535_783_019_961_831_881_945)\r\n    q = unsafe_sub(unsafe_mul(q, value) >> 96, 533_845_033_583_426_703_283_633_433_725_380)\r\n    q = unsafe_add(unsafe_mul(q, value) >> 96, 3_604_857_256_930_695_427_073_651_918_091_429)\r\n    q = unsafe_sub(unsafe_mul(q, value) >> 96, 14_423_608_567_350_463_180_887_372_962_807_573)\r\n    q = unsafe_add(unsafe_mul(q, value) >> 96, 26_449_188_498_355_588_339_934_803_723_976_023)\r\n\r\n    # The polynomial `q` has no zeros in the range because all its roots are complex.\r\n    # No scaling is required, as `p` is already \"2 ** 96\" too large. Also,\r\n    # `r` is in the range \"(0.09, 0.25) * 2**96\" after the division.\r\n    r: int256 = unsafe_div(p, q)\r\n\r\n    # To finalise the calculation, we have to multiply `r` by:\r\n    #   - the scale factor \"s = ~6.031367120\",\r\n    #   - the factor \"2 ** k\" from the range reduction, and\r\n    #   - the factor \"1e18 / 2 ** 96\" for the base conversion.\r\n    # We do this all at once, with an intermediate result in \"2**213\" base,\r\n    # so that the final right shift always gives a positive value.\r\n\r\n    # Note that to circumvent Vyper's safecast feature for the potentially\r\n    # negative parameter value `r`, we first convert `r` to `bytes32` and\r\n    # subsequently to `uint256`. Remember that the EVM default behaviour is\r\n    # to use two's complement representation to handle signed integers.\r\n    return convert(unsafe_mul(convert(convert(r, bytes32), uint256), 3_822_833_074_963_236_453_042_738_258_902_158_003_155_416_615_667) >>\\\r\n           convert(unsafe_sub(195, k), uint256), int256)","ABI":"[{\"stateMutability\":\"pure\",\"type\":\"function\",\"name\":\"newton_y\",\"inputs\":[{\"name\":\"ANN\",\"type\":\"uint256\"},{\"name\":\"gamma\",\"type\":\"uint256\"},{\"name\":\"x\",\"type\":\"uint256[2]\"},{\"name\":\"D\",\"type\":\"uint256\"},{\"name\":\"i\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"pure\",\"type\":\"function\",\"name\":\"get_y\",\"inputs\":[{\"name\":\"_ANN\",\"type\":\"uint256\"},{\"name\":\"_gamma\",\"type\":\"uint256\"},{\"name\":\"_x\",\"type\":\"uint256[2]\"},{\"name\":\"_D\",\"type\":\"uint256\"},{\"name\":\"i\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256[2]\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"newton_D\",\"inputs\":[{\"name\":\"ANN\",\"type\":\"uint256\"},{\"name\":\"gamma\",\"type\":\"uint256\"},{\"name\":\"x_unsorted\",\"type\":\"uint256[2]\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"newton_D\",\"inputs\":[{\"name\":\"ANN\",\"type\":\"uint256\"},{\"name\":\"gamma\",\"type\":\"uint256\"},{\"name\":\"x_unsorted\",\"type\":\"uint256[2]\"},{\"name\":\"K0_prev\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_p\",\"inputs\":[{\"name\":\"_xp\",\"type\":\"uint256[2]\"},{\"name\":\"_D\",\"type\":\"uint256\"},{\"name\":\"_A_gamma\",\"type\":\"uint256[2]\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"pure\",\"type\":\"function\",\"name\":\"wad_exp\",\"inputs\":[{\"name\":\"x\",\"type\":\"int256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"version\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"string\"}]}]","ContractName":"CurveTwocryptoMathOptimized","CompilerVersion":"vyper:0.3.10","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":""}]}