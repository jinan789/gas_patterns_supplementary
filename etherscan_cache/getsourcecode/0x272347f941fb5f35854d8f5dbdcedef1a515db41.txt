{"status":"1","message":"OK","result":[{"SourceCode":"# @version ^0.3.9\r\n\r\nMAX_REQUESTS: constant(uint256) = 32 # maximum number of requestIds to process at a time\r\nMAX_OUTPUT_PIPES: constant(uint256) = 32\r\nMAX_LIDO_DEPOSIT: constant(uint256) = 1000 * 10**18\r\nMIN_LIDO_DEPOSIT: constant(uint256) = 100\r\nMAX_PIPE_DATA: constant(uint256) = 32 * 16\r\n\r\ninterface StETH:\r\n  def balanceOf(_owner: address) -> uint256: view\r\n  def transferFrom(_from: address, _to: address, _value: uint256) -> bool: nonpayable\r\n  def approve(_spender: address, _value: uint256) -> bool: nonpayable\r\n\r\ninterface UnstETH:\r\n  def requestWithdrawals(_amounts: DynArray[uint256, MAX_REQUESTS], _owner: address) -> DynArray[uint256, MAX_REQUESTS]: nonpayable\r\n  def getClaimableEther(_requestIds: DynArray[uint256, MAX_REQUESTS], _hints: DynArray[uint256, MAX_REQUESTS]) -> DynArray[uint256, MAX_REQUESTS]: view\r\n  def claimWithdrawals(_requestIds: DynArray[uint256, MAX_REQUESTS], _hints: DynArray[uint256, MAX_REQUESTS]): nonpayable\r\n\r\ninterface Lidont:\r\n  def mint(amount: uint256, recipient: address): nonpayable\r\n\r\ninterface OutputPipe:\r\n  def receive(_who: address, _data: Bytes[MAX_PIPE_DATA]): payable\r\n  def receiveReward(_token: address, _from: address, _amount: uint256): nonpayable\r\n\r\nstakedEther: immutable(StETH)\r\nunstETH: immutable(UnstETH)\r\nlidont: public(Lidont)\r\n\r\n# Claims tracking\r\n\r\n# Stages:\r\n# 1. No deposit           - outputPipe empty\r\n#    deposit →\r\n# 2. stETH deposited      - outputPipe set, stETH non-zero\r\n#    initiateWithdrawal →\r\n# 3. Withdrawal requested - outputPipe set, stETH zero, ETH zero\r\n#    finaliseWithdrawal →\r\n# 4. Withdrawal finalised - outputPipe set, stETH zero, ETH non-zero\r\n#    claim →\r\nstruct DepositData:\r\n  stETH: uint256\r\n  requestId: uint256\r\n  ETH: uint256\r\n  outputPipe: address\r\n\r\ndeposits: public(HashMap[address, DepositData])\r\n\r\nqueue: public(address[MAX_REQUESTS])\r\nqueueSize: public(uint256)\r\nqueueFront: public(uint256)\r\nqueueBack: public(uint256)\r\n@internal\r\ndef _appendQueue(a: address):\r\n  self.queue[self.queueBack] = a\r\n  self.queueBack += 1\r\n  if self.queueBack == MAX_REQUESTS: self.queueBack = 0\r\n  self.queueSize += 1\r\n  assert self.queueSize < MAX_REQUESTS, \"too many depositors\"\r\n@internal\r\ndef _popQueue() -> address:\r\n  front: address = self.queue[self.queueFront]\r\n  self.queueFront += 1\r\n  if self.queueFront == MAX_REQUESTS: self.queueFront = 0\r\n  self.queueSize -= 1\r\n  return front\r\n\r\n# Output pipes\r\n\r\nadmin: public(address)\r\nnewMinter: public(address)\r\noutputIndex: public(HashMap[address, uint256]) # 0 is invalid, otherwise 1+index in outputPipes\r\noutputPipes: public(DynArray[address, MAX_OUTPUT_PIPES])\r\n\r\nemissionPerBlock: public(uint256)\r\nlastRewardBlock: public(HashMap[address, uint256])\r\n\r\nevent ChangeAdmin:\r\n  oldAdmin: indexed(address)\r\n  newAdmin: indexed(address)\r\n\r\nevent SetOutputValidity:\r\n  output: indexed(address)\r\n  valid: indexed(bool)\r\n\r\nevent ChangeEmission:\r\n  oldEmissionPerBlock: indexed(uint256)\r\n  newEmissionPerBlock: indexed(uint256)\r\n\r\n@external\r\ndef __init__(stETHAddress: address, unstETHAddress: address):\r\n  stakedEther = StETH(stETHAddress)\r\n  unstETH = UnstETH(unstETHAddress)\r\n  self.admin = msg.sender\r\n\r\n@external\r\ndef changeAdmin(newAdmin: address):\r\n  assert msg.sender == self.admin, \"auth\"\r\n  self.admin = newAdmin\r\n  log ChangeAdmin(msg.sender, newAdmin)\r\n\r\n@external\r\ndef setLidont(lidontAddress: address):\r\n  assert msg.sender == self.admin, \"auth\"\r\n  self.lidont = Lidont(lidontAddress)\r\n\r\n@external\r\ndef setUpgrade(upgradeAddress: address):\r\n  assert msg.sender == self.admin, \"auth\"\r\n  self.newMinter = upgradeAddress\r\n\r\nevent SetLastRewardBlock:\r\n  pipe: indexed(address)\r\n  bnum: indexed(uint256)\r\n\r\n@internal\r\ndef _updatePendingRewardsFor(output: address):\r\n  # assert 0 < self.outputIndex[output], \"assume the caller checks this\"\r\n  unclaimedBlocks: uint256 = block.number - self.lastRewardBlock[output]\r\n  self.lastRewardBlock[output] = block.number\r\n  log SetLastRewardBlock(output, block.number)\r\n  reward: uint256 = unclaimedBlocks * self.emissionPerBlock\r\n  if 0 < reward:\r\n    self.lidont.mint(reward, output)\r\n    OutputPipe(output).receiveReward(self.lidont.address, empty(address), reward)\r\n\r\n@internal\r\ndef _updatePendingRewards():\r\n  for output in self.outputPipes:\r\n    self._updatePendingRewardsFor(output)\r\n\r\n@external\r\ndef triggerEmission(output: address):\r\n  assert 0 < self.outputIndex[output], \"invalid output pipe\"\r\n  self._updatePendingRewardsFor(output)\r\n\r\n@external\r\ndef toggleValidOutput(output: address):\r\n  assert msg.sender == self.admin, \"auth\"\r\n  newValidity: bool = self.outputIndex[output] == 0\r\n  if not newValidity:\r\n    self._updatePendingRewardsFor(output)\r\n  for i in range(MAX_OUTPUT_PIPES):\r\n    if i == len(self.outputPipes): break\r\n    if newValidity and self.outputPipes[i] == empty(address):\r\n      self.outputPipes[i] = output\r\n      self.outputIndex[output] = unsafe_add(i, 1)\r\n      break\r\n    elif not newValidity and self.outputPipes[i] == output:\r\n      self.outputPipes[i] = empty(address)\r\n      self.outputIndex[output] = 0\r\n      break\r\n  if newValidity:\r\n    if self.outputIndex[output] == 0:\r\n      self.outputPipes.append(output)\r\n      self.outputIndex[output] = len(self.outputPipes)\r\n    self.lastRewardBlock[output] = block.number\r\n    log SetLastRewardBlock(output, block.number)\r\n  log SetOutputValidity(output, newValidity)\r\n\r\n@external\r\ndef changeEmissionRate(newEmissionPerBlock: uint256):\r\n  assert msg.sender == self.admin, \"auth\"\r\n  self._updatePendingRewards()\r\n  self.emissionPerBlock = newEmissionPerBlock\r\n  log ChangeEmission(self.emissionPerBlock, newEmissionPerBlock)\r\n\r\n# Main mechanisms:\r\n# - deposit stETH for (pending) ETH\r\n# - process withdrawals with Lido\r\n# - claim withdrawn ETH to output pipe\r\n\r\nevent Deposit:\r\n  who: indexed(address)\r\n  amount: indexed(uint256)\r\n\r\nevent WithdrawalRequest:\r\n  requestIds: DynArray[uint256, MAX_REQUESTS]\r\n  depositors: DynArray[address, MAX_REQUESTS]\r\n  amounts: DynArray[uint256, MAX_REQUESTS]\r\n\r\nevent Claim:\r\n  who: indexed(address)\r\n  output: indexed(address)\r\n  amount: indexed(uint256)\r\n\r\n@external\r\ndef deposit(stETHAmount: uint256, outputPipe: address):\r\n  assert 0 < self.outputIndex[outputPipe], \"invalid pipe\"\r\n  assert MIN_LIDO_DEPOSIT <= stETHAmount, \"deposit too small\"\r\n  assert stETHAmount <= MAX_LIDO_DEPOSIT, \"deposit too large\"\r\n  assert stETHAmount <= stakedEther.balanceOf(msg.sender), \"balance\"\r\n  assert stakedEther.transferFrom(msg.sender, self, stETHAmount), \"stETH transfer failed\"\r\n  assert self.deposits[msg.sender].outputPipe == empty(address) and self.deposits[msg.sender].stETH == 0, \"pending deposit\"\r\n  self.deposits[msg.sender].outputPipe = outputPipe\r\n  self.deposits[msg.sender].stETH = stETHAmount\r\n  self._appendQueue(msg.sender)\r\n  log Deposit(msg.sender, stETHAmount)\r\n\r\n@external\r\ndef changeOutput(outputPipe: address):\r\n  assert self.deposits[msg.sender].outputPipe != empty(address), \"no deposit\"\r\n  assert 0 < self.outputIndex[outputPipe], \"invalid pipe\"\r\n  self.deposits[msg.sender].outputPipe = outputPipe\r\n\r\n@external\r\ndef initiateWithdrawal(depositors: DynArray[address, MAX_REQUESTS]) -> DynArray[uint256, MAX_REQUESTS]:\r\n  requestAmounts: DynArray[uint256, MAX_REQUESTS] = []\r\n  totalRequestAmount: uint256 = 0\r\n  for depositor in depositors:\r\n    assert self.deposits[depositor].ETH == 0, \"claim pending\"\r\n    amount: uint256 = self.deposits[depositor].stETH\r\n    assert amount > 0, \"no deposit\"\r\n    requestAmounts.append(amount)\r\n    totalRequestAmount += amount\r\n  assert stakedEther.approve(unstETH.address, totalRequestAmount), \"stETH approve failed\"\r\n  requestIds: DynArray[uint256, MAX_REQUESTS] = unstETH.requestWithdrawals(requestAmounts, self)\r\n  for i in range(MAX_REQUESTS):\r\n    if i == len(requestIds): break\r\n    depositor: address = depositors[i]\r\n    self.deposits[depositor].stETH = 0\r\n    self.deposits[depositor].requestId = requestIds[i]\r\n  log WithdrawalRequest(requestIds, depositors, requestAmounts)\r\n  return requestIds\r\n\r\n@external\r\ndef finaliseWithdrawal(depositors: DynArray[address, MAX_REQUESTS],\r\n                       _hints: DynArray[uint256, MAX_REQUESTS]) -> DynArray[uint256, MAX_REQUESTS]:\r\n  requestIds: DynArray[uint256, MAX_REQUESTS] = []\r\n  for depositor in depositors:\r\n    requestIds.append(self.deposits[depositor].requestId)\r\n  claimAmounts: DynArray[uint256, MAX_REQUESTS] = unstETH.getClaimableEther(requestIds, _hints)\r\n  unstETH.claimWithdrawals(requestIds, _hints)\r\n  for i in range(MAX_REQUESTS):\r\n    if i == len(claimAmounts): break\r\n    self.deposits[depositors[i]].ETH = claimAmounts[i]\r\n  return claimAmounts\r\n\r\n@external\r\n@payable\r\ndef __default__():\r\n  assert msg.sender == unstETH.address, \"only withdrawals accepted\"\r\n\r\n@external\r\ndef claim(data: Bytes[MAX_PIPE_DATA]) -> uint256:\r\n  recipient: address = self._popQueue()\r\n  output: address = self.deposits[recipient].outputPipe\r\n  assert output != empty(address), \"not deposited\" # TODO: impossible?\r\n  amount: uint256 = self.deposits[recipient].ETH\r\n  assert 0 < amount, \"not finalised\"\r\n  OutputPipe(output).receive(recipient, data, value=amount)\r\n  self.deposits[recipient].ETH = 0\r\n  self.deposits[recipient].outputPipe = empty(address)\r\n  log Claim(recipient, output, amount)\r\n  return amount","ABI":"[{\"name\":\"ChangeAdmin\",\"inputs\":[{\"name\":\"oldAdmin\",\"type\":\"address\",\"indexed\":true},{\"name\":\"newAdmin\",\"type\":\"address\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetOutputValidity\",\"inputs\":[{\"name\":\"output\",\"type\":\"address\",\"indexed\":true},{\"name\":\"valid\",\"type\":\"bool\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"ChangeEmission\",\"inputs\":[{\"name\":\"oldEmissionPerBlock\",\"type\":\"uint256\",\"indexed\":true},{\"name\":\"newEmissionPerBlock\",\"type\":\"uint256\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetLastRewardBlock\",\"inputs\":[{\"name\":\"pipe\",\"type\":\"address\",\"indexed\":true},{\"name\":\"bnum\",\"type\":\"uint256\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Deposit\",\"inputs\":[{\"name\":\"who\",\"type\":\"address\",\"indexed\":true},{\"name\":\"amount\",\"type\":\"uint256\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"WithdrawalRequest\",\"inputs\":[{\"name\":\"requestIds\",\"type\":\"uint256[]\",\"indexed\":false},{\"name\":\"depositors\",\"type\":\"address[]\",\"indexed\":false},{\"name\":\"amounts\",\"type\":\"uint256[]\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Claim\",\"inputs\":[{\"name\":\"who\",\"type\":\"address\",\"indexed\":true},{\"name\":\"output\",\"type\":\"address\",\"indexed\":true},{\"name\":\"amount\",\"type\":\"uint256\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"stETHAddress\",\"type\":\"address\"},{\"name\":\"unstETHAddress\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"changeAdmin\",\"inputs\":[{\"name\":\"newAdmin\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"setLidont\",\"inputs\":[{\"name\":\"lidontAddress\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"setUpgrade\",\"inputs\":[{\"name\":\"upgradeAddress\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"triggerEmission\",\"inputs\":[{\"name\":\"output\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"toggleValidOutput\",\"inputs\":[{\"name\":\"output\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"changeEmissionRate\",\"inputs\":[{\"name\":\"newEmissionPerBlock\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"deposit\",\"inputs\":[{\"name\":\"stETHAmount\",\"type\":\"uint256\"},{\"name\":\"outputPipe\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"changeOutput\",\"inputs\":[{\"name\":\"outputPipe\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"initiateWithdrawal\",\"inputs\":[{\"name\":\"depositors\",\"type\":\"address[]\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"finaliseWithdrawal\",\"inputs\":[{\"name\":\"depositors\",\"type\":\"address[]\"},{\"name\":\"_hints\",\"type\":\"uint256[]\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}]},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"claim\",\"inputs\":[{\"name\":\"data\",\"type\":\"bytes\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"lidont\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"deposits\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"tuple\",\"components\":[{\"name\":\"stETH\",\"type\":\"uint256\"},{\"name\":\"requestId\",\"type\":\"uint256\"},{\"name\":\"ETH\",\"type\":\"uint256\"},{\"name\":\"outputPipe\",\"type\":\"address\"}]}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"queue\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"queueSize\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"queueFront\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"queueBack\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"admin\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"newMinter\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"outputIndex\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"outputPipes\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"emissionPerBlock\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"lastRewardBlock\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]}]","ContractName":"Vyper_contract","CompilerVersion":"vyper:0.3.10","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"000000000000000000000000ae7ab96520de3a18e5e111b5eaab095312d7fe84000000000000000000000000889edc2edab5f40e902b864ad4d7ade8e412f9b1","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":""}]}