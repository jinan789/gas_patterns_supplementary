{"status":"1","message":"OK","result":[{"SourceCode":"# @version 0.3.10\r\n\"\"\"\r\n@title Minter\r\n@author Yearn Finance\r\n@license GNU AGPLv3\r\n@notice\r\n    Mints reward tokens for the gauge controller according to a predefined formula.\r\n    Annualized emission is `c * sqrt(ve_supply)` and is recalculated every epoch.\r\n\"\"\"\r\n\r\ninterface Token:\r\n    def mint(_account: address, _amount: uint256): nonpayable\r\n    def transferOwnership(_owner: address): nonpayable\r\n\r\ninterface VotingEscrow:\r\n    def totalSupply(_ts: uint256) -> uint256: view\r\n\r\ninterface Minter:\r\n    def mint(_epoch: uint256) -> uint256: nonpayable\r\n\r\nimplements: Minter\r\n\r\ngenesis: public(immutable(uint256))\r\ntoken: public(immutable(Token))\r\nvoting_escrow: public(immutable(VotingEscrow))\r\nmanagement: public(address)\r\npending_management: public(address)\r\ncontroller: public(address)\r\nscaling_factor: public(uint256)\r\nlast_epoch: public(uint256)\r\n\r\nevent Mint:\r\n    epoch: indexed(uint256)\r\n    amount: uint256\r\n\r\nevent SetController:\r\n    controller: indexed(address)\r\n\r\nevent SetScalingFactor:\r\n    scaling_factor: uint256\r\n\r\nevent TransferTokenOwnership:\r\n    owner: indexed(address)\r\n\r\nevent PendingManagement:\r\n    management: indexed(address)\r\n\r\nevent SetManagement:\r\n    management: indexed(address)\r\n\r\nUNIT: constant(uint256) = 10**18\r\nSCALE: constant(uint256) = 10_000\r\nWEEK_LENGTH: constant(uint256) = 7 * 24 * 60 * 60\r\nEPOCH_LENGTH: constant(uint256) = 2 * WEEK_LENGTH\r\n\r\n@external\r\ndef __init__(_genesis: uint256, _token: address, _voting_escrow: address, _last_epoch: uint256):\r\n    \"\"\"\r\n    @notice Constructor\r\n    @param _genesis Genesis timestamp\r\n    @param _token Address of token to be minted\r\n    @param _voting_escrow Voting escrow address\r\n    @param _last_epoch Last completed epoch prior to activation\r\n    \"\"\"\r\n    genesis = _genesis\r\n    token = Token(_token)\r\n    voting_escrow = VotingEscrow(_voting_escrow)\r\n    self.management = msg.sender\r\n    self.last_epoch = _last_epoch\r\n    self.scaling_factor = 12 * SCALE\r\n\r\n@external\r\n@view\r\ndef epoch() -> uint256:\r\n    \"\"\"\r\n    @notice Get the current epoch\r\n    @return Current epoch\r\n    \"\"\"\r\n    return self._epoch()\r\n\r\n@internal\r\n@view\r\ndef _epoch() -> uint256:\r\n    return (block.timestamp - genesis) / EPOCH_LENGTH\r\n\r\n@external\r\n@view\r\ndef preview(_epoch: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Estimate tokens minted in a future epoch\r\n    @param _epoch Epoch number\r\n    @return Estimated tokens minted\r\n    \"\"\"\r\n    assert _epoch > self.last_epoch\r\n    return self._mintable(_epoch)\r\n\r\n@external\r\ndef mint(_epoch: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Mint tokens for a specific epoch\r\n    @param _epoch Epoch number\r\n    @return Amount of tokens minted\r\n    @dev Only callable by gauge controller\r\n    @dev Should only be called for a finished epoch\r\n    @dev Should only be called in sequence\r\n    \"\"\"\r\n    controller: address = self.controller\r\n    assert msg.sender == controller\r\n    assert _epoch == self.last_epoch + 1\r\n    assert _epoch < self._epoch()\r\n\r\n    self.last_epoch = _epoch\r\n    minted: uint256 = self._mintable(_epoch)\r\n    token.mint(controller, minted)\r\n    log Mint(_epoch, minted)\r\n    return minted\r\n\r\n@internal\r\n@view\r\ndef _mintable(_epoch: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice \r\n        Rewards for an epoch. Annual emission of `c * sqrt(ve_supply)`, \r\n        where `ve_supply` is evaluated at the end of the epoch\r\n    \"\"\"\r\n    supply: uint256 = voting_escrow.totalSupply(genesis + (_epoch + 1) * EPOCH_LENGTH)\r\n    return self.scaling_factor * self._sqrt(supply) * 14 / 365 / SCALE\r\n\r\n@external\r\ndef set_controller(_controller: address):\r\n    \"\"\"\r\n    @notice Set the new gauge controller\r\n    @param _controller New gauge controller\r\n    @dev Only callable by management\r\n    \"\"\"\r\n    assert msg.sender == self.management\r\n    assert _controller != empty(address)\r\n    self.controller = _controller\r\n    log SetController(_controller)\r\n\r\n@external\r\ndef set_scaling_factor(_scaling_factor: uint256):\r\n    \"\"\"\r\n    @notice Set the new scaling factor\r\n    @param _scaling_factor New scaling factor\r\n    @dev Should be between 4 and 64, inclusive\r\n    @dev Only callable by management\r\n    \"\"\"\r\n    assert msg.sender == self.management\r\n    assert _scaling_factor >= 4 * SCALE and _scaling_factor <= 64 * SCALE\r\n    assert self._epoch() == self.last_epoch + 1\r\n    self.scaling_factor = _scaling_factor\r\n    log SetScalingFactor(_scaling_factor)\r\n\r\n@external\r\ndef transfer_token_ownership(_new: address):\r\n    \"\"\"\r\n    @notice Transfer ownership of token\r\n    @param _new New token owner\r\n    @dev Once this has been called, this contract will no longer be\r\n        able to mint additional tokens\r\n    @dev Only callable by management\r\n    \"\"\"\r\n    assert msg.sender == self.management\r\n    assert _new != empty(address)\r\n    token.transferOwnership(_new)\r\n    log TransferTokenOwnership(_new)\r\n\r\n@external\r\ndef set_management(_management: address):\r\n    \"\"\"\r\n    @notice \r\n        Set the pending management address.\r\n        Needs to be accepted by that account separately to transfer management over\r\n    @param _management New pending management address\r\n    \"\"\"\r\n    assert msg.sender == self.management\r\n    self.pending_management = _management\r\n    log PendingManagement(_management)\r\n\r\n@external\r\ndef accept_management():\r\n    \"\"\"\r\n    @notice \r\n        Accept management role.\r\n        Can only be called by account previously marked as pending management by current management\r\n    \"\"\"\r\n    assert msg.sender == self.pending_management\r\n    self.pending_management = empty(address)\r\n    self.management = msg.sender\r\n    log SetManagement(msg.sender)\r\n\r\n@internal\r\n@pure\r\ndef _sqrt(_x: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice \r\n        Calculate square root of a 18 decimal number, rounding down.\r\n        Uses the Babylonian method: iteratively calculate `(r_i + x / r_i) / 2`, \r\n        which converges quadratically to `r = sqrt(x)`.\r\n        Based on implementation in https://github.com/PaulRBerg/prb-math\r\n    \"\"\"\r\n    if _x == 0:\r\n        return 0\r\n\r\n    # sqrt(x * 10**18 * 10**18) = sqrt(x) * 10**18\r\n    x: uint256 = unsafe_mul(_x, UNIT)\r\n\r\n    # find first bit\r\n    r: uint256 = 1\r\n    if x >= 1 << 128:\r\n        x = x >> 128\r\n        r = r << 64\r\n    if x >= 1 << 64:\r\n        x = x >> 64\r\n        r = r << 32\r\n    if x >= 1 << 32:\r\n        x = x >> 32\r\n        r = r << 16\r\n    if x >= 1 << 16:\r\n        x = x >> 16\r\n        r = r << 8\r\n    if x >= 1 << 8:\r\n        x = x >> 8\r\n        r = r << 4\r\n    if x >= 1 << 4:\r\n        x = x >> 4\r\n        r = r << 2\r\n    if x >= 1 << 2:\r\n        r = r << 1\r\n    \r\n    # iterate 7 times to get 2**7 = 128 bit accuracy\r\n    x = unsafe_mul(_x, UNIT)\r\n    r = unsafe_add(r, unsafe_div(x, r)) >> 1\r\n    r = unsafe_add(r, unsafe_div(x, r)) >> 1\r\n    r = unsafe_add(r, unsafe_div(x, r)) >> 1\r\n    r = unsafe_add(r, unsafe_div(x, r)) >> 1\r\n    r = unsafe_add(r, unsafe_div(x, r)) >> 1\r\n    r = unsafe_add(r, unsafe_div(x, r)) >> 1\r\n    r = unsafe_add(r, unsafe_div(x, r)) >> 1\r\n\r\n    d: uint256 = x / r\r\n    if r >= d:\r\n        return d\r\n    return r","ABI":"[{\"name\":\"Mint\",\"inputs\":[{\"name\":\"epoch\",\"type\":\"uint256\",\"indexed\":true},{\"name\":\"amount\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetController\",\"inputs\":[{\"name\":\"controller\",\"type\":\"address\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetScalingFactor\",\"inputs\":[{\"name\":\"scaling_factor\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"TransferTokenOwnership\",\"inputs\":[{\"name\":\"owner\",\"type\":\"address\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"PendingManagement\",\"inputs\":[{\"name\":\"management\",\"type\":\"address\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetManagement\",\"inputs\":[{\"name\":\"management\",\"type\":\"address\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"_genesis\",\"type\":\"uint256\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_voting_escrow\",\"type\":\"address\"},{\"name\":\"_last_epoch\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"epoch\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"preview\",\"inputs\":[{\"name\":\"_epoch\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"mint\",\"inputs\":[{\"name\":\"_epoch\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_controller\",\"inputs\":[{\"name\":\"_controller\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_scaling_factor\",\"inputs\":[{\"name\":\"_scaling_factor\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"transfer_token_ownership\",\"inputs\":[{\"name\":\"_new\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_management\",\"inputs\":[{\"name\":\"_management\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"accept_management\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"genesis\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"token\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"voting_escrow\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"management\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"pending_management\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"controller\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"scaling_factor\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"last_epoch\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]}]","ContractName":"Minter","CompilerVersion":"vyper:0.3.10","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000650b878000000000000000000000000041252e8691e964f7de35156b68493bab6797a27500000000000000000000000090c1f9220d90d3966fbee24045edd73e1d588ad5000000000000000000000000000000000000000000000000000000000000000c","EVMVersion":"Default","Library":"","LicenseType":"GNU AGPLv3","Proxy":"0","Implementation":"","SwarmSource":""}]}