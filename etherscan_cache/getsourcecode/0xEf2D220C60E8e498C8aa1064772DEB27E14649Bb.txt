{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The default value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = allowance(owner, spender);\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `from` to `to`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\\n            // decrementing then incrementing.\\n            _balances[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        unchecked {\\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\\n            _balances[account] += amount;\\n        }\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\\n            _totalSupply -= amount;\\n        }\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\\n     *\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Might emit an {Approval} event.\\n     */\\n    function _spendAllowance(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20Burnable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../ERC20.sol\\\";\\nimport \\\"../../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\\n * tokens and those that they have an allowance for, in a way that can be\\n * recognized off-chain (via event analysis).\\n */\\nabstract contract ERC20Burnable is Context, ERC20 {\\n    /**\\n     * @dev Destroys `amount` tokens from the caller.\\n     *\\n     * See {ERC20-_burn}.\\n     */\\n    function burn(uint256 amount) public virtual {\\n        _burn(_msgSender(), amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\\n     * allowance.\\n     *\\n     * See {ERC20-_burn} and {ERC20-allowance}.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have allowance for ``accounts``'s tokens of at least\\n     * `amount`.\\n     */\\n    function burnFrom(address account, uint256 amount) public virtual {\\n        _spendAllowance(account, _msgSender(), amount);\\n        _burn(account, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Factory {\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\n\\n    function feeTo() external view returns (address);\\n    function feeToSetter() external view returns (address);\\n\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\n    function allPairs(uint) external view returns (address pair);\\n    function allPairsLength() external view returns (uint);\\n\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n\\n    function setFeeTo(address) external;\\n    function setFeeToSetter(address) external;\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\n\\ninterface IUniswapV2Router01 {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETH(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountETH);\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountToken, uint amountETH);\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\n\\nimport './IUniswapV2Router01.sol';\\n\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountETH);\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountETH);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/lmeow/ILmeow.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.0;\\n\\nimport {IERC20, IERC20Metadata} from \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\n\\ninterface ILmeow is IERC20, IERC20Metadata {}\\n\"\r\n    },\r\n    \"contracts/lmeow/Lmeow.sol.nolog.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {ERC20Burnable} from \\\"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\\\";\\nimport {ERC20} from \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\\\";\\nimport \\\"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\\\";\\nimport \\\"./ILmeow.sol\\\";\\nimport \\\"./Ownable.sol\\\";\\n\\n\\n\\ncontract Vault is Ownable {\\n    IUniswapV2Router02 public immutable router;\\n\\n    constructor(IUniswapV2Router02 _router) {\\n        router = _router;\\n    }\\n\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint ethValue\\n    )\\n        external\\n        onlyOwner\\n        returns (\\n            uint amountToken,\\n            uint amountETH,\\n            uint liquidity\\n        )\\n    {\\n\\n\\n\\n        (amountToken, amountETH, liquidity) = router.addLiquidityETH{value: ethValue}(\\n            token,\\n            amountTokenDesired,\\n            amountTokenMin,\\n            amountETHMin,\\n            to,\\n            block.timestamp\\n        );\\n\\n    }\\n\\n    function recover(uint256 amount) external onlyOwner {\\n        msg.sender.call{value: amount}(new bytes(0));\\n    }\\n\\n    fallback() external payable onlyOwner {\\n\\n\\n\\n        (bool success, ) = address(router).call{value: msg.value}(msg.data);\\n        require(success, \\\"forward router faild\\\");\\n\\n\\n    }\\n\\n    receive() external payable {}\\n}\\n\\ncontract Lmeow is ILmeow, Ownable {\\n    string public constant override name = \\\"Lmeow Token\\\";\\n    string public constant override symbol = \\\"lmeow\\\";\\n    uint8 public constant override decimals = 18;\\n    uint256 public override totalSupply;\\n\\n    uint256 public constant initialSupply = 420690000000000 ether;\\n    uint256 public constant initialLPSupply = (initialSupply * 75) / 100; // 75%\\n    uint256 public constant marketingSupply = (initialSupply * 10) / 100; // 10%\\n    uint256 public constant teamSupply = (initialSupply * 10) / 100; // 10%\\n    uint256 public constant devSupply = initialSupply - initialLPSupply - marketingSupply - teamSupply; // 5%\\n\\n    address public constant marketingAddr = 0x5D98206E4a3E3b87E6d899A47f33DEB579105b96;\\n    address public constant teamAddr = 0x50E943A5e3c4078211a7e0226fc1e0f648B867af;\\n    address public constant devAddr = 0xbA6489eFB076194EB5551a0799d70648E0149952;\\n\\n    uint256 public constant ticketPrice = 3000000000000 ether;\\n    uint256 public constant WIN_COUNT = 3;\\n    uint256 public constant CYCLE_DURATION = 1 weeks;\\n    // limit 100 = 1%, 1=0.01% ,10=0.1% , 1000=10%, 10000=100%\\n    uint256 public limitFractional = 100;\\n    uint256 public buyTaxFractional = 1000;\\n    uint256 public sellTaxFractional = 1000;\\n    uint256 public autoLpFractional = 7500;\\n    uint256 public constant TEN_THOUSAND = 10000;\\n    address public pair;\\n    IUniswapV2Router02 public router;\\n    Vault public vault;\\n    Vault public lpVault;\\n    address public weth;\\n    address public recoverAddress;\\n\\n    uint256 public immutable deployTime;\\n    uint256 public lastAddLiquidityTime;\\n    uint256 private _seed = 2023;\\n    bool _inSwap;\\n    bool public autoAddLiquidity = true;\\n    bool public autoSwapBack = true;\\n    bool public initialLPSupplyAdded;\\n    mapping(address => bool) public lockedMap;\\n    mapping(address => uint256) public override balanceOf;\\n    mapping(address => bool) public withoutLimitMap;\\n    mapping(address => mapping(address => uint256)) public override allowance; // allowance[owner][spender]\\n\\n    mapping(uint256 => mapping(uint256 => Ticket)) public ticketMap;\\n    mapping(uint256 => uint256) public ticketCountMap;\\n    mapping(uint256 => RewardCycle) public rewardCycleMap;\\n    mapping(uint256 => mapping(address => uint256[])) public ticketUserMap;\\n    mapping(uint256 => uint256) public cycleRewardAmountMap;\\n\\n    event Lock(address user, uint256 timestamp);\\n    event OpenCycle(address user, uint256 cycleId);\\n    event Stake(uint256 indexed cycleId, address indexed user, uint256 count);\\n    event UnStake(uint256 indexed cycleId, address indexed user, uint256 count);\\n    event Reward(uint256 indexed cycleId, address indexed user, uint256 amount);\\n\\n    error MaxHolderLimitExceeded(address user);\\n    error LengthMismatch();\\n    error AlreadySetUp();\\n    error AccountLocked(address user);\\n    error InsufficientAllowance(address owner, address spender, uint256 amount);\\n    error ExceedsBalance(address owner);\\n    error InvalidAddress(address addr);\\n    error InvalidTime();\\n    error IllegalOperation();\\n    error InvalidArgs();\\n    error OnlyHumanCall();\\n    error ZeroBalance();\\n    error TransferETHFailed(address user, uint256 amount);\\n\\n    struct Ticket {\\n        address user;\\n        bool redeemed;\\n    }\\n\\n    struct TicketDetail {\\n        uint256 ticketCycleId;\\n        uint256 ticketId;\\n        address user;\\n        bool redeemed;\\n    }\\n\\n    struct TicketWinner {\\n        uint256 ticketId;\\n        uint256 amount;\\n        bool claimed;\\n    }\\n\\n    struct RewardCycle {\\n        TicketWinner[] winner;\\n        uint256 totalRewardEth;\\n        bool opened;\\n    }\\n\\n    modifier swapping() {\\n        _inSwap = true;\\n        _;\\n        _inSwap = false;\\n    }\\n\\n    modifier validRecipient(address to) {\\n        if (to == address(0)) revert ZeroAddress();\\n        _;\\n    }\\n\\n    modifier onlyEmergency() {\\n        if (msg.sender != recoverAddress) revert InvalidAddress(msg.sender);\\n        if (block.timestamp < (deployTime + 300 days)) revert IllegalOperation();\\n        _;\\n    }\\n\\n    modifier holdThreshold(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) {\\n        if (!withoutLimitMap[recipient]) {\\n            if (balanceOf[recipient] + amount > (initialSupply / TEN_THOUSAND) * limitFractional) {\\n                revert MaxHolderLimitExceeded(recipient);\\n            }\\n        }\\n        _;\\n    }\\n\\n    modifier onlyHuman() {\\n        if (tx.origin != msg.sender) revert OnlyHumanCall();\\n        _;\\n    }\\n\\n    modifier previousCycle(uint256 cycleId) {\\n        if (cycleId >= currentCycleId()) revert InvalidTime();\\n        _;\\n    }\\n\\n    constructor(IUniswapV2Router02 router_) {\\n        deployTime = block.timestamp;\\n        router = router_;\\n        IUniswapV2Factory factory = IUniswapV2Factory(router.factory());\\n        address weth_ = router.WETH();\\n        weth = weth_;\\n        pair = factory.createPair(weth_, address(this));\\n        vault = new Vault(router);\\n        lpVault = new Vault(router);\\n        address sender = msg.sender;\\n        recoverAddress = sender;\\n        withoutLimitMap[pair] = true;\\n        withoutLimitMap[address(this)] = true;\\n        withoutLimitMap[address(vault)] = true;\\n        withoutLimitMap[address(lpVault)] = true;\\n        totalSupply = initialSupply;\\n\\n        allowance[address(this)][address(router_)] = type(uint256).max;\\n        allowance[address(vault)][address(router_)] = type(uint256).max;\\n        allowance[address(lpVault)][address(router_)] = type(uint256).max;\\n        allowance[sender][address(router_)] = type(uint256).max;\\n\\n        balanceOf[address(this)] = initialLPSupply;\\n        balanceOf[marketingAddr] = marketingSupply;\\n        balanceOf[teamAddr] = teamSupply;\\n        balanceOf[devAddr] = devSupply;\\n\\n        emit Transfer(address(0), marketingAddr, marketingSupply);\\n        emit Transfer(address(0), teamAddr, teamSupply);\\n        emit Transfer(address(0), devAddr, devSupply);\\n        emit Transfer(address(0), address(this), initialLPSupply);\\n    }\\n\\n    function addInitialLP() external payable onlyOwner swapping {\\n\\n\\n        if (initialLPSupplyAdded) revert IllegalOperation();\\n        if (msg.value != 1 ether) revert IllegalOperation();\\n        router.addLiquidityETH{value: 1 ether}(address(this), initialLPSupply, 0, 0, msg.sender, block.timestamp);\\n        initialLPSupplyAdded = true;\\n\\n    }\\n\\n    function setWithoutLimit(address user) external onlyOwner {\\n        withoutLimitMap[user] = true;\\n    }\\n\\n    function setWithLimit(address user) external onlyOwner {\\n        withoutLimitMap[user] = false;\\n    }\\n\\n    function setPair(address pair_) external onlyOwner {\\n        pair = pair_;\\n    }\\n\\n    function setTaxBuyAndSellFractional(uint256 buy, uint256 sell) external onlyOwner {\\n        if (buy > TEN_THOUSAND / 10) revert InvalidArgs();\\n        if (sell > TEN_THOUSAND / 10) revert InvalidArgs();\\n        buyTaxFractional = buy;\\n        sellTaxFractional = sell;\\n    }\\n\\n    function setAutoLpFractional(uint256 autoLpFractional_) external onlyOwner {\\n        if (autoLpFractional_ > TEN_THOUSAND) revert InvalidArgs();\\n        autoLpFractional = autoLpFractional_;\\n    }\\n\\n    function setautoAddLiquidity(bool isAuto) external onlyOwner {\\n        autoAddLiquidity = isAuto;\\n    }\\n\\n    function setAutoSwapBack(bool isAuto) external onlyOwner {\\n        autoSwapBack = isAuto;\\n    }\\n\\n    /**\\n     * holder limit\\n     * @param limit 100 = 1%, 1=0.01%\\n     */\\n    function setLimitFractional(uint256 limit) external onlyOwner {\\n        if (limit > TEN_THOUSAND) revert InvalidArgs();\\n        limitFractional = limit;\\n    }\\n\\n    function lockAccount(address[] memory users, bool locked) external onlyOwner {\\n        for (uint256 i = 0; i < users.length; i++) {\\n            lockedMap[users[i]] = locked;\\n        }\\n    }\\n\\n    function _basicTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal returns (bool) {\\n\\n        uint256 bl = balanceOf[from];\\n\\n\\n        if (bl < amount) revert ExceedsBalance(from);\\n        unchecked {\\n            balanceOf[from] = bl - amount;\\n            balanceOf[to] += amount;\\n        }\\n        emit Transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    function _transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal validRecipient(recipient) holdThreshold(sender, recipient, amount) returns (bool) {\\n\\n\\n\\n        if (lockedMap[sender]) revert AccountLocked(sender);\\n        if (lockedMap[recipient]) revert AccountLocked(recipient);\\n        if (_inSwap) {\\n\\n            return _basicTransfer(sender, recipient, amount);\\n        } else {\\n            if (shouldAddLiquidity()) {\\n\\n                addLiquidity();\\n\\n            }\\n            if (shouldSwapBack()) {\\n\\n                swapBack();\\n\\n            }\\n\\n            uint256 taxAmount;\\n            if (sender == pair) {\\n                // buy\\n                if (buyTaxFractional > 0) {\\n                    // take buy tax\\n                    taxAmount = (amount / TEN_THOUSAND) * buyTaxFractional;\\n                }\\n            } else if (recipient == pair) {\\n                // sell\\n                if (sellTaxFractional > 0) {\\n                    // take sell tax\\n                    taxAmount = (amount / TEN_THOUSAND) * sellTaxFractional;\\n                }\\n            }\\n\\n            if (taxAmount > 0) {\\n                balanceOf[sender] -= taxAmount;\\n                uint256 autoLpAmount = (taxAmount / TEN_THOUSAND) * autoLpFractional;\\n                uint256 rewardAmount = taxAmount - autoLpAmount;\\n                if (autoLpAmount > 0) {\\n                    balanceOf[address(lpVault)] += autoLpAmount;\\n                    emit Transfer(sender, address(lpVault), autoLpAmount);\\n                }\\n                if (rewardAmount > 0) {\\n                    balanceOf[address(vault)] += rewardAmount;\\n                    emit Transfer(sender, address(vault), rewardAmount);\\n                }\\n            }\\n            return _basicTransfer(sender, recipient, amount - taxAmount);\\n        }\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external override returns (bool transferResult) {\\n\\n        _spendAllowance(from, msg.sender, value);\\n\\n        transferResult = _transferFrom(from, to, value);\\n\\n    }\\n\\n    function transfer(address to, uint256 value) external override returns (bool) {\\n\\n        return _transferFrom(msg.sender, to, value);\\n    }\\n\\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool) {\\n        if (subtractedValue >= allowance[msg.sender][spender]) {\\n            allowance[msg.sender][spender] = 0;\\n        } else {\\n            allowance[msg.sender][spender] -= subtractedValue;\\n        }\\n        emit Approval(msg.sender, spender, allowance[msg.sender][spender]);\\n        return true;\\n    }\\n\\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool) {\\n        allowance[msg.sender][spender] += addedValue;\\n        emit Approval(msg.sender, spender, allowance[msg.sender][spender]);\\n        return true;\\n    }\\n\\n    function approve(address spender, uint256 value) external override returns (bool) {\\n\\n        allowance[msg.sender][spender] = value;\\n        emit Approval(msg.sender, spender, value);\\n        return true;\\n    }\\n    function _burn(address account, uint256 amount) internal virtual {\\n        if (account == address(0)) revert ZeroAddress();\\n        uint256 accountBalance = balanceOf[account];\\n        if (accountBalance < amount) revert ExceedsBalance(account);\\n        unchecked {\\n            balanceOf[account] = accountBalance - amount;\\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    function burn(uint256 amount) public virtual {\\n        _burn(msg.sender, amount);\\n    }\\n    function burnFrom(address account, uint256 amount) public virtual {\\n        _spendAllowance(account, msg.sender, amount);\\n        _burn(account, amount);\\n    }\\n\\n    function _spendAllowance(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        uint256 currentAllowance = allowance[owner][spender];\\n\\n\\n        if (currentAllowance != type(uint256).max) {\\n            if (currentAllowance < amount) revert InsufficientAllowance(owner, spender, amount);\\n            unchecked {\\n                allowance[owner][spender] = currentAllowance - amount;\\n            }\\n        }\\n\\n    }\\n\\n    function swapBack() public swapping {\\n        uint256 amountToSwap = balanceOf[address(vault)];\\n\\n\\n\\n        if (amountToSwap < 10000 ether) {\\n            return;\\n        }\\n        address[] memory path = new address[](2);\\n        path[0] = address(this);\\n        path[1] = weth;\\n\\n\\n\\n        IUniswapV2Router02(address(vault)).swapExactTokensForETHSupportingFeeOnTransferTokens(\\n            amountToSwap,\\n            0,\\n            path,\\n            address(this),\\n            block.timestamp\\n        );\\n\\n    }\\n\\n    function addLiquidity() public swapping {\\n\\n\\n        uint256 autoLiquidityAmount = balanceOf[address(lpVault)];\\n        uint256 amountToLiquify = autoLiquidityAmount / 2;\\n        uint256 amountToSwap = autoLiquidityAmount - amountToLiquify;\\n\\n        if (amountToSwap < 100 ether) {\\n\\n            return;\\n        }\\n\\n        address[] memory path = new address[](2);\\n        path[0] = address(this);\\n        path[1] = weth;\\n\\n\\n\\n        IUniswapV2Router02(address(lpVault)).swapExactTokensForETHSupportingFeeOnTransferTokens(\\n            amountToSwap,\\n            0,\\n            path,\\n            address(lpVault),\\n            block.timestamp\\n        );\\n\\n        uint256 amountToLiquifyEth = address(lpVault).balance;\\n\\n        //\\n        if (amountToLiquify > 0 && amountToLiquifyEth > 0) {\\n\\n            lpVault.addLiquidityETH(address(this), amountToLiquify, 0, 0, address(this), amountToLiquifyEth);\\n        }\\n        lastAddLiquidityTime = block.timestamp;\\n        _seed = random(0, amountToSwap);\\n\\n    }\\n\\n    function shouldAddLiquidity() public view returns (bool) {\\n        return\\n            autoAddLiquidity && !_inSwap && msg.sender != pair && block.timestamp >= (lastAddLiquidityTime + 2 hours);\\n    }\\n\\n    function shouldSwapBack() public view returns (bool) {\\n        return autoSwapBack && !_inSwap && msg.sender != pair;\\n    }\\n\\n    function setRecover(address recover_) external onlyOwner {\\n        recoverAddress = recover_;\\n    }\\n\\n    function emergencyRecover(IERC20 token, uint256 amount) external onlyEmergency {\\n        token.transfer(msg.sender, amount);\\n    }\\n\\n    function emergencyRecoverEth(uint256 amount) external onlyEmergency {\\n        transferETH(msg.sender, amount, false);\\n    }\\n\\n    function emergencyRecoverVault(Vault vault_, uint256 amount) external onlyEmergency {\\n        vault_.recover(amount);\\n    }\\n\\n    function balanceOfEth(address addr) public view returns (uint256) {\\n        return addr.balance;\\n    }\\n\\n    function ticketCycleId(uint256 time) public view returns (uint256) {\\n        uint256 dt = deployTime;\\n        if (time < dt) revert InvalidArgs();\\n        unchecked {\\n            return (time - dt) / CYCLE_DURATION;\\n        }\\n    }\\n\\n    function currentCycleId() public view returns (uint256) {\\n        return ticketCycleId(block.timestamp);\\n    }\\n\\n    function getRandomSeed(address user) internal view returns (uint256) {\\n        return\\n            uint256(\\n                keccak256(\\n                    abi.encodePacked(\\n                        user,\\n                        _seed,\\n                        block.prevrandao,\\n                        block.timestamp,\\n                        blockhash(block.number - 1),\\n                        gasleft()\\n                    )\\n                )\\n            );\\n    }\\n\\n    function random(uint256 min, uint256 max) internal view returns (uint256) {\\n        // inclusive,inclusive (don't use absolute min and max values of uint256)\\n        // deterministic based on seed provided\\n        uint256 diff = max - min + 1;\\n        uint256 randomVar = uint256(keccak256(abi.encodePacked(getRandomSeed(pair)))) % diff;\\n        return randomVar + min;\\n    }\\n\\n    function openLottery(uint256 cycleId) external onlyHuman {\\n\\n\\n        if (cycleId >= currentCycleId()) {\\n            revert InvalidTime();\\n        }\\n        if (ticketUserMap[cycleId][msg.sender].length == 0) {\\n            revert IllegalOperation();\\n        }\\n\\n\\n        RewardCycle storage cycle_ = rewardCycleMap[cycleId];\\n        if (cycle_.opened) revert IllegalOperation();\\n\\n        uint256 ticketCount = ticketCountMap[cycleId];\\n        if (ticketCount == 0) revert LengthMismatch();\\n        uint256 rewardTotal = cycleRewardAmountMap[cycleId];\\n        if (rewardTotal == 0) revert ZeroBalance();\\n        cycle_.totalRewardEth = rewardTotal;\\n        uint256 amount = rewardTotal / WIN_COUNT;\\n\\n\\n\\n        if (ticketCount <= WIN_COUNT) {\\n            uint256 restReward = rewardTotal;\\n            for (uint256 i; i < ticketCount; i++) {\\n                cycle_.winner.push(TicketWinner({ticketId: i, amount: amount, claimed: true}));\\n                address winer = ticketMap[cycleId][i].user;\\n                if (winer == address(0)) revert ZeroAddress();\\n                transferETH(winer, amount, true);\\n                emit Reward(cycleId, winer, amount);\\n                restReward -= amount;\\n            }\\n            transferETH(devAddr, restReward, false);\\n        } else {\\n            uint256[] memory winTicketIdsTmp = new uint256[](WIN_COUNT);\\n\\n            for (uint256 i; i < WIN_COUNT; i++) {\\n                uint256 lastWinTicketId;\\n                if (i == 0) {\\n                    lastWinTicketId = random(0, ticketCount - 1);\\n                    _seed += lastWinTicketId;\\n                    winTicketIdsTmp[i] = lastWinTicketId;\\n                } else {\\n                    while (true) {\\n                        lastWinTicketId = random(0, ticketCount - 1);\\n                        _seed += lastWinTicketId;\\n\\n                        bool duplicate;\\n                        for (uint256 j; j < winTicketIdsTmp.length; j++) {\\n                            if (winTicketIdsTmp[j] == lastWinTicketId) {\\n                                duplicate = true;\\n                                break;\\n                            }\\n                        }\\n                        if (!duplicate) {\\n                            winTicketIdsTmp[i] = lastWinTicketId;\\n                            break;\\n                        }\\n                    }\\n                }\\n                cycle_.winner.push(TicketWinner({ticketId: lastWinTicketId, amount: amount, claimed: true}));\\n                address winer = ticketMap[cycleId][lastWinTicketId].user;\\n                if (winer == address(0)) revert ZeroAddress();\\n                transferETH(winer, amount, true);\\n                emit Reward(cycleId, winer, amount);\\n            }\\n        }\\n        cycle_.opened = true;\\n        emit OpenCycle(msg.sender, cycleId);\\n\\n    }\\n\\n    function stake(uint256 count) external onlyHuman {\\n        if (count == 0) revert InvalidArgs();\\n        _basicTransfer(msg.sender, address(this), count * ticketPrice);\\n\\n        uint256 cycleId = currentCycleId();\\n        uint256 ticketCount = ticketCountMap[cycleId];\\n\\n        for (uint256 i; i < count; i++) {\\n            uint256 currentTicketId = ticketCount + i;\\n            ticketMap[cycleId][currentTicketId] = Ticket({user: msg.sender, redeemed: false});\\n            ticketUserMap[cycleId][msg.sender].push(currentTicketId);\\n        }\\n        ticketCountMap[cycleId] += count;\\n        emit Stake(cycleId, msg.sender, count);\\n    }\\n\\n    function unStake(uint256 cycleId) external onlyHuman previousCycle(cycleId) {\\n        uint256[] memory ticketIds = ticketUserMap[cycleId][msg.sender];\\n        if (ticketIds.length == 0) revert LengthMismatch();\\n\\n        RewardCycle storage cycle_ = rewardCycleMap[cycleId];\\n        if (!cycle_.opened) revert IllegalOperation();\\n\\n        for (uint256 i; i < ticketIds.length; i++) {\\n            Ticket storage ticket = ticketMap[cycleId][ticketIds[i]];\\n            if (ticket.user != msg.sender) revert IllegalOperation();\\n            if (ticket.redeemed) revert IllegalOperation();\\n            ticket.redeemed = true;\\n        }\\n\\n        _basicTransfer(address(this), msg.sender, ticketIds.length * ticketPrice);\\n        emit UnStake(cycleId, msg.sender, ticketIds.length);\\n    }\\n\\n    function continueStake(uint256 previousCycleId) external previousCycle(previousCycleId) {\\n        uint256 cycleId = currentCycleId();\\n\\n        uint256[] memory ticketIds = ticketUserMap[previousCycleId][msg.sender];\\n\\n        if (ticketIds.length == 0) revert LengthMismatch();\\n        RewardCycle storage cycle_ = rewardCycleMap[previousCycleId];\\n\\n        if (!cycle_.opened) revert IllegalOperation();\\n\\n        for (uint256 i; i < ticketIds.length; i++) {\\n            Ticket storage ticket = ticketMap[previousCycleId][ticketIds[i]];\\n            if (ticket.user != msg.sender) revert IllegalOperation();\\n            if (ticket.redeemed) revert IllegalOperation();\\n            ticket.redeemed = true;\\n        }\\n        emit UnStake(previousCycleId, msg.sender, ticketIds.length);\\n\\n        uint256 ticketIdCount = ticketCountMap[cycleId];\\n\\n        for (uint256 i; i < ticketIds.length; i++) {\\n            ticketMap[cycleId][ticketIdCount + i] = Ticket({user: msg.sender, redeemed: false});\\n        }\\n        ticketCountMap[cycleId] = ticketIdCount + ticketIds.length;\\n        emit Stake(cycleId, msg.sender, ticketIds.length);\\n\\n    }\\n\\n    function getAllTicketsDetail(uint256 cycleId) external view returns (TicketDetail[] memory ticketsDetail) {\\n        uint256 ticketCount = ticketCountMap[cycleId];\\n        ticketsDetail = new TicketDetail[](ticketCount);\\n        for (uint256 i; i < ticketCount; i++) {\\n            Ticket storage ticket = ticketMap[cycleId][i];\\n            ticketsDetail[i] = TicketDetail({\\n                ticketCycleId: cycleId,\\n                ticketId: i,\\n                user: ticket.user,\\n                redeemed: ticket.redeemed\\n            });\\n        }\\n    }\\n\\n    function getUserTicketList(uint256 cycleId, address user) external view returns (uint256[] memory ticketIds) {\\n        ticketIds = ticketUserMap[cycleId][user];\\n    }\\n\\n    function getLockedMap(address[] calldata users) external view returns (bool[] memory lockedMap_) {\\n        lockedMap_ = new bool[](users.length);\\n        for (uint256 i; i < users.length; i++) {\\n            lockedMap_[i] = lockedMap[users[i]];\\n        }\\n    }\\n\\n    function chainTime() public view returns (uint256) {\\n        return block.timestamp;\\n    }\\n\\n    function transferETH(\\n        address target,\\n        uint256 amount,\\n        bool isCheck\\n    ) internal validRecipient(target) {\\n        (bool success, ) = target.call{value: amount}(new bytes(0));\\n        if (isCheck) {\\n            if (!success) revert TransferETHFailed(target, amount);\\n        }\\n    }\\n\\n    receive() external payable {\\n\\n        cycleRewardAmountMap[currentCycleId()] += msg.value;\\n\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lmeow/Ownable.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.0;\\n\\nabstract contract Ownable {\\n    address public owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    error OnlyOwnerCancall(address caller);\\n    error ZeroAddress();\\n\\n    constructor() {\\n        _transferOwnership(msg.sender);\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        if (owner != msg.sender) revert OnlyOwnerCancall(msg.sender);\\n        _;\\n    }\\n\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        if (newOwner == address(0)) revert ZeroAddress();\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = owner;\\n        owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 2000\r\n    },\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-gas-snapshot/=lib/permit2/lib/forge-gas-snapshot/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts/=lib/permit2/lib/openzeppelin-contracts/\",\r\n      \"permit2/=lib/permit2/\",\r\n      \"lib/forge-std:ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"lib/permit2:ds-test/=lib/permit2/lib/forge-std/lib/ds-test/src/\",\r\n      \"lib/permit2:forge-gas-snapshot/=lib/permit2/lib/forge-gas-snapshot/src/\",\r\n      \"lib/permit2:forge-std/=lib/permit2/lib/forge-std/src/\",\r\n      \"lib/permit2:openzeppelin-contracts/=lib/permit2/lib/openzeppelin-contracts/\",\r\n      \"lib/permit2:solmate/=lib/permit2/lib/solmate/\"\r\n    ],\r\n    \"viaIR\": true,\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"router_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"AccountLocked\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AlreadySetUp\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"ExceedsBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IllegalOperation\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"InsufficientAllowance\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"InvalidAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidArgs\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidTime\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LengthMismatch\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"MaxHolderLimitExceeded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyHumanCall\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"OnlyOwnerCancall\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TransferETHFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroBalance\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Lock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cycleId\",\"type\":\"uint256\"}],\"name\":\"OpenCycle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"cycleId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Reward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"cycleId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"Stake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"cycleId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"UnStake\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CYCLE_DURATION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TEN_THOUSAND\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WIN_COUNT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"addInitialLP\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"addLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"autoAddLiquidity\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"autoLpFractional\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"autoSwapBack\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"balanceOfEth\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burnFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyTaxFractional\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"chainTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"previousCycleId\",\"type\":\"uint256\"}],\"name\":\"continueStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentCycleId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"cycleRewardAmountMap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deployTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"devAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"devSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"emergencyRecover\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"emergencyRecoverEth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Vault\",\"name\":\"vault_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"emergencyRecoverVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cycleId\",\"type\":\"uint256\"}],\"name\":\"getAllTicketsDetail\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"ticketCycleId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ticketId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"redeemed\",\"type\":\"bool\"}],\"internalType\":\"struct Lmeow.TicketDetail[]\",\"name\":\"ticketsDetail\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"users\",\"type\":\"address[]\"}],\"name\":\"getLockedMap\",\"outputs\":[{\"internalType\":\"bool[]\",\"name\":\"lockedMap_\",\"type\":\"bool[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cycleId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserTicketList\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"ticketIds\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialLPSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialLPSupplyAdded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastAddLiquidityTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"limitFractional\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"users\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"locked\",\"type\":\"bool\"}],\"name\":\"lockAccount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lockedMap\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpVault\",\"outputs\":[{\"internalType\":\"contract Vault\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cycleId\",\"type\":\"uint256\"}],\"name\":\"openLottery\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"recoverAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rewardCycleMap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalRewardEth\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"opened\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellTaxFractional\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"autoLpFractional_\",\"type\":\"uint256\"}],\"name\":\"setAutoLpFractional\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"isAuto\",\"type\":\"bool\"}],\"name\":\"setAutoSwapBack\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"setLimitFractional\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair_\",\"type\":\"address\"}],\"name\":\"setPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recover_\",\"type\":\"address\"}],\"name\":\"setRecover\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"buy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sell\",\"type\":\"uint256\"}],\"name\":\"setTaxBuyAndSellFractional\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"setWithLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"setWithoutLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"isAuto\",\"type\":\"bool\"}],\"name\":\"setautoAddLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"shouldAddLiquidity\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"shouldSwapBack\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapBack\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"teamAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"teamSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ticketCountMap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"ticketCycleId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ticketMap\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"redeemed\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ticketPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ticketUserMap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"transferResult\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cycleId\",\"type\":\"uint256\"}],\"name\":\"unStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vault\",\"outputs\":[{\"internalType\":\"contract Vault\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weth\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"withoutLimitMap\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"Lmeow","CompilerVersion":"v0.8.21+commit.d9974bed","OptimizationUsed":"1","Runs":"2000","ConstructorArguments":"0000000000000000000000007a250d5630b4cf539739df2c5dacb4c659f2488d","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}