{"status":"1","message":"OK","result":[{"SourceCode":"# @version 0.3.10\r\n\"\"\"\r\n@title Generic governor\r\n@author 0xkorin, Yearn Finance\r\n@license GNU AGPLv3\r\n@notice\r\n    Governor for executing arbitrary calls, after passing through a voting procedure.\r\n    Time is divided in 4 week epochs. During the first three weeks, accounts with sufficient\r\n    voting weight are able to submit proposals. In the final week of the epoch all accounts\r\n    are able to vote on all open proposals. If at the end of the epoch the proposal has reached\r\n    a sufficiently high fraction of votes, the proposal has passed and can be enacted through\r\n    the executor.\r\n\r\n    Most parameters are configurable by management. The management role is intended to be \r\n    transferred to the proxy, making the system self-governing.\r\n\"\"\"\r\n\r\ninterface Measure:\r\n    def vote_weight(_account: address) -> uint256: view\r\n\r\ninterface Executor:\r\n    def execute(_script: Bytes[2048]): nonpayable\r\n\r\nstruct Proposal:\r\n    epoch: uint256\r\n    author: address\r\n    ipfs: bytes32\r\n    state: uint256\r\n    hash: bytes32\r\n    yea: uint256\r\n    nay: uint256\r\n    abstain: uint256\r\n\r\ngenesis: public(immutable(uint256))\r\n\r\nmanagement: public(address)\r\npending_management: public(address)\r\n\r\nmeasure: public(address)\r\nexecutor: public(address)\r\npacked_quorum: uint256 # current (120) | previous (120) | epoch (16)\r\npacked_majority: uint256 # current (120) | previous (120) | epoch (16)\r\npacked_delay: uint256 # current (120) | previous (120) | epoch (16)\r\npropose_min_weight: public(uint256)\r\n\r\nnum_proposals: public(uint256)\r\nproposals: HashMap[uint256, Proposal]\r\nvoted: public(HashMap[address, HashMap[uint256, bool]])\r\n\r\nevent Propose:\r\n    idx: indexed(uint256)\r\n    epoch: indexed(uint256)\r\n    author: indexed(address)\r\n    ipfs: bytes32\r\n    script: Bytes[2048]\r\n\r\nevent Retract:\r\n    idx: indexed(uint256)\r\n\r\nevent Cancel:\r\n    idx: indexed(uint256)\r\n\r\nevent Vote:\r\n    account: indexed(address)\r\n    idx: indexed(uint256)\r\n    yea: uint256\r\n    nay: uint256\r\n    abstain: uint256\r\n\r\nevent Enact:\r\n    idx: indexed(uint256)\r\n    by: indexed(address)\r\n\r\nevent SetMeasure:\r\n    measure: indexed(address)\r\n\r\nevent SetExecutor:\r\n    executor: indexed(address)\r\n\r\nevent SetDelay:\r\n    delay: uint256\r\n\r\nevent SetQuorum:\r\n    quorum: uint256\r\n\r\nevent SetMajority:\r\n    majority: uint256\r\n\r\nevent SetProposeMinWeight:\r\n    min_weight: uint256\r\n\r\nevent PendingManagement:\r\n    management: indexed(address)\r\n\r\nevent SetManagement:\r\n    management: indexed(address)\r\n\r\nSTATE_ABSENT: constant(uint256)    = 0\r\nSTATE_PROPOSED: constant(uint256)  = 1\r\nSTATE_PASSED: constant(uint256)    = 2\r\nSTATE_REJECTED: constant(uint256)  = 3\r\nSTATE_RETRACTED: constant(uint256) = 4\r\nSTATE_CANCELLED: constant(uint256) = 5\r\nSTATE_ENACTED: constant(uint256)   = 6\r\n\r\nWEEK: constant(uint256) = 7 * 24 * 60 * 60\r\nEPOCH_LENGTH: constant(uint256) = 4 * WEEK\r\nVOTE_LENGTH: constant(uint256) = WEEK\r\nVOTE_START: constant(uint256) = EPOCH_LENGTH - VOTE_LENGTH\r\nVOTE_SCALE: constant(uint256) = 10_000\r\n\r\nVALUE_MASK: constant(uint256) = 2**120 - 1\r\nPREVIOUS_SHIFT: constant(int128) = -120\r\nEPOCH_MASK: constant(uint256) = 2**16 - 1\r\nEPOCH_SHIFT: constant(int128) = -240\r\n\r\n@external\r\ndef __init__(_genesis: uint256, _measure: address, _executor: address, _quorum: uint256, _majority: uint256, _delay: uint256):\r\n    \"\"\"\r\n    @notice Constructor\r\n    @param _genesis Timestamp of start of epoch 0\r\n    @param _measure Vote weight measure\r\n    @param _executor Governance executor\r\n    @param _quorum Quorum threshold (18 decimals)\r\n    @param _majority Majority threshold (bps)\r\n    @param _delay Vote enactment delay (seconds)\r\n    \"\"\"\r\n    assert _genesis <= block.timestamp\r\n    assert _measure != empty(address)\r\n    assert _executor != empty(address)\r\n    assert _quorum <= VALUE_MASK\r\n    assert _majority >= VOTE_SCALE / 2 and _majority <= VOTE_SCALE\r\n    assert _delay <= VOTE_START\r\n\r\n    genesis = _genesis\r\n    self.management = msg.sender\r\n    self.measure = _measure\r\n    self.executor = _executor\r\n    self.packed_quorum = _quorum\r\n    self.packed_majority = _majority\r\n    self.packed_delay = _delay\r\n    assert self._epoch() > 0\r\n\r\n@external\r\n@view\r\ndef epoch() -> uint256:\r\n    \"\"\"\r\n    @notice Get the current epoch\r\n    @return Current epoch\r\n    \"\"\"\r\n    return self._epoch()\r\n\r\n@internal\r\n@view\r\ndef _epoch() -> uint256:\r\n    \"\"\"\r\n    @notice Get the current epoch\r\n    \"\"\"\r\n    return (block.timestamp - genesis) / EPOCH_LENGTH\r\n\r\n@external\r\n@view\r\ndef propose_open() -> bool:\r\n    \"\"\"\r\n    @notice Query whether the proposal period is currently open\r\n    @return True: proposal period is open, False: proposal period is closed\r\n    \"\"\"\r\n    return self._propose_open()\r\n\r\n@internal\r\n@view\r\ndef _propose_open() -> bool:\r\n    \"\"\"\r\n    @notice Query whether the proposal period is currently open\r\n    \"\"\"\r\n    return (block.timestamp - genesis) % EPOCH_LENGTH < VOTE_START\r\n\r\n@external\r\n@view\r\ndef vote_open() -> bool:\r\n    \"\"\"\r\n    @notice Query whether the vote period is currently open\r\n    @return True: vote period is open, False: vote period is closed\r\n    \"\"\"\r\n    return self._vote_open()\r\n\r\n@internal\r\n@view\r\ndef _vote_open() -> bool:\r\n    \"\"\"\r\n    @notice Query whether the vote period is currently open\r\n    \"\"\"\r\n    return (block.timestamp - genesis) % EPOCH_LENGTH >= VOTE_START\r\n\r\n@external\r\n@view\r\ndef quorum() -> uint256:\r\n    \"\"\"\r\n    @notice \r\n        Get quorum threshold. At least this voting weight must be used\r\n        on a proposal for it to pass\r\n    @return Quorum threshold (18 decimals)\r\n    \"\"\"\r\n    return self.packed_quorum & VALUE_MASK\r\n\r\n@external\r\n@view\r\ndef previous_quorum() -> uint256:\r\n    \"\"\"\r\n    @notice Get quorum threshold required to pass a proposal of previous epoch\r\n    @return Quorum threshold (18 decimals)\r\n    \"\"\"\r\n    return self._quorum(self._epoch() - 1)\r\n\r\n@external\r\n@view\r\ndef majority() -> uint256:\r\n    \"\"\"\r\n    @notice Get majority threshold required to pass a proposal\r\n    @return Majority threshold (bps)\r\n    \"\"\"\r\n    return self.packed_majority & VALUE_MASK\r\n\r\n@external\r\n@view\r\ndef previous_majority() -> uint256:\r\n    \"\"\"\r\n    @notice Get majority threshold required to pass a proposal of previous epoch\r\n    @return Majority threshold (bps)\r\n    \"\"\"\r\n    return self._majority(self._epoch() - 1)\r\n\r\n@internal\r\n@view\r\ndef _quorum(_epoch: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Get quorum threshold of an epoch\r\n    @param _epoch Epoch to query quorum threshold for\r\n    @return Quorum threshold (18 decimals)\r\n    @dev Should only be used to query this or last epoch's value\r\n    \"\"\"\r\n    packed: uint256 = self.packed_quorum\r\n    if _epoch < shift(packed, EPOCH_SHIFT):\r\n        return shift(packed, PREVIOUS_SHIFT) & VALUE_MASK\r\n    return packed & VALUE_MASK\r\n\r\n@internal\r\n@view\r\ndef _majority(_epoch: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Get majority threshold of an epoch\r\n    @param _epoch Epoch to query majority threshold for\r\n    @return Majority threshold (bps)\r\n    @dev Should only be used to query this or last epoch's value\r\n    \"\"\"\r\n    packed: uint256 = self.packed_majority\r\n    if _epoch < shift(packed, EPOCH_SHIFT):\r\n        return shift(packed, PREVIOUS_SHIFT) & VALUE_MASK\r\n    return packed & VALUE_MASK\r\n\r\n@external\r\n@view\r\ndef delay() -> uint256:\r\n    \"\"\"\r\n    @notice Get minimum delay between passing a proposal and its enactment\r\n    @return Enactment delay (seconds)\r\n    \"\"\"\r\n    return self.packed_delay & VALUE_MASK\r\n\r\n@external\r\n@view\r\ndef previous_delay() -> uint256:\r\n    \"\"\"\r\n    @notice Get minimum delay between passing a proposal and its enactment of previous epoch\r\n    @return Enactment delay (seconds)\r\n    \"\"\"\r\n    return self._delay(self._epoch() - 1)\r\n\r\n@internal\r\n@view\r\ndef _delay(_epoch: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Get minimum delay between passing a proposal and its enactment\r\n    @param _epoch Epoch to query delay for\r\n    @return Enactment delay (seconds)\r\n    @dev Should only be used to query this or last epoch's value\r\n    \"\"\"\r\n    packed: uint256 = self.packed_delay\r\n    if _epoch < shift(packed, EPOCH_SHIFT):\r\n        return shift(packed, PREVIOUS_SHIFT) & VALUE_MASK\r\n    return packed & VALUE_MASK\r\n\r\n@external\r\n@view\r\ndef proposal(_idx: uint256) -> Proposal:\r\n    \"\"\"\r\n    @notice Get a proposal\r\n    @param _idx Proposal index\r\n    @return The proposal\r\n    \"\"\"\r\n    proposal: Proposal = self.proposals[_idx]\r\n    proposal.state = self._proposal_state(_idx)\r\n    return proposal\r\n\r\n@external\r\n@view\r\ndef proposal_state(_idx: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Get the state of a proposal\r\n    @param _idx Proposal index\r\n    @return The proposal state\r\n    \"\"\"\r\n    return self._proposal_state(_idx)\r\n\r\n@external\r\ndef update_proposal_state(_idx: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Update the state of a proposal\r\n    @param _idx Proposal index\r\n    @return The proposal state\r\n    \"\"\"\r\n    state: uint256 = self._proposal_state(_idx)\r\n    if state != STATE_ABSENT:\r\n        self.proposals[_idx].state = state\r\n    return state\r\n\r\n@internal\r\n@view\r\ndef _proposal_state(_idx: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Get the state of a proposal\r\n    @dev Determines the pass/reject state based on the relative number of votes in favor\r\n    \"\"\"\r\n    state: uint256 = self.proposals[_idx].state\r\n    if state not in [STATE_PROPOSED, STATE_PASSED]:\r\n        return state\r\n\r\n    current_epoch: uint256 = self._epoch()\r\n    vote_epoch: uint256 = self.proposals[_idx].epoch\r\n    if current_epoch == vote_epoch:\r\n        return STATE_PROPOSED\r\n    \r\n    if current_epoch == vote_epoch + 1:\r\n        yea: uint256 = self.proposals[_idx].yea\r\n        nay: uint256 = self.proposals[_idx].nay\r\n        abstain: uint256 = self.proposals[_idx].abstain\r\n\r\n        counted: uint256 = yea + nay # for majority purposes\r\n        total: uint256 = counted + abstain # for quorum purposes\r\n        if counted > 0 and total >= self._quorum(vote_epoch) and \\\r\n            yea * VOTE_SCALE >= counted * self._majority(vote_epoch):\r\n            return STATE_PASSED\r\n\r\n    return STATE_REJECTED\r\n\r\n@external\r\ndef propose(_ipfs: bytes32, _script: Bytes[2048]) -> uint256:\r\n    \"\"\"\r\n    @notice Create a proposal\r\n    @param _ipfs IPFS CID containing a description of the proposal\r\n    @param _script Script to be executed if the proposal passes\r\n    @return The proposal index\r\n    \"\"\"\r\n    assert self._propose_open()\r\n    assert Measure(self.measure).vote_weight(msg.sender) >= self.propose_min_weight\r\n\r\n    epoch: uint256 = self._epoch()\r\n    idx: uint256 = self.num_proposals\r\n    self.num_proposals = idx + 1\r\n    self.proposals[idx].epoch = epoch\r\n    self.proposals[idx].author = msg.sender\r\n    self.proposals[idx].ipfs = _ipfs\r\n    self.proposals[idx].state = STATE_PROPOSED\r\n    self.proposals[idx].hash = keccak256(_script)\r\n    log Propose(idx, epoch, msg.sender, _ipfs, _script)\r\n    return idx\r\n\r\n@external\r\ndef retract(_idx: uint256):\r\n    \"\"\"\r\n    @notice Retract a proposal. Only callable by proposal author\r\n    @param _idx Proposal index\r\n    \"\"\"\r\n    assert msg.sender == self.proposals[_idx].author\r\n    state: uint256 = self._proposal_state(_idx)\r\n    assert state == STATE_PROPOSED and not self._vote_open()\r\n    self.proposals[_idx].state = STATE_RETRACTED\r\n    log Retract(_idx)\r\n\r\n@external\r\ndef cancel(_idx: uint256):\r\n    \"\"\"\r\n    @notice Cancel a proposal. Only callable by management\r\n    @param _idx Proposal index\r\n    \"\"\"\r\n    assert msg.sender == self.management\r\n    state: uint256 = self._proposal_state(_idx)\r\n    assert state == STATE_PROPOSED or state == STATE_PASSED\r\n    self.proposals[_idx].state = STATE_CANCELLED\r\n    log Cancel(_idx)\r\n\r\n@external\r\ndef vote_yea(_idx: uint256):\r\n    \"\"\"\r\n    @notice Vote in favor of a proposal\r\n    @param _idx Proposal index\r\n    \"\"\"\r\n    self._vote(_idx, VOTE_SCALE, 0, 0)\r\n\r\n@external\r\ndef vote_nay(_idx: uint256):\r\n    \"\"\"\r\n    @notice Vote in opposition of a proposal\r\n    @param _idx Proposal index\r\n    \"\"\"\r\n    self._vote(_idx, 0, VOTE_SCALE, 0)\r\n\r\n@external\r\ndef vote_abstain(_idx: uint256):\r\n    \"\"\"\r\n    @notice Vote in abstention of a proposal\r\n    @param _idx Proposal index\r\n    \"\"\"\r\n    self._vote(_idx, 0, 0, VOTE_SCALE)\r\n\r\n@external\r\ndef vote(_idx: uint256, _yea: uint256, _nay: uint256, _abstain: uint256):\r\n    \"\"\"\r\n    @notice Weighted vote on a proposal\r\n    @param _idx Proposal index\r\n    @param _yea Fraction of votes in favor\r\n    @param _nay Fraction of votes in opposition\r\n    @param _abstain Fraction of abstained votes\r\n    \"\"\"\r\n    self._vote(_idx, _yea, _nay, _abstain)\r\n\r\n@internal\r\ndef _vote(_idx: uint256, _yea: uint256, _nay: uint256, _abstain: uint256):\r\n    \"\"\"\r\n    @notice Weighted vote on a proposal\r\n    \"\"\"\r\n    assert self._vote_open()\r\n    assert self.proposals[_idx].epoch == self._epoch()\r\n    assert self.proposals[_idx].state == STATE_PROPOSED\r\n    assert not self.voted[msg.sender][_idx]\r\n    assert _yea + _nay + _abstain == VOTE_SCALE\r\n\r\n    weight: uint256 = Measure(self.measure).vote_weight(msg.sender)\r\n    assert weight > 0\r\n    self.voted[msg.sender][_idx] = True\r\n    yea: uint256 = 0\r\n    if _yea > 0:\r\n        yea = weight * _yea / VOTE_SCALE\r\n        self.proposals[_idx].yea += yea\r\n    nay: uint256 = 0\r\n    if _nay > 0:\r\n        nay = weight * _nay / VOTE_SCALE\r\n        self.proposals[_idx].nay += nay\r\n    abstain: uint256 = 0\r\n    if _abstain > 0:\r\n        abstain = weight * _abstain / VOTE_SCALE\r\n        self.proposals[_idx].abstain += abstain\r\n    log Vote(msg.sender, _idx, yea, nay, abstain)\r\n\r\n@external\r\ndef enact(_idx: uint256, _script: Bytes[2048]):\r\n    \"\"\"\r\n    @notice Enact a proposal after its vote has passed\r\n    @param _idx Proposal index\r\n    @param _script The script to execute\r\n    \"\"\"\r\n    assert self._proposal_state(_idx) == STATE_PASSED\r\n    assert keccak256(_script) == self.proposals[_idx].hash\r\n    delay: uint256 = self._delay(self._epoch() - 1)\r\n    assert (block.timestamp - genesis) % EPOCH_LENGTH >= delay\r\n\r\n    self.proposals[_idx].state = STATE_ENACTED\r\n    log Enact(_idx, msg.sender)\r\n    Executor(self.executor).execute(_script)\r\n\r\n@external\r\ndef set_measure(_measure: address):\r\n    \"\"\"\r\n    @notice Set vote weight measure contract\r\n    @param _measure New vote weight measure\r\n    \"\"\"\r\n    assert msg.sender == self.management\r\n    assert _measure != empty(address)\r\n    self.measure = _measure\r\n    log SetMeasure(_measure)\r\n\r\n@external\r\ndef set_executor(_executor: address):\r\n    \"\"\"\r\n    @notice Set executor contract\r\n    @param _executor New executor\r\n    \"\"\"\r\n    assert msg.sender == self.management\r\n    assert _executor != empty(address)\r\n    self.executor = _executor\r\n    log SetExecutor(_executor)\r\n\r\n@external\r\ndef set_quorum(_quorum: uint256):\r\n    \"\"\"\r\n    @notice \r\n        Set quorum threshold in 18 decimals. \r\n        Proposals need at least this absolute number of votes to pass\r\n    @param _quorum New quorum threshold (18 decimals)\r\n    \"\"\"\r\n    assert msg.sender == self.management\r\n    assert _quorum <= VALUE_MASK\r\n    epoch: uint256 = self._epoch()\r\n    previous: uint256 = self._quorum(epoch - 1)\r\n    self.packed_quorum = _quorum | shift(previous, -PREVIOUS_SHIFT) | shift(epoch, -EPOCH_SHIFT)\r\n    log SetQuorum(_quorum)\r\n\r\n@external\r\ndef set_majority(_majority: uint256):\r\n    \"\"\"\r\n    @notice \r\n        Set majority threshold in basispoints. \r\n        Proposals need at least this fraction of votes in favor to pass\r\n    @param _majority New majority threshold (bps)\r\n    \"\"\"\r\n    assert msg.sender == self.management\r\n    assert _majority >= VOTE_SCALE / 2 and _majority <= VOTE_SCALE\r\n    epoch: uint256 = self._epoch()\r\n    previous: uint256 = self._majority(epoch - 1)\r\n    self.packed_majority = _majority | shift(previous, -PREVIOUS_SHIFT) | shift(epoch, -EPOCH_SHIFT)\r\n    log SetMajority(_majority)\r\n\r\n@external\r\ndef set_delay(_delay: uint256):\r\n    \"\"\"\r\n    @notice\r\n        Set enactment time delay in seconds. Proposals that passed need to wait \r\n        at least this time before they can be enacted.\r\n    @param _delay New delay (seconds)\r\n    \"\"\"\r\n    assert msg.sender == self.management\r\n    assert _delay <= VOTE_START\r\n    epoch: uint256 = self._epoch()\r\n    previous: uint256 = self._delay(epoch - 1)\r\n    self.packed_delay = _delay | shift(previous, -PREVIOUS_SHIFT) | shift(epoch, -EPOCH_SHIFT)\r\n    log SetDelay(_delay)\r\n\r\n@external\r\ndef set_propose_min_weight(_propose_min_weight: uint256):\r\n    \"\"\"\r\n    @notice Set minimum vote weight required to submit new proposals\r\n    @param _propose_min_weight New minimum weight\r\n    \"\"\"\r\n    assert msg.sender == self.management\r\n    self.propose_min_weight = _propose_min_weight\r\n    log SetProposeMinWeight(_propose_min_weight)\r\n\r\n@external\r\ndef set_management(_management: address):\r\n    \"\"\"\r\n    @notice \r\n        Set the pending management address.\r\n        Needs to be accepted by that account separately to transfer management over\r\n    @param _management New pending management address\r\n    \"\"\"\r\n    assert msg.sender == self.management\r\n    self.pending_management = _management\r\n    log PendingManagement(_management)\r\n\r\n@external\r\ndef accept_management():\r\n    \"\"\"\r\n    @notice \r\n        Accept management role.\r\n        Can only be called by account previously marked as pending management by current management\r\n    \"\"\"\r\n    assert msg.sender == self.pending_management\r\n    self.pending_management = empty(address)\r\n    self.management = msg.sender\r\n    log SetManagement(msg.sender)","ABI":"[{\"name\":\"Propose\",\"inputs\":[{\"name\":\"idx\",\"type\":\"uint256\",\"indexed\":true},{\"name\":\"epoch\",\"type\":\"uint256\",\"indexed\":true},{\"name\":\"author\",\"type\":\"address\",\"indexed\":true},{\"name\":\"ipfs\",\"type\":\"bytes32\",\"indexed\":false},{\"name\":\"script\",\"type\":\"bytes\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Retract\",\"inputs\":[{\"name\":\"idx\",\"type\":\"uint256\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Cancel\",\"inputs\":[{\"name\":\"idx\",\"type\":\"uint256\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Vote\",\"inputs\":[{\"name\":\"account\",\"type\":\"address\",\"indexed\":true},{\"name\":\"idx\",\"type\":\"uint256\",\"indexed\":true},{\"name\":\"yea\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"nay\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"abstain\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Enact\",\"inputs\":[{\"name\":\"idx\",\"type\":\"uint256\",\"indexed\":true},{\"name\":\"by\",\"type\":\"address\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetMeasure\",\"inputs\":[{\"name\":\"measure\",\"type\":\"address\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetExecutor\",\"inputs\":[{\"name\":\"executor\",\"type\":\"address\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetDelay\",\"inputs\":[{\"name\":\"delay\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetQuorum\",\"inputs\":[{\"name\":\"quorum\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetMajority\",\"inputs\":[{\"name\":\"majority\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetProposeMinWeight\",\"inputs\":[{\"name\":\"min_weight\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"PendingManagement\",\"inputs\":[{\"name\":\"management\",\"type\":\"address\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetManagement\",\"inputs\":[{\"name\":\"management\",\"type\":\"address\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"_genesis\",\"type\":\"uint256\"},{\"name\":\"_measure\",\"type\":\"address\"},{\"name\":\"_executor\",\"type\":\"address\"},{\"name\":\"_quorum\",\"type\":\"uint256\"},{\"name\":\"_majority\",\"type\":\"uint256\"},{\"name\":\"_delay\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"epoch\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"propose_open\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"vote_open\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"quorum\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"previous_quorum\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"majority\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"previous_majority\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"delay\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"previous_delay\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"proposal\",\"inputs\":[{\"name\":\"_idx\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"tuple\",\"components\":[{\"name\":\"epoch\",\"type\":\"uint256\"},{\"name\":\"author\",\"type\":\"address\"},{\"name\":\"ipfs\",\"type\":\"bytes32\"},{\"name\":\"state\",\"type\":\"uint256\"},{\"name\":\"hash\",\"type\":\"bytes32\"},{\"name\":\"yea\",\"type\":\"uint256\"},{\"name\":\"nay\",\"type\":\"uint256\"},{\"name\":\"abstain\",\"type\":\"uint256\"}]}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"proposal_state\",\"inputs\":[{\"name\":\"_idx\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"update_proposal_state\",\"inputs\":[{\"name\":\"_idx\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"propose\",\"inputs\":[{\"name\":\"_ipfs\",\"type\":\"bytes32\"},{\"name\":\"_script\",\"type\":\"bytes\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"retract\",\"inputs\":[{\"name\":\"_idx\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"cancel\",\"inputs\":[{\"name\":\"_idx\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"vote_yea\",\"inputs\":[{\"name\":\"_idx\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"vote_nay\",\"inputs\":[{\"name\":\"_idx\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"vote_abstain\",\"inputs\":[{\"name\":\"_idx\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"vote\",\"inputs\":[{\"name\":\"_idx\",\"type\":\"uint256\"},{\"name\":\"_yea\",\"type\":\"uint256\"},{\"name\":\"_nay\",\"type\":\"uint256\"},{\"name\":\"_abstain\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"enact\",\"inputs\":[{\"name\":\"_idx\",\"type\":\"uint256\"},{\"name\":\"_script\",\"type\":\"bytes\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_measure\",\"inputs\":[{\"name\":\"_measure\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_executor\",\"inputs\":[{\"name\":\"_executor\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_quorum\",\"inputs\":[{\"name\":\"_quorum\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_majority\",\"inputs\":[{\"name\":\"_majority\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_delay\",\"inputs\":[{\"name\":\"_delay\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_propose_min_weight\",\"inputs\":[{\"name\":\"_propose_min_weight\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_management\",\"inputs\":[{\"name\":\"_management\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"accept_management\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"genesis\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"management\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"pending_management\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"measure\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"executor\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"propose_min_weight\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"num_proposals\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"voted\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"},{\"name\":\"arg1\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]}]","ContractName":"Generic governor","CompilerVersion":"vyper:0.3.10","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000064d4288000000000000000000000000052574a10ce418afef388e39cea61643d33dba81d00000000000000000000000071258ee726644f1d52d6a9f5e11c21d1e38c2bf10000000000000000000000000000000000000000000000000de0b6b3a764000000000000000000000000000000000000000000000000000000000000000013880000000000000000000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"GNU AGPLv3","Proxy":"0","Implementation":"","SwarmSource":""}]}