{"status":"1","message":"OK","result":[{"SourceCode":"# @version 0.3.7\r\n\"\"\"\r\n@notice Curve Arbitrum Bridge Wrapper\r\n\"\"\"\r\nfrom vyper.interfaces import ERC20\r\n\r\n\r\ninterface GatewayRouter:\r\n    def getGateway(_token: address) -> address: view\r\n    def outboundTransferCustomRefund(  # emits DepositInitiated event with Inbox sequence #\r\n        _token: address,\r\n        _refund_to: address,\r\n        _to: address,\r\n        _amount: uint256,\r\n        _max_gas: uint256,\r\n        _gas_price_bid: uint256,\r\n        _data: Bytes[128],  # _max_submission_cost, _extra_data\r\n    ): payable\r\n    def getOutboundCalldata(\r\n        _token: address,\r\n        _from: address,\r\n        _to: address,\r\n        _amount: uint256,\r\n        _data: Bytes[128]\r\n    ) -> (uint256, uint256): view  # actually returns bytes, but we just need the size\r\n\r\ninterface Inbox:\r\n    def calculateRetryableSubmissionFee(_data_length: uint256, _base_fee: uint256) -> uint256: view\r\n\r\n\r\nevent TransferOwnership:\r\n    _old_owner: address\r\n    _new_owner: address\r\n\r\nevent UpdateSubmissionData:\r\n    _old_submission_data: uint256[2]\r\n    _new_submission_data: uint256[2]\r\n\r\n\r\nGATEWAY: constant(address) = 0xa3A7B6F88361F48403514059F1F16C8E78d60EeC\r\nGATEWAY_ROUTER: constant(address) = 0x72Ce9c846789fdB6fC1f34aC4AD25Dd9ef7031ef\r\nINBOX: constant(address) = 0x4Dbd4fc535Ac27206064B68FfCf827b0A60BAB3f\r\n\r\n\r\nTOKEN: immutable(address)\r\n\r\n\r\n# [gas_limit uint128][gas_price uint128]\r\nsubmission_data: uint256\r\nis_approved: public(HashMap[address, bool])\r\n\r\nowner: public(address)\r\nfuture_owner: public(address)\r\n\r\n\r\n@external\r\ndef __init__(_token: address, _gas_limit: uint256, _gas_price: uint256, _owner: address):\r\n    for value in [_gas_limit, _gas_price]:\r\n        assert value < 2 ** 128\r\n\r\n    TOKEN = _token\r\n    self.submission_data = shift(_gas_limit, 128) + _gas_price\r\n    log UpdateSubmissionData([0, 0], [_gas_limit, _gas_price])\r\n\r\n    assert ERC20(_token).approve(GATEWAY, max_value(uint256), default_return_value=True)\r\n    self.is_approved[_token] = True\r\n\r\n    self.owner = _owner\r\n    log TransferOwnership(empty(address), _owner)\r\n\r\n\r\n@payable\r\n@external\r\ndef bridge(_token: address, _to: address, _amount: uint256):\r\n    \"\"\"\r\n    @notice Bridge an ERC20 token using the Arbitrum standard bridge\r\n    @param _token The address of the token to bridge\r\n    @param _to The address to deposit token to on L2\r\n    @param _amount The amount of `_token` to deposit\r\n    \"\"\"\r\n    assert ERC20(_token).transferFrom(msg.sender, self, _amount, default_return_value=True)\r\n\r\n    if _token != TOKEN and not self.is_approved[_token]:\r\n        assert ERC20(_token).approve(GatewayRouter(GATEWAY_ROUTER).getGateway(_token), max_value(uint256), default_return_value=True)\r\n        self.is_approved[_token] = True\r\n\r\n    data: uint256 = self.submission_data\r\n    gas_limit: uint256 = shift(data, -128)\r\n    gas_price: uint256 = data % 2 ** 128\r\n    submission_cost: uint256 = Inbox(INBOX).calculateRetryableSubmissionFee(\r\n        GatewayRouter(GATEWAY_ROUTER).getOutboundCalldata(\r\n            _token,\r\n            self,\r\n            msg.sender,\r\n            _amount,\r\n            b\"\",\r\n        )[1] + 256,\r\n        block.basefee\r\n    )\r\n\r\n    # NOTE: Excess ETH fee is refunded to this bridger's address on L2.\r\n    # After bridging, the token should arrive on Arbitrum within 10 minutes. If it\r\n    # does not, the L2 transaction may have failed due to an insufficient amount\r\n    # within `max_submission_cost + (gas_limit * gas_price)`\r\n    # In this case, the transaction can be manually broadcasted on Arbitrum by calling\r\n    # `ArbRetryableTicket(0x000000000000000000000000000000000000006e).redeem(redemption-TxID)`\r\n    # The calldata for this manual transaction is easily obtained by finding the reverted\r\n    # transaction in the tx history for 0x000000000000000000000000000000000000006e on Arbiscan.\r\n    # https://developer.offchainlabs.com/docs/l1_l2_messages#retryable-transaction-lifecycle\r\n    GatewayRouter(GATEWAY_ROUTER).outboundTransferCustomRefund(\r\n        _token,\r\n        self.owner,\r\n        _to,\r\n        _amount,\r\n        gas_limit,\r\n        gas_price,\r\n        _abi_encode(submission_cost, b\"\"),\r\n        value=gas_limit * gas_price + submission_cost\r\n    )\r\n\r\n    if self.balance != 0:\r\n        raw_call(msg.sender, b\"\", value=self.balance)\r\n\r\n\r\n@view\r\n@external\r\ndef cost() -> uint256:\r\n    \"\"\"\r\n    @notice Cost in ETH to bridge\r\n    \"\"\"\r\n    submission_cost: uint256 = Inbox(INBOX).calculateRetryableSubmissionFee(\r\n        GatewayRouter(GATEWAY_ROUTER).getOutboundCalldata(\r\n            TOKEN,\r\n            self,\r\n            msg.sender,\r\n            10 ** 36,\r\n            b\"\",\r\n        )[1] + 256,\r\n        block.basefee\r\n    )\r\n    data: uint256 = self.submission_data\r\n    # gas_limit * gas_price\r\n    return shift(data, -128) * data % 2 ** 128 + submission_cost\r\n\r\n\r\n@pure\r\n@external\r\ndef check(_account: address) -> bool:\r\n    \"\"\"\r\n    @notice Verify if `_account` is allowed to bridge using `transmit_emissions`\r\n    @param _account The account calling `transmit_emissions`\r\n    \"\"\"\r\n    return True\r\n\r\n\r\n@external\r\ndef set_submission_data(_gas_limit: uint256, _gas_price: uint256):\r\n    \"\"\"\r\n    @notice Update the arb retryable ticket submission data\r\n    @param _gas_limit The gas limit for the retryable ticket tx\r\n    @param _gas_price The gas price for the retryable ticket tx\r\n    \"\"\"\r\n    assert msg.sender == self.owner\r\n\r\n    for value in [_gas_limit, _gas_price]:\r\n        assert value < 2 ** 128\r\n\r\n    data: uint256 = self.submission_data\r\n    self.submission_data = shift(_gas_limit, 128) + _gas_price\r\n    log UpdateSubmissionData(\r\n        [shift(data, -128), data % 2 ** 128],\r\n        [_gas_limit, _gas_price]\r\n    )\r\n\r\n\r\n@external\r\ndef commit_transfer_ownership(_future_owner: address):\r\n    \"\"\"\r\n    @notice Transfer ownership to `_future_owner`\r\n    @param _future_owner The account to commit as the future owner\r\n    \"\"\"\r\n    assert msg.sender == self.owner  # dev: only owner\r\n\r\n    self.future_owner = _future_owner\r\n\r\n\r\n@external\r\ndef accept_transfer_ownership():\r\n    \"\"\"\r\n    @notice Accept the transfer of ownership\r\n    @dev Only the committed future owner can call this function\r\n    \"\"\"\r\n    assert msg.sender == self.future_owner  # dev: only future owner\r\n\r\n    log TransferOwnership(self.owner, msg.sender)\r\n    self.owner = msg.sender\r\n\r\n\r\n@view\r\n@external\r\ndef gas_limit() -> uint256:\r\n    \"\"\"\r\n    @notice Get gas limit used for L2 retryable ticket\r\n    \"\"\"\r\n    return shift(self.submission_data, -128)\r\n\r\n\r\n@view\r\n@external\r\ndef gas_price() -> uint256:\r\n    \"\"\"\r\n    @notice Get gas price used for L2 retryable ticket\r\n    \"\"\"\r\n    return self.submission_data % 2 ** 128","ABI":"[{\"name\":\"TransferOwnership\",\"inputs\":[{\"name\":\"_old_owner\",\"type\":\"address\",\"indexed\":false},{\"name\":\"_new_owner\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"UpdateSubmissionData\",\"inputs\":[{\"name\":\"_old_submission_data\",\"type\":\"uint256[2]\",\"indexed\":false},{\"name\":\"_new_submission_data\",\"type\":\"uint256[2]\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_gas_limit\",\"type\":\"uint256\"},{\"name\":\"_gas_price\",\"type\":\"uint256\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"bridge\",\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"cost\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"pure\",\"type\":\"function\",\"name\":\"check\",\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_submission_data\",\"inputs\":[{\"name\":\"_gas_limit\",\"type\":\"uint256\"},{\"name\":\"_gas_price\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"commit_transfer_ownership\",\"inputs\":[{\"name\":\"_future_owner\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"accept_transfer_ownership\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"gas_limit\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"gas_price\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"is_approved\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"owner\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"future_owner\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]}]","ContractName":"Vyper_contract","CompilerVersion":"vyper:0.3.7","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"000000000000000000000000afa52e3860b4371ab9d8f08e801e9ea1027c0ca200000000000000000000000000000000000000000000000000000000000186a0000000000000000000000000000000000000000000000000000000000bebc2000000000000000000000000002c3b135cd7dc6c673b358bef214843dab3464278","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":""}]}