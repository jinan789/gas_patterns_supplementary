{"status":"1","message":"OK","result":[{"SourceCode":"# @version 0.3.7\r\n\r\nfrom vyper.interfaces import ERC165\r\nfrom vyper.interfaces import ERC721\r\n\r\nimplements: ERC165\r\nimplements: ERC721\r\n\r\n############ ERC-165 #############\r\n# @dev Static list of supported ERC165 interface ids\r\nSUPPORTED_INTERFACES: constant(bytes4[4]) = [\r\n    0x01ffc9a7,  # ERC165 interface ID of ERC165\r\n    0x80ac58cd,  # ERC165 interface ID of ERC721\r\n    0x5b5e139f,  # ERC165 interface ID of ERC721 Metadata Extension\r\n    # 0x5604e225,  # ERC165 interface ID of ERC4494\r\n    0x2a55205a,  # ERC165 interface ID of ERC2981\r\n]\r\n\r\ninterface WBRC:\r\n    def transferFrom(src:address,dst:address,wad:uint256) -> bool: nonpayable\r\n\r\n############ ERC-721 #############\r\n\r\n# Interface for the contract called by safeTransferFrom()\r\ninterface ERC721Receiver:\r\n    def onERC721Received(\r\n            operator: address,\r\n            owner: address,\r\n            tokenId: uint256,\r\n            data: Bytes[1024]\r\n        ) -> bytes4: nonpayable\r\n\r\n# Interface for ERC721Metadata\r\n\r\ninterface ERC721Metadata:\r\n\tdef name() -> String[64]: view\r\n\r\n\tdef symbol() -> String[32]: view\r\n\r\n\tdef tokenURI(\r\n\t\t_tokenId: uint256\r\n\t) -> String[128]: view\r\n\r\ninterface ERC721Enumerable:\r\n\r\n\tdef totalSupply() -> uint256: view\r\n\r\n\tdef tokenByIndex(\r\n\t\t_index: uint256\r\n\t) -> uint256: view\r\n\r\n\tdef tokenOfOwnerByIndex(\r\n\t\t_address: address,\r\n\t\t_index: uint256\r\n\t) -> uint256: view\r\n\r\nevent Mint:\r\n    minter: indexed(address)\r\n    amt: uint256\r\n\r\n# @dev Emits when ownership of any NFT changes by any mechanism. This event emits when NFTs are\r\n#      created (`from` == 0) and destroyed (`to` == 0). Exception: during contract creation, any\r\n#      number of NFTs may be created and assigned without emitting Transfer. At the time of any\r\n#      transfer, the approved address for that NFT (if any) is reset to none.\r\n# @param owner Sender of NFT (if address is zero address it indicates token creation).\r\n# @param receiver Receiver of NFT (if address is zero address it indicates token destruction).\r\n# @param tokenId The NFT that got transfered.\r\nevent Transfer:\r\n    sender: indexed(address)\r\n    receiver: indexed(address)\r\n    tokenId: indexed(uint256)\r\n\r\n# @dev This emits when the approved address for an NFT is changed or reaffirmed. The zero\r\n#      address indicates there is no approved address. When a Transfer event emits, this also\r\n#      indicates that the approved address for that NFT (if any) is reset to none.\r\n# @param owner Owner of NFT.\r\n# @param approved Address that we are approving.\r\n# @param tokenId NFT which we are approving.\r\nevent Approval:\r\n    owner: indexed(address)\r\n    approved: indexed(address)\r\n    tokenId: indexed(uint256)\r\n\r\n# @dev This emits when an operator is enabled or disabled for an owner. The operator can manage\r\n#      all NFTs of the owner.\r\n# @param owner Owner of NFT.\r\n# @param operator Address to which we are setting operator rights.\r\n# @param approved Status of operator rights(true if operator rights are given and false if\r\n# revoked).\r\nevent ApprovalForAll:\r\n    owner: indexed(address)\r\n    operator: indexed(address)\r\n    approved: bool\r\n\r\nowner: public(address)\r\n\r\n\r\ntotalSupply: public(uint256)\r\n\r\n# @dev TokenID => owner\r\nidToOwner: public(HashMap[uint256, address])\r\n\r\n# @dev Mapping from owner address to count of their tokens.\r\nbalanceOf: public(HashMap[address, uint256])\r\n\r\nbrcBalanceOf: public(HashMap[address, uint256])\r\n\r\n# @dev Mapping from owner address to mapping of operator addresses.\r\nisApprovedForAll: public(HashMap[address, HashMap[address, bool]])\r\n\r\n# @dev Mapping from NFT ID to approved address.\r\nidToApprovals: public(HashMap[uint256, address])\r\n############ ERC-4494 ############\r\n\r\nbaseURI: public(String[100])\r\n\r\n\r\n# @dev amount of Sats of given token\r\namt: public(HashMap[uint256, uint256])\r\nlimit: public(uint256)\r\n# @dev WBRC-20 max supply\r\nmaxWBRC: public(uint256)\r\nmaxWBRCPerAddr: public(uint256)\r\nWBCRSupply: public(uint256)\r\nwbtc: public(address)\r\n\r\nDOMAIN_SEPARATOR: public(bytes32)\r\n\r\nEIP712_DOMAIN_TYPEHASH: constant(bytes32) = keccak256(\r\n    \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\r\n)\r\nEIP712_DOMAIN_NAMEHASH: constant(bytes32) = keccak256(\"Owner NFT\")\r\nEIP712_DOMAIN_VERSIONHASH: constant(bytes32) = keccak256(\"1\")\r\n\r\n\r\n# ERC20 Token Metadata\r\nNAME: constant(String[20]) = \"WBTC Inscription\"\r\nSYMBOL: constant(String[5]) = \"WBTCI\"\r\n# @dev Percentage of royalties for lifetime for the creator\r\n\r\n# genesis block of btc is 2009-1-4 2:15\r\nROYALTY_TO_APPLY_TO_PRICE: constant(decimal) = 1.4215 / 100.0\r\n\r\n@external\r\ndef __init__(_maxWBRC: uint256,_limit: uint256,_maxWBRCPerAddr:uint256, WBTCAddr: address):\r\n    \"\"\"\r\n    @dev Contract constructor.\r\n    \"\"\"\r\n    self.owner = msg.sender\r\n    self.limit  = _limit\r\n    self.maxWBRC = _maxWBRC\r\n    self.wbtc  = WBTCAddr\r\n    self.maxWBRCPerAddr = _maxWBRCPerAddr\r\n    self.baseURI = \"ipfs://bafybeiecwdylwwhyeunthubgg3nhkn5n46d63k57tanbka4qqfwfyubupm\"\r\n    # ERC712 domain separator for ERC4494\r\n    self.DOMAIN_SEPARATOR = keccak256(\r\n        _abi_encode(\r\n            EIP712_DOMAIN_TYPEHASH,\r\n            EIP712_DOMAIN_NAMEHASH,\r\n            EIP712_DOMAIN_VERSIONHASH,\r\n            chain.id,\r\n            self,\r\n        )\r\n    )\r\n# ERC721 Metadata Extension\r\n@pure\r\n@external\r\ndef name() -> String[40]:\r\n    return NAME\r\n\r\n@pure\r\n@external\r\ndef symbol() -> String[5]:\r\n    return SYMBOL\r\n\r\n@view\r\n@external\r\ndef tokenURI(tokenId: uint256) -> String[179]:\r\n    _amt :uint256 = self.amt[tokenId]\r\n    return concat(self.baseURI, \"/\" , uint2str(_amt))\r\n\r\n\r\n@external\r\ndef setBaseURI(_baseURI: String[100]):\r\n    assert msg.sender == self.owner\r\n    self.baseURI = _baseURI\r\n\r\n@external\r\ndef setDomainSeparator():\r\n    \"\"\"\r\n    @dev Update the domain separator in case of a hardfork where chain ID changes\r\n    \"\"\"\r\n    self.DOMAIN_SEPARATOR = keccak256(\r\n        _abi_encode(\r\n            EIP712_DOMAIN_TYPEHASH,\r\n            EIP712_DOMAIN_NAMEHASH,\r\n            EIP712_DOMAIN_VERSIONHASH,\r\n            chain.id,\r\n            self,\r\n        )\r\n    )\r\n\r\n############ ERC-165 #############\r\n\r\n@pure\r\n@external\r\ndef supportsInterface(interface_id: bytes4) -> bool:\r\n    \"\"\"\r\n    @dev Interface identification is specified in ERC-165.\r\n    @param interface_id Id of the interface\r\n    \"\"\"\r\n    return interface_id in SUPPORTED_INTERFACES\r\n\r\n\r\n##### ERC-721 VIEW FUNCTIONS #####\r\n\r\n@view\r\n@external\r\ndef ownerOf(tokenId: uint256) -> address:\r\n    \"\"\"\r\n    @dev Returns the address of the owner of the NFT.\r\n         Throws if `tokenId` is not a valid NFT.\r\n    @param tokenId The identifier for an NFT.\r\n    \"\"\"\r\n    owner: address = self.idToOwner[tokenId]\r\n    # Throws if `tokenId` is not a valid NFT\r\n    assert owner != empty(address)\r\n    return owner\r\n\r\n\r\n@view\r\n@external\r\ndef getApproved(tokenId: uint256) -> address:\r\n    \"\"\"\r\n    @dev Get the approved address for a single NFT.\r\n         Throws if `tokenId` is not a valid NFT.\r\n    @param tokenId ID of the NFT to query the approval of.\r\n    \"\"\"\r\n    # Throws if `tokenId` is not a valid NFT\r\n    assert self.idToOwner[tokenId] != empty(address)\r\n    return self.idToApprovals[tokenId]\r\n\r\n\r\n### TRANSFER FUNCTION HELPERS ###\r\n### Royalty integration under the ERC-2981: NFT Royalty Standard\r\n@view\r\n@external\r\ndef royaltyInfo(_tokenId: uint256, _salePrice: uint256) -> (address, uint256):\r\n    \"\"\"\r\n    /// @notice Called with the sale price to determine how much royalty\r\n    //          is owed and to whom. Important; Not all marketplaces respect this, e.g. OpenSea\r\n    /// @param _tokenId - the NFT asset queried for royalty information\r\n    /// @param _salePrice - the sale price of the NFT asset specified by _tokenId\r\n    /// @return receiver - address of who should be sent the royalty payment\r\n    /// @return royaltyAmount - the royalty payment amount for _salePrice\r\n    \"\"\"\r\n\r\n    royalty: uint256 = convert(convert(_salePrice, decimal) * ROYALTY_TO_APPLY_TO_PRICE, uint256) # Percentage that accepts decimals\r\n    return self.owner, royalty\r\n\r\n@view\r\n@internal\r\ndef _isApprovedOrOwner(spender: address, tokenId: uint256) -> bool:\r\n    \"\"\"\r\n    @dev Returns whether the given spender can transfer a given token ID\r\n    @param spender address of the spender to query\r\n    @param tokenId uint256 ID of the token to be transferred\r\n    @return bool whether the msg.sender is approved for the given token ID,\r\n        is an operator of the owner, or is the owner of the token\r\n    \"\"\"\r\n    owner: address = self.idToOwner[tokenId]\r\n\r\n    if owner == spender:\r\n        return True\r\n\r\n    if spender == self.idToApprovals[tokenId]:\r\n        return True\r\n\r\n    if (self.isApprovedForAll[owner])[spender]:\r\n        return True\r\n\r\n    return False\r\n\r\n\r\n@internal\r\ndef _transferFrom(owner: address, receiver: address, tokenId: uint256, sender: address):\r\n    \"\"\"\r\n    @dev Execute transfer of a NFT.\r\n         Throws unless `msg.sender` is the current owner, an authorized operator, or the approved\r\n         address for this NFT. (NOTE: `msg.sender` not allowed in private function so pass `_sender`.)\r\n         address for thisassert self.idToOwner[tokenId] == owner NFT. (NOTE: `msg.sender` not allowed in private function so pass `_sender`.)\r\n         Throws if `receiver` is the zero address.\r\n         Throws if `owner` is not the current owner.\r\n         Throws if `tokenId` is not a valid NFT.\r\n         \r\n    \"\"\"\r\n    # Check requirements\r\n    assert self._isApprovedOrOwner(sender, tokenId)\r\n    assert receiver != empty(address)\r\n    assert owner != empty(address)\r\n    assert self.idToOwner[tokenId] == owner\r\n\r\n    # Reset approvals, if any\r\n    if self.idToApprovals[tokenId] != empty(address):\r\n        self.idToApprovals[tokenId] = empty(address)\r\n\r\n    # Change the owner\r\n    self.idToOwner[tokenId] = receiver\r\n\r\n    _amt : uint256 = self.amt[tokenId]\r\n    # Change count tracking\r\n    self.balanceOf[owner] -= 1\r\n    self.brcBalanceOf[owner] -= _amt\r\n    # Add count of token to address\r\n    self.balanceOf[receiver] += 1\r\n    self.brcBalanceOf[owner] += _amt\r\n\r\n    # Log the transfer\r\n    log Transfer(owner, receiver, tokenId)\r\n\r\n\r\n@external\r\ndef transferFrom(owner: address, receiver: address, tokenId: uint256):\r\n    \"\"\"\r\n    @dev Throws unless `msg.sender` is the current owner, an authorized operator, or the approved\r\n         address for this NFT.\r\n         Throws if `owner` is not the current owner.\r\n         Throws if `receiver` is the zero address.\r\n         Throws if `tokenId` is not a valid NFT.\r\n    @notice The caller is responsible to confirm that `receiver` is capable of receiving NFTs or else\r\n            they maybe be permanently lost.\r\n    @param owner The current owner of the NFT.\r\n    @param receiver The new owner.\r\n    @param tokenId The NFT to transfer.\r\n    \"\"\"\r\n    self._transferFrom(owner, receiver, tokenId, msg.sender)\r\n\r\n\r\n@external\r\ndef safeTransferFrom(\r\n        owner: address,\r\n        receiver: address,\r\n        tokenId: uint256,\r\n        data: Bytes[1024]=b\"\"\r\n    ):\r\n    \"\"\"\r\n    @dev Transfers the ownership of an NFT from one address to another address.\r\n         Throws unless `msg.sender` is the current owner, an authorized operator, or the\r\n         approved address for this NFT.\r\n         Throws if `owner` is not the current owner.\r\n         Throws if `receiver` is the zero address.\r\n         Throws if `tokenId` is not a valid NFT.\r\n         If `receiver` is a smart contract, it calls `onERC721Received` on `receiver` and throws if\r\n         the return value is not `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\r\n         NOTE: bytes4 is represented by bytes32 with padding\r\n    @param owner The current owner of the NFT.\r\n    @param receiver The new owner.\r\n    @param tokenId The NFT to transfer.\r\n    @param data Additional data with no specified format, sent in call to `receiver`.\r\n    \"\"\"\r\n    self._transferFrom(owner, receiver, tokenId, msg.sender)\r\n    if receiver.is_contract: # check if `receiver` is a contract address\r\n        returnValue: bytes4 = ERC721Receiver(receiver).onERC721Received(msg.sender, owner, tokenId, data)\r\n        # Throws if transfer destination is a contract which does not implement 'onERC721Received'\r\n        assert returnValue == method_id(\"onERC721Received(address,address,uint256,bytes)\", output_type=bytes4)\r\n\r\n@external\r\ndef approve(operator: address, tokenId: uint256):\r\n    \"\"\"\r\n    @dev Set or reaffirm the approved address for an NFT. The zero address indicates there is no approved address.\r\n         Throws unless `msg.sender` is the current NFT owner, or an authorized operator of the current owner.\r\n         Throws if `tokenId` is not a valid NFT. (NOTE: This is not written the EIP)\r\n         Throws if `operator` is the current owner. (NOTE: This is not written the EIP)\r\n    @param operator Address to be approved for the given NFT ID.\r\n    @param tokenId ID of the token to be approved.\r\n    \"\"\"\r\n    # Throws if `tokenId` is not a valid NFT\r\n    owner: address = self.idToOwner[tokenId]\r\n    assert owner != empty(address)\r\n\r\n    # Throws if `operator` is the current owner\r\n    assert operator != owner\r\n\r\n    # Throws if `msg.sender` is not the current owner, or is approved for all actions\r\n    assert owner == msg.sender or (self.isApprovedForAll[owner])[msg.sender]\r\n\r\n    self.idToApprovals[tokenId] = operator\r\n    log Approval(owner, operator, tokenId)\r\n\r\n@external\r\ndef setApprovalForAll(operator: address, approved: bool):\r\n    \"\"\"\r\n    @dev Enables or disables approval for a third party (\"operator\") to manage all of\r\n         `msg.sender`'s assets. It also emits the ApprovalForAll event.\r\n    @notice This works even if sender doesn't own any tokens at the time.\r\n    @param operator Address to add to the set of authorized operators.\r\n    @param approved True if the operators is approved, false to revoke approval.\r\n    \"\"\"\r\n    self.isApprovedForAll[msg.sender][operator] = approved\r\n    log ApprovalForAll(msg.sender, operator, approved)\r\n\r\n@external\r\ndef inscribe(receiver: address, _amt: uint256) -> bool:\r\n    \"\"\"\r\n    @dev Create a new Owner NFT\r\n    @return bool confirming that the minting occurred \r\n    \"\"\" \r\n\r\n    assert receiver != empty(address)\r\n    assert self.limit >= _amt, \"exceed limit of WBRC20\"\r\n    assert self.WBCRSupply + _amt <= self.maxWBRC, \"exceed max of WBRC20\"\r\n    assert _amt % 50 == 0 and _amt > 0, \"amt must be a positive integer multiple of 50\"\r\n    assert self.brcBalanceOf[receiver] + _amt <= self.maxWBRCPerAddr, \"exceed the upper boundd of a single address\"\r\n\r\n    # Throws if `totalSupply` count NFTs tracked by this contract is owned by someone\r\n    assert self.idToOwner[self.totalSupply] == empty(address)\r\n    assert WBRC(self.wbtc).transferFrom(msg.sender,self,_amt) == True, \"fail to transfer wbtc\"\r\n\r\n    # Create new owner to allocate token\r\n    self.idToOwner[self.totalSupply] = receiver\r\n    log Transfer(empty(address), receiver, self.totalSupply)\r\n\r\n    # Change count tracking, `totalSupply` represents id for `tokenId`\r\n    self.amt[self.totalSupply] = _amt\r\n    self.totalSupply += 1\r\n    self.WBCRSupply += _amt\r\n\r\n    # Update balance of minter\r\n    self.balanceOf[receiver] += 1\r\n    self.brcBalanceOf[receiver] += _amt\r\n    \r\n    log Mint(receiver,_amt)\r\n    return True\r\n\r\n@external\r\ndef getBRCAmount(_tokenId:uint256) -> uint256:\r\n    return self.amt[_tokenId]","ABI":"[{\"name\":\"Mint\",\"inputs\":[{\"name\":\"minter\",\"type\":\"address\",\"indexed\":true},{\"name\":\"amt\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Transfer\",\"inputs\":[{\"name\":\"sender\",\"type\":\"address\",\"indexed\":true},{\"name\":\"receiver\",\"type\":\"address\",\"indexed\":true},{\"name\":\"tokenId\",\"type\":\"uint256\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Approval\",\"inputs\":[{\"name\":\"owner\",\"type\":\"address\",\"indexed\":true},{\"name\":\"approved\",\"type\":\"address\",\"indexed\":true},{\"name\":\"tokenId\",\"type\":\"uint256\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"ApprovalForAll\",\"inputs\":[{\"name\":\"owner\",\"type\":\"address\",\"indexed\":true},{\"name\":\"operator\",\"type\":\"address\",\"indexed\":true},{\"name\":\"approved\",\"type\":\"bool\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"_maxWBRC\",\"type\":\"uint256\"},{\"name\":\"_limit\",\"type\":\"uint256\"},{\"name\":\"_maxWBRCPerAddr\",\"type\":\"uint256\"},{\"name\":\"WBTCAddr\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"pure\",\"type\":\"function\",\"name\":\"name\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"string\"}]},{\"stateMutability\":\"pure\",\"type\":\"function\",\"name\":\"symbol\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"string\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"tokenURI\",\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"string\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"setBaseURI\",\"inputs\":[{\"name\":\"_baseURI\",\"type\":\"string\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"setDomainSeparator\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"pure\",\"type\":\"function\",\"name\":\"supportsInterface\",\"inputs\":[{\"name\":\"interface_id\",\"type\":\"bytes4\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"ownerOf\",\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"getApproved\",\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"royaltyInfo\",\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_salePrice\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"transferFrom\",\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"safeTransferFrom\",\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"safeTransferFrom\",\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"approve\",\"inputs\":[{\"name\":\"operator\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"setApprovalForAll\",\"inputs\":[{\"name\":\"operator\",\"type\":\"address\"},{\"name\":\"approved\",\"type\":\"bool\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"inscribe\",\"inputs\":[{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"_amt\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"getBRCAmount\",\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"owner\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"totalSupply\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"idToOwner\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"balanceOf\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"brcBalanceOf\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"isApprovedForAll\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"},{\"name\":\"arg1\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"idToApprovals\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"baseURI\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"string\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"amt\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"limit\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"maxWBRC\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"maxWBRCPerAddr\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"WBCRSupply\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"wbtc\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"DOMAIN_SEPARATOR\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}]}]","ContractName":"Vyper_contract","CompilerVersion":"vyper:0.3.7","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000001406f4000000000000000000000000000000000000000000000000000000000000003e80000000000000000000000000000000000000000000000000000000000004e200000000000000000000000002260fac5e5542a773aa44fbcfedf7c193bc2c599","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":""}]}