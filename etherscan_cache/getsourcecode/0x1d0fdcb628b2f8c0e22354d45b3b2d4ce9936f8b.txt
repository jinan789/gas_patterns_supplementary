{"status":"1","message":"OK","result":[{"SourceCode":"# @version 0.3.10\r\n\"\"\"\r\n@title Gauge registry\r\n@author Yearn Finance\r\n@license GNU AGPLv3\r\n@notice\r\n    Registry for approved gauges.\r\n    Gauges can be added by governance, which makes them eligible\r\n    to be voted on in the gauge controller.\r\n    Each registered gauge corresponds to a unique underlying vault.\r\n\"\"\"\r\n\r\ninterface Controller:\r\n    def whitelist(_gauge: address, _whitelisted: bool): nonpayable\r\n\r\ninterface Factory:\r\n    def gauge_versions(_gauge: address) -> uint256: view\r\n\r\ninterface Gauge:\r\n    def asset() -> address: view\r\n\r\nmanagement: public(address)\r\npending_management: public(address)\r\ncontroller: public(Controller)\r\nfactory: public(Factory)\r\n\r\nvault_count: public(uint256)\r\nvaults: public(address[99999])\r\nvault_gauge_map: public(HashMap[address, address]) # vault => gauge\r\n\r\nevent Register:\r\n    gauge: indexed(address)\r\n    idx: uint256\r\n\r\nevent Deregister:\r\n    gauge: indexed(address)\r\n    idx: uint256\r\n\r\nevent UpdateIndex:\r\n    old_idx: indexed(uint256)\r\n    idx: uint256\r\n\r\nevent SetController:\r\n    controller: address\r\n\r\nevent SetFactory:\r\n    factory: address\r\n\r\nevent PendingManagement:\r\n    management: indexed(address)\r\n\r\nevent SetManagement:\r\n    management: indexed(address)\r\n\r\n@external\r\ndef __init__(_controller: address, _factory: address):\r\n    \"\"\"\r\n    @notice Constructor\r\n    @param _controller Gauge controller\r\n    @param _factory Gauge factory\r\n    \"\"\"\r\n    self.management = msg.sender\r\n    self.controller = Controller(_controller)\r\n    self.factory = Factory(_factory)\r\n\r\n@external\r\n@view\r\ndef gauges(_idx: uint256) -> address:\r\n    \"\"\"\r\n    @notice Get a gauge at a certain index in the list\r\n    @param _idx Index of the gauge\r\n    @return Gauge at the specified index\r\n    \"\"\"\r\n    vault: address = self.vaults[_idx]\r\n    assert vault != empty(address)\r\n    return self.vault_gauge_map[vault]\r\n\r\n@external\r\ndef register(_gauge: address) -> uint256:\r\n    \"\"\"\r\n    @notice Add a gauge to the registry\r\n    @param _gauge Gauge address\r\n    @return Index of the vault\r\n    @dev Gauge has to originate from the factory\r\n    @dev Underlying vault cannot already have a registered gauge\r\n    @dev Only callable by management\r\n    \"\"\"\r\n    assert msg.sender == self.management\r\n    assert self.factory.gauge_versions(_gauge) > 0\r\n    vault: address = Gauge(_gauge).asset()\r\n    assert self.vault_gauge_map[vault] == empty(address)\r\n\r\n    idx: uint256 = self.vault_count\r\n    self.vault_count = idx + 1\r\n    self.vaults[idx] = vault\r\n    self.vault_gauge_map[vault] = _gauge\r\n    self.controller.whitelist(_gauge, True)\r\n    log Register(_gauge, idx)\r\n    return idx\r\n\r\n@external\r\ndef deregister(_gauge: address, _idx: uint256):\r\n    \"\"\"\r\n    @notice Remove a gauge from the registry\r\n    @param _gauge Gauge address\r\n    @param _idx Vault index\r\n    @dev Only callable by management\r\n    \"\"\"\r\n    assert msg.sender == self.management\r\n    vault: address = Gauge(_gauge).asset()\r\n    assert self.vault_gauge_map[vault] == _gauge\r\n    assert self.vaults[_idx] == vault\r\n\r\n    # swap last entry in array with the one being deleted\r\n    # and shorten array by one\r\n    max_idx: uint256 = self.vault_count - 1\r\n    self.vault_count = max_idx\r\n    log Deregister(_gauge, _idx)\r\n    if _idx != max_idx:\r\n        self.vaults[_idx] = self.vaults[max_idx]\r\n        log UpdateIndex(max_idx, _idx)\r\n    self.vaults[max_idx] = empty(address)\r\n    self.vault_gauge_map[vault] = empty(address)\r\n    self.controller.whitelist(_gauge, False)\r\n\r\n@external\r\n@view\r\ndef registered(_gauge: address) -> bool:\r\n    \"\"\"\r\n    @notice Check whether a gauge is registered\r\n    @param _gauge Gauge address\r\n    @return Registration status\r\n    \"\"\"\r\n    vault: address = Gauge(_gauge).asset()\r\n    return self.vault_gauge_map[vault] == _gauge\r\n\r\n@external\r\ndef set_controller(_controller: address):\r\n    \"\"\"\r\n    @notice Set a new gauge controller\r\n    @param _controller New gauge controller\r\n    @dev Only callable by management\r\n    \"\"\"\r\n    assert msg.sender == self.management\r\n    assert _controller != empty(address)\r\n    self.controller = Controller(_controller)\r\n    log SetController(_controller)\r\n\r\n@external\r\ndef set_factory(_factory: address):\r\n    \"\"\"\r\n    @notice Set a new factory\r\n    @param _factory New factory\r\n    @dev Only callable by management\r\n    \"\"\"\r\n    assert msg.sender == self.management\r\n    assert _factory != empty(address)\r\n    self.factory = Factory(_factory)\r\n    log SetFactory(_factory)\r\n\r\n@external\r\ndef set_management(_management: address):\r\n    \"\"\"\r\n    @notice \r\n        Set the pending management address.\r\n        Needs to be accepted by that account separately to transfer management over\r\n    @param _management New pending management address\r\n    \"\"\"\r\n    assert msg.sender == self.management\r\n    self.pending_management = _management\r\n    log PendingManagement(_management)\r\n\r\n@external\r\ndef accept_management():\r\n    \"\"\"\r\n    @notice \r\n        Accept management role.\r\n        Can only be called by account previously marked as pending management by current management\r\n    \"\"\"\r\n    assert msg.sender == self.pending_management\r\n    self.pending_management = empty(address)\r\n    self.management = msg.sender\r\n    log SetManagement(msg.sender)","ABI":"[{\"name\":\"Register\",\"inputs\":[{\"name\":\"gauge\",\"type\":\"address\",\"indexed\":true},{\"name\":\"idx\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Deregister\",\"inputs\":[{\"name\":\"gauge\",\"type\":\"address\",\"indexed\":true},{\"name\":\"idx\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"UpdateIndex\",\"inputs\":[{\"name\":\"old_idx\",\"type\":\"uint256\",\"indexed\":true},{\"name\":\"idx\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetController\",\"inputs\":[{\"name\":\"controller\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetFactory\",\"inputs\":[{\"name\":\"factory\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"PendingManagement\",\"inputs\":[{\"name\":\"management\",\"type\":\"address\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetManagement\",\"inputs\":[{\"name\":\"management\",\"type\":\"address\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"_controller\",\"type\":\"address\"},{\"name\":\"_factory\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"gauges\",\"inputs\":[{\"name\":\"_idx\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"register\",\"inputs\":[{\"name\":\"_gauge\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"deregister\",\"inputs\":[{\"name\":\"_gauge\",\"type\":\"address\"},{\"name\":\"_idx\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"registered\",\"inputs\":[{\"name\":\"_gauge\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_controller\",\"inputs\":[{\"name\":\"_controller\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_factory\",\"inputs\":[{\"name\":\"_factory\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_management\",\"inputs\":[{\"name\":\"_management\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"accept_management\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"management\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"pending_management\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"controller\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"factory\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"vault_count\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"vaults\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"vault_gauge_map\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]}]","ContractName":"Gauge registry","CompilerVersion":"vyper:0.3.10","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"00000000000000000000000046b38522422d597ddbaa2d6e98d6c9b397028d5b00000000000000000000000043cfc64f00b4e45619cfbc7964d982fa022e0b91","EVMVersion":"Default","Library":"","LicenseType":"GNU AGPLv3","Proxy":"0","Implementation":"","SwarmSource":""}]}